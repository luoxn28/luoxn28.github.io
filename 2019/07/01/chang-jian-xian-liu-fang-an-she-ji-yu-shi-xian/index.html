<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>常见限流方案设计与实现 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">常见限流方案设计与实现</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">常见限流方案设计与实现</h1><div class="post-meta">Jul 1, 2019<span> | </span><span class="category"><a href="/categories/分布式/">分布式</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏桶算法"><span class="toc-number">1.</span> <span class="toc-text">漏桶算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#令牌桶算法"><span class="toc-number">2.</span> <span class="toc-text">令牌桶算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动时间窗口算法"><span class="toc-number">3.</span> <span class="toc-text">滑动时间窗口算法</span></a></li></ol></div></div><div class="post-content"><p>高并发系统设计的3个利器：缓存、限流、降级，本文就限流相关算法，分析其设计与实现。</p>
<p>从分布式角度来看，限流可分为<strong>分布式限流</strong>（比如基于Sentinel或者Redis的集群限流）和<strong>单机限流</strong>。从算法实现角度来看，限流算法可分为<strong>漏桶算法</strong>、<strong>令牌桶算法</strong>和<strong>滑动时间窗口算法</strong>。下面主要分析这3种限流算法和分布式限流实现方案。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>把请求比作是水，水来了都先放进桶里，并以恒定速度出水（处理请求），当水流量过大会导致桶溢出，即拒绝服务。请求的最大处理速度也就是水从漏桶流出的速度。</p>
<p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/clipboard-1561974899704.png" alt="img"></p>
<p>基于漏桶（桶+恒定处理速率），可以起到对请求整流效果。漏桶算法可基于线程池来实现，线程池使用固定容量的阻塞队列+固定个数的处理线程来实现；最简单且最常见的漏桶思想的实现就是基于SynchronousQueue的线程池，其相当于一个空桶+固定处理线程 : )。</p>
<blockquote>
<p> 注意：原生的漏桶算法以恒定速度出水（处理请求），但是实际场景中请求的处理耗时可能不相等，为了实现恒定速率，一般都是限定同时处理请求的最大线程数。</p>
</blockquote>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>很多场景中，需要允许某种程度的突发请求，请求的最大速度也就是所有桶大小。这时候漏桶算法就不合适了，令牌桶算法更为适合。</p>
<p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/clipboard.png" alt="img"></p>
<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>
<p>令牌桶算法的一个实现方案是：起一个Timer线程以固定频率往桶中放令牌，桶满时令牌溢出，业务线程在获取令牌时直接从桶中获取即可。该方案容易理解，但是需要一个Timer线程，资源占用较重。</p>
<p>令牌桶算法还有一种实现方案不需要用Timer线程，这个经典实现就是<code>Guava</code>中的<code>RateLimiter</code>。<code>RateLimiter</code>实现原理如下：</p>
<ol>
<li><code>startTick</code>记录RateLimiter初始化时的时间戳（单位ns），后续<code>nowMicros</code>(当前时间点)都是取(System.nanoTime()-startTick)/1000；</li>
<li><code>nextFreeTicketMicros</code>记录下次可获取令牌的开始时间点，在RateLimiter初始化和获取到令牌之后会进行更新；</li>
<li>如果nowMicros大于等于nextFreeTicketMicros，表示可以获取令牌；如果nowMicros大于nextFreeTicketMicros，会计算二者差值并除以放一个令牌的周期，然后赋值给<code>storedPermits</code>字段（表示当前桶中令牌数，注意不能超过桶容量）；</li>
<li>然后storedPermits减去当前需要令牌数，如果此时要获取令牌数大于storedPermits，那么会将nextFreeTicketMicros再往后推进<code>(要获取令牌 - storedPermits) * 放一个令牌的周期</code> 的时间。</li>
</ol>
<p>更具体的步骤及代码实现可参考RateLimiter源码，这里不再赘述。</p>
<blockquote>
<p>从步骤4可以看出，初始化一个RateLimiter.create(100)，是可以执行rateLimiter.tryAcquire(200)的，只不多会将nextFreeTicketMicros再往后推进而已。</p>
</blockquote>
<h3 id="滑动时间窗口算法"><a href="#滑动时间窗口算法" class="headerlink" title="滑动时间窗口算法"></a>滑动时间窗口算法</h3><p>滑动时间窗口算法就是根据当前时间获取对应的时间窗口，时间窗口保存有流量相关的统计值，根据该统计值判断是否触发流控。</p>
<p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/9fc0e4c10c8c.png" alt="img"></p>
<p>一般来说，时间窗口可以循环复用，在复用时重新初始化即可，具体实现可参考sentinel的滑动窗口实现。滑动时间窗口能够支持的瞬时流量最大可为该窗口上限，而令牌桶算法能够支持的瞬时流量最大为桶大小；注意，滑动时间窗口算法中获取token数量一次最大不能超过窗口上限，而RateLimiter实现的令牌桶可以支持一次获取超过桶大小的token。</p>
<p><strong>分布式限流</strong></p>
<p>上述所说的几种限流都是单台机器上的限流算法，有些场景下我们还需要分布式限流，一种是基于Redis做分布式限流，另一种类似于Sentinel分布式限流。</p>
<p><strong>Sentinel</strong></p>
<p>Sentinel分布式限流是启动一个token server服务器，其他sentinel client端就是token client端，当做限流操作时，从token server获取token，获取成功表示未触发限流；否则表示触发了限流；通信出现异常，可配置降级走本地Sentinel限流机制。分布式限流文档：<a href="https://github.com/alibaba/Sentinel/wiki/集群流控" target="_blank" rel="noopener">Sentinel集群流控</a></p>
<p>sentinel的分布式限流是token client调用以下方法到服务端获取token，相当于是每次都会获取acquireCount个token：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取令牌Token， 参数规则Id，获取令牌数，优先级 </span></span><br><span class="line"><span class="function">TokenResult <span class="title">requestToken</span><span class="params">(Long ruleId, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>基于Redis限流</strong></p>
<p>基于Redis做限流操作，使用lua脚本保证命令原子性，比如qps设置为10，如果key不存在，就设置key过期时间1s，value=1；如果value小于10，则自增value；value达到10触发流控。示例lua代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">"rate.limit:"</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, key)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">"INCR"</span>, key) &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, key, expire_time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>常用的限流算法有漏桶、令牌桶和滑动窗口，根据具体场景可选择不同限流算法；如果需要集群限流，可选用Sentinel或者基于Redis做分布式限流。</p>
<blockquote>
<p> 关于Sentinel，估计挺多小伙伴还不知道Sentinel是个什么东东，Sentinel是一个以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的框架。github地址为：<a href="https://github.com/alibaba/Sentinel。" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel。</a></p>
<p>笔者整理了一份《Sentinel不完全指南》，需要的小伙伴可以关注「TopCoder」公众号发送 <code>sentinel</code>来获取，《Sentinel不完全指南》和Sentinel官方文档，二者互为补充，结合起来学习Sentinel效果更好呦 : )</p>
</blockquote>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/">http://luoxn28.github.io/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/" data-id="ckc7rx8ac003xoqcitogp5b1i" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACn0lEQVR42u3awXLiQAwE0Pz/T+9ecksB3dIMIVXPJwqMPY+DNbT09RUf/34cyaebM5P7Hjvw8PDw1kuf3T5nPD//5/uPXj9fMx4eHt5t3qOl5+e0y5oVnno9eHh4eB/Dew5oF9GS8PDw8P4Kb/ZYz8sDHh4e3t/iJWFEHqQmocZmq30la8HDw8OLeflyP+f1lf4eHh4e3rqrnheJWVHZhLnRavHw8PAu8DajA/lwVT5wMBtNeBFJ4OHh4V3j7Rv/SZFoS0VeePDw8PDew2u/kAe7eYybb9nrdhoeHh7eBd7sEbxpYs0e9G1mi4eHh3ePN2vVt5vjJDLYbNzx8PDwfou32V5HmUcZOhzYoOPh4eFd4OWLa6PbttjkDa3hRhwPDw/vKG/D2MPqR3xQYPDw8PBu8zZDVAkvb2ttrhz1+vDw8PAO8fILtT/EZhwhP/9FwcDDw8M7yps1+/PtbBsc5JvsqHTh4eHhXeY9v3QbVZwaR0g+fXg+Hh4e3jXeJh6dBbV5XLsaPsDDw8O7xpsFuJutcx5tzEYc8PDw8O7x2pKw2f5uYo46mZ7NGuDh4eHFK5/97d8PEMwGFJKyVGfVeHh4eCVvFkPst7mzFtdqK4+Hh4d3iNfeZrZrbZeVlJNigAAPDw/vjbwWM3tnNlZVb6Px8PDwjvKS8pAf++u0owkPf0Q8PDy8a7ximOla62t2vFg/Hh4e3lHe7GG9iS1mAwpthPH9Dh4eHt4FXvvwncW7daUKzmzHC/Dw8PDO8vahwKlRgE0bLIpx8fDw8I7y2sZY3irLB7O+Dh0PY1w8PDy8X+VtFt1eYRWF4OHh4X0AL7lxi9lv0/Hw8PDez8vDiDx+3Q8cHPgUDw8P7wKv/XvfNsP2EfCmUOHh4eEd5f0H4a/+K0FDeOYAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/sentinel/">sentinel</a><a href="/tags/服务治理/">服务治理</a></div><div class="post-nav"><a class="pre" href="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/">从Netty NioEventLoop实现中可以学到什么</a><a class="next" href="/2019/06/29/sentinel-dubbo-gua-pei-ji-zhi/">sentinel dubbo适配机制</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-provider-filter-lian-shi-ru-he-gou-jian-de/">Dubbo provider Filter链是如何构建的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-rpc-zai-provider-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在provider端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/dubbo-provider-shi-ru-he-qi-dong-de/">dubbo provider是如何启动的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/dubbo-lian-tong-xing-tao-lun/">Dubbo连通性讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/dubbo-xian-cheng-mo-xing/">Dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/04/dubbo-rpc-zai-consumer-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在consumer端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>