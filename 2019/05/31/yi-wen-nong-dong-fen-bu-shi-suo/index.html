<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>一文弄懂分布式锁 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一文弄懂分布式锁</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">一文弄懂分布式锁</h1><div class="post-meta">May 31, 2019<span> | </span><span class="category"><a href="/categories/分布式/">分布式</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#DB锁"><span class="toc-number">1.</span> <span class="toc-text">DB锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis锁"><span class="toc-number">2.</span> <span class="toc-text">Redis锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis锁续约问题"><span class="toc-number">2.1.</span> <span class="toc-text">Redis锁续约问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper分布式锁"><span class="toc-number">3.</span> <span class="toc-text">zookeeper分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>多线程情况下对共享资源的操作需要加锁，避免数据被写乱，在分布式系统中，这个问题也是存在的，此时就需要一个分布式锁服务。常见的分布式锁实现一般是基于DB、Redis、zookeeper。下面笔者会按照顺序分析下这3种分布式锁的设计与实现，想直接看分布式锁总结的小伙伴可直接翻到文档末尾处。</p>
</blockquote>
<p>分布式锁的实现由多种方式，但是不管怎样，分布式锁一般要有以下特点：</p>
<ul>
<li><strong>排他性</strong>：任意时刻，只能有一个client能获取到锁</li>
<li><strong>容错性</strong>：分布式锁服务一般要满足AP，也就是说，只要分布式锁服务集群节点大部分存活，client就可以进行加锁解锁操作</li>
<li><strong>避免死锁</strong>：分布式锁一定能得到释放，即使client在释放之前崩溃或者网络不可达</li>
</ul>
<p>除了以上特点之外，分布式锁最好也能满足可重入、高性能、阻塞锁特性（AQS这种，能够及时从阻塞状态唤醒）等，下面就话不多说，赶紧上车~</p>
<h2 id="DB锁"><a href="#DB锁" class="headerlink" title="DB锁"></a>DB锁</h2><p>在数据库新建一张表用于控制并发控制，表结构可以如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`lock_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`key_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分布式key'</span>,</span><br><span class="line">  <span class="string">`memo`</span> <span class="built_in">varchar</span>(<span class="number">43</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'可记录操作内容'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>,<span class="string">`key_id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`key_id`</span> (<span class="string">`key_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<p>key_id作为分布式key用来并发控制，memo可用来记录一些操作内容（比如memo可用来支持重入特性，标记下当前加锁的client和加锁次数）。将key_id设置为唯一索引，保证了针对同一个key_id只有一个加锁（数据插入）能成功。此时lock和unlock伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def lock ：</span><br><span class="line">    exec sql: insert into lock_table(key_id, memo, update_time) values (key_id, memo, NOW())</span><br><span class="line">    if result == true :</span><br><span class="line">        return true</span><br><span class="line">    else :</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">def unlock ：</span><br><span class="line">    exec sql: delete from lock_table where key_id = &apos;key_id&apos; and memo = &apos;memo&apos;</span><br></pre></td></tr></table></figure></p>
<p>注意，伪代码中的lock操作是非阻塞锁，也就是tryLock，如果想实现阻塞（或者阻塞超时）加锁，只修反复执行lock伪代码直到加锁成功为止即可。基于DB的分布式锁其实有一个问题，那就是如果加锁成功后，client端宕机或者由于网络原因导致没有解锁，那么其他client就无法对该key_id进行加锁并且无法释放了。为了能够让锁失效，需要在应用层加上定时任务，去删除过期还未解锁的记录，比如删除2分钟前未解锁的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def clear_timeout_lock :</span><br><span class="line">    exec sql : delete from lock_table where update_time &lt;  ADDTIME(NOW(),&apos;-00:02:00&apos;)</span><br></pre></td></tr></table></figure></p>
<p>因为单实例DB的TPS一般为几百，所以基于DB的分布式性能上限一般也是1k以下，一般在并发量不大的场景下该分布式锁是满足需求的，不会出现性能问题。不过DB作为分布式锁服务需要考虑单点问题，对于分布式系统来说是不允许出现单点的，一般通过数据库的同步复制，以及使用vip切换Master就能解决这个问题。</p>
<p>以上DB分布式锁是通过insert来实现的，如果加锁的数据已经在数据库中存在，那么用<code>select xxx where key_id = xxx for udpate</code>方式来做也是可以的。</p>
<h2 id="Redis锁"><a href="#Redis锁" class="headerlink" title="Redis锁"></a>Redis锁</h2><p>Redis锁是通过以下命令对资源进行加锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key_id key_value NX PX expireTime</span><br></pre></td></tr></table></figure></p>
<p>其中，set nx命令只会在key不存在时给key进行赋值，px用来设置key过期时间，key_value一般是随机值，用来保证释放锁的安全性（释放时会判断是否是之前设置过的随机值，只有是才释放锁）。由于资源设置了过期时间，一定时间后锁会自动释放。</p>
<p><code>set nx</code>保证并发加锁时只有一个client能设置成功（Redis内部是单线程，并且数据存在内存中，也就是说redis内部执行命令是不会有多线程同步问题的），此时的lock/unlock伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def lock:</span><br><span class="line">    if (redis.call(&apos;set&apos;, KEYS[1], ARGV[1], &apos;ex&apos;, ARGV[2], &apos;nx&apos;)) then</span><br><span class="line">      return true</span><br><span class="line">    end</span><br><span class="line">      return false</span><br><span class="line">      </span><br><span class="line">def unlock:</span><br><span class="line">    if (redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1]) then</span><br><span class="line">      redis.call(&apos;del&apos;, KEYS[1])</span><br><span class="line">      return true</span><br><span class="line">    end</span><br><span class="line">      return false</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis锁续约问题"><a href="#Redis锁续约问题" class="headerlink" title="Redis锁续约问题"></a>Redis锁续约问题</h3><p>如果一个获取到锁的client因为某种原因导致没能及时释放锁，并且redis因为超时释放了锁，另外一个client获取到了锁，此时情况如下图所示：<br><img src="/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/./一文弄懂分布式锁/20190601104854371.png" alt></p>
<p>那么如何解决这个问题呢，一种方案是引入锁续约机制，也就是获取锁之后，释放锁之前，会定时进行锁续约，比如以锁超时时间的1/3为间隔周期进行锁续约。</p>
<p>关于开源的redis的分布式锁实现有很多，比较出名的有<a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">redisson</a>、百度的<a href="https://github.com/baidu/dlock" target="_blank" rel="noopener">dlock</a>，关于分布式锁，笔者也写了一个简易版的分布式锁redis-lock，主要是增加了锁续约和可同时针对多个key加锁的机制。</p>
<p>对于高可用性，一般可以通过集群或者master-slave来解决，redis锁优势是性能出色，劣势就是由于数据在内存中，一旦缓存服务宕机，锁数据就丢失了。像redis自带复制功能，可以对数据可靠性有一定的保证，但是由于复制也是异步完成的，因此依然可能出现master节点写入锁数据而未同步到slave节点的时候宕机，锁数据丢失问题。</p>
<h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p>ZooKeeper是一个高可用的分布式协调服务，由雅虎创建，是Google Chubby的开源实现。ZooKeeper提供了一项基本的服务：分布式锁服务。zookeeper重要的3个特征是：zab协议、node存储模型和watcher机制。通过zab协议保证数据一致性，zookeeper集群部署保证可用性，node存储在内存中，提高了数据操作性能，使用watcher机制，实现了通知机制（比如加锁成功的client释放锁时可以通知到其他client）。</p>
<p>zookeeper node模型支持临时节点特性，即client写入的数据时临时数据，当客户端宕机时临时数据会被删除，这样就不需要给锁增加超时释放机制了。当针对同一个path并发多个创建请求时，只有一个client能创建成功，这个特性用来实现分布式锁。注意：如果client端没有宕机，由于网络原因导致zookeeper服务与client心跳失败，那么zookeeper也会把临时数据给删除掉的，这时如果client还在操作共享数据，是有一定风险的。</p>
<p>基于zookeeper实现分布式锁，相对于基于redis和DB的实现来说，使用上更容易，效率与稳定性较好。curator封装了对zookeeper的api操作，同时也封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等，使用curator进行分布式加锁示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对zookeeper的底层api的一些封装--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String lockPath = <span class="string">"/curator_recipes_lock_path"</span>;</span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="string">"192.168.193.128:2181"</span>)</span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).build();</span><br><span class="line"></span><br><span class="line">    client.start();</span><br><span class="line">    InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"></span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.acquire();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"zookeeper acquire success: "</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LockSupport.park();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面介绍的3种分布式锁的设计与实现中，我们可以看出每种实现都有各自的特点，针对潜在的问题有不同的解决方案，归纳如下：</p>
<ul>
<li>性能：redis &gt; zookeeper &gt; db。</li>
<li>避免死锁：DB通过应用层设置定时任务来删除过期还未释放的锁，redis通过设置超时时间来解决，而zookeeper是通过临时节点来解决。</li>
<li>可用性：DB可通过数据库同步复制，vip切换master来解决，redis可通过集群或者master-slave方式来解决，zookeeper本身自己是通过zab协议集群部署来解决的。注意，DB和redis的复制一般都是异步的，也就是说某些时刻分布式锁发生故障可能存在数据不一致问题，而zookeeper本身通过zab协议保证集群内(至少n/2+1个)节点数据一致性。</li>
<li>锁唤醒：DB和redis分布式锁一般不支持唤醒机制（也可以通过应用层自己做轮询检测锁是否空闲，空闲就唤醒内部加锁线程），zookeeper可通过本身的watcher/notify机制来做。</li>
</ul>
<p>使用分布式锁，安全性上和多线程（同一个进程内）加锁是没法比的，可能由于网络原因，分布式锁服务（因为超时或者认为client挂了）将加锁资源给删除了，如果client端继续操作共享资源，此时是有隐患的。因此，对于分布式锁，一个是尽量提高分布式锁服务的可用性，另一个就是要部署同一内网，尽量降低网络问题发生几率。这样来看，貌似分布式锁服务不是“完美”的（PS：技术貌似也不好做到十全十美 :( ），那么开发人员该如何选择分布式锁呢？最好是结合自己的业务实际场景，来选择不同的分布式锁实现，一般来说，基于redis的分布式锁服务应用较多。</p>
<p>参考资料：</p>
<ol>
<li><a href="http://weizijun.cn/2016/03/17/%E8%81%8A%E4%B8%80%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">聊一聊分布式锁的设计</a></li>
<li><a href="https://github.com/luoxn28/redis-lock" target="_blank" rel="noopener">https://github.com/luoxn28/redis-lock</a></li>
</ol>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/">http://luoxn28.github.io/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/" data-id="ck8obhpsu002hc7ci78z35sgo" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuElEQVR42u3a0WrrMBAE0Pz/T7evhUucmV0rmMvxU0icVEcFSZ7d1yu+fuKrvf/vt/5+9/r1zRceHh7erUP/955371y/nwz9+lv59OHh4eF9h9cOJV+so0HEjHzMeHh4eM/h5Yfm5DfbCcLDw8P7P3iz7STZHtoNCQ8PD++bvCSMaFPTfHFPgt3jWQseHh5ed9aNBv2c10fqe3h4eHi3NgRcH53buHYWOtSjxcPDwzvAmxWxEkzSdpDECu1k4eHh4Z3mJS1Ws+JWXrhqJyVv/MLDw8P7Di9ffJOS1abt4HokUUiBh4eHd4yXNEVtFv22UWATYXx4VsDDw8Nb8/ZNV3ULVElaNQTg4eHhHeAli34e3bZTsy+qFfU9PDw8vGO8PFSdbQ95W8A+IMbDw8M7zUvi1LYA1m4zs+N7tDHg4eHh3cRrF/EZOCpWlUFwPh14eHh4J3hJY9PswD0baB5/REdwPDw8vFt5s0aB9s62GjWLPKJdDg8PD2/Nmx1z8yW7vXMf6RZNV3h4eHgj3ixIzQ/f7XF51hD2dlR4eHh4B3j7HzrRZNBuOavdDw8PD6/kJct98qSf3L9JmvOpebW7GR4eHt6a1xa92haBWatBPn14eHh4T+AlBbN2S9gv+lF0goeHh3eA17YUzBoOZsW2WRAcTToeHh7empfHAfU8xcv6rJ2r+F/h4eHhHePlV1vIT7aEzTbzobKHh4eHd4A3G25bKtsU24YXHh4e3gHYZjNoS2ibslbe3vq2GxcPDw9vzdussZtQI29EuKH1Cg8PD+8AL9kM2uJ9zp69X3yKh4eHd4w3OxbnRf02qrgtXsHDw8N7AC9vnGpPtnmgUIwNDw8P7zG8PErII93ZL3+YDjw8PLxjvOTPnPi03XjqiBkPDw/vAK9+vA8+zcPWPAI+2KSFh4eHl/J+AX2DnHEf8XdMAAAAAElFTkSuQmCC">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/06/01/concurrenthashmap-jing-ran-ye-you-si-xun-huan/">ConcurrentHashMap竟然也有死循环</a><a class="next" href="/2019/05/19/mysql-ji-chu-gai-nian-zhi-duo-shao/">MySQL基础概念知多少</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/ye-shi-nei-cun-guan-li/">页式内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/group-by-zhong-zi-cha-xun-order-by-pai-xu-shi-xiao-wen-ti-fen-xi/">group by中子查询order by排序失效问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/">Transmittable-Thread-Local：线程间上下文传递解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/xian-cheng-chi-ru-he-chuan-di-xian-cheng-shang-xia-wen-xin-xi/">线程池如何传递线程上下文信息</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/tostring-ru-he-fan-xu-lie-hua/">ToString如何反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/java-bing-fa-gong-ju-lei/">Java并发工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/19/yi-qi-liao-liao-3-ge-xian-cheng-yi-ci-da-yin-1-2-3-de-gu-shi/">一起聊聊3个线程依次打印1、2、3的故事</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/08/kubernetes-zhi-pod-na-xie-shi/">kubernetes之Pod那些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/influxdb-ru-men/">influxdb入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/influxdb-yuan-li-na-xie-shi/">influxdb原理那些事</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>