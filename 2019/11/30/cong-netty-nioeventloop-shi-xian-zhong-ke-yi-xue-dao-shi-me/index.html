<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>从Netty NioEventLoop实现中可以学到什么 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从Netty NioEventLoop实现中可以学到什么</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从Netty NioEventLoop实现中可以学到什么</h1><div class="post-meta">Nov 30, 2019<span> | </span><span class="category"><a href="/categories/框架研究/">框架研究</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoop实现原理"><span class="toc-number">1.</span> <span class="toc-text">EventLoop实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理机制"><span class="toc-number">1.1.</span> <span class="toc-text">事件处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务处理机制"><span class="toc-number">1.2.</span> <span class="toc-text">任务处理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于NioEventLoop实现的思考"><span class="toc-number">2.</span> <span class="toc-text">对于NioEventLoop实现的思考</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>本文主要讨论Netty NioEventLoop原理及实践，关于Netty NioEventLoop，首先要知道NioEventLoop是什么，为什么它会是Netty核心Reactor处理器，实现原理是什么，进而再讨论Netty对其的实现及使用上我们可以学到哪些。</p>
</blockquote>
<p>EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理客户端请求和内部任务，内部任务如ServerSocketChannel注册、ServerSocket绑定和延时任务处理等操作。</p>
<p>EventLoop是由事件驱动的，比如IO事件和任务等，IO事件即selectionKey中ready的事件，如<code>accept、connect、read、write</code>等，由processSelectedKeys方法触发。处理完请求时间之后，会处理内部添加到taskQueue中的任务，如<code>register0、bind0</code>等任务，由runAllTasks方法触发。注意NioEventLoop在Linux中默认底层是基于epoll机制。</p>
<p><img src="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/./从Netty NioEventLoop实现中可以学到什么/image-20191130084720466.png" alt><br>上图是EventLoop的核心流程图，如果从Netty整体视角看EventLoop的事件流转，下图来的更直观：</p>
<p><img src="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/./从Netty NioEventLoop实现中可以学到什么/image-20191130084938960.png" alt></p>
<blockquote>
<p>注意：bossGroup和WorkerGroup中的NioEventLoop流程是一致的，只不过前者处理Accept事件之后将连接注册到后者，由后者处理该连接上后续的读写事件。</p>
</blockquote>
<p>大致了解了NioEventLoop之后，不知道有没有小伙伴有这样的疑问，为什么Netty要这样实现呢，这种实现方案对于我们后续开发如何借鉴呢？关于这些疑问，本文最后讨论哈 :)</p>
<h2 id="EventLoop实现原理"><a href="#EventLoop实现原理" class="headerlink" title="EventLoop实现原理"></a>EventLoop实现原理</h2><p>EventLoop是一个<strong>Reactor模型</strong>的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理IO事件和内部任务。IO事件和内部任务执行时间百分比通过ioRatio来调节，ioRatio表示执行IO时间所占百分比。任务包括普通任务和已经到时的延迟任务，延迟任务存放到一个优先级队列PriorityQueue中，执行任务前从PriorityQueue读取所有到时的task，然后添加到taskQueue中，最后统一执行task。</p>
<h3 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h3><p>EventLoop是由事件驱动的，比如IO事件即selectionKey中ready的事件，如<code>accept、connect、read、write</code>等，处理的核心逻辑主要是在<code>NioEventLoop.run</code>方法中，流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* 如果hasTasks，则调用selector.selectNow()，非阻塞方式获取channel事件，没有channel事件时可能返回为0。这里用非阻塞方式是为了尽快获取连接事件，然后处理连接事件和内部任务。*/</span></span><br><span class="line">      <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">          select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">          <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cancelledKeys = <span class="number">0</span>;</span><br><span class="line">      needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">/* ioRatio调节连接事件和内部任务执行事件百分比</span></span><br><span class="line"><span class="comment">       * ioRatio越大，连接事件处理占用百分比越大 */</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">      <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          runAllTasks();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">          runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上，在执行<code>select()</code>前有一个<code>hasTasks()</code>的操作，这个<code>hasTasks()</code>方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行<code>selector.selectNow()</code>，该方法会立即返回，保证了EventLoop在有任务执行时不会因为IO事件迟迟不来造成延后处理，这里优先处理IO事件，然后再处理任务。</p>
<p>如果当前taskQueue没有任务时，就会执行<code>select(wakenUp.getAndSet(false))</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个方法解决了Nio中臭名昭著的bug：selector的select方法导致空轮询 cpu100% */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* delayNanos(currentTimeNanos)：计算延迟任务队列中第一个任务的到期执行时间（即最晚还能延迟多长时间执行），默认返回1s。每个SingleThreadEventExecutor都持有一个延迟执行任务的优先队列PriorityQueue，启动线程时，往队列中加入一个任务。*/</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/* 如果延迟任务队列中第一个任务的最晚还能延迟执行的时间小于500000纳秒，且selectCnt == 0（selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()），则执行selector.selectNow()方法并立即返回。*/</span></span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 超时阻塞select</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line">            System.out.println(selectCnt);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 有事件到来 | 被唤醒 | 有内部任务 | 有定时任务时，会返回</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// 阻塞超时后没有事件到来，重置selectCnt</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// Selector重建</span></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当java NIO bug触发时，进行Selector重建，rebuildSelector过程如下：</p>
<ol>
<li>通过方法openSelector创建一个新的selector。</li>
<li>将old selector的selectionKey执行cancel。</li>
<li>将old selector的channel重新注册到新的selector中。</li>
</ol>
<p>Netty的连接处理就是IO事件的处理，IO事件包括读事件、ACCEPT事件、写事件和OP_CONNECT事件：</p>
<ul>
<li>ACCEPT事件：连接建立好之后将该连接的channel注册到workGroup中某个NIOEventLoop的selector中；</li>
<li>READ事件：从channel中读取数据，存放到byteBuf中，触发后续的ChannelHandler来处理数据；</li>
<li>WRITE事件：正常情况下一般是不会注册写事件的，如果Socket发送缓冲区中没有空闲内存时，在写入会导致阻塞，此时可以注册写事件，当有空闲内存（或者可用字节数大于等于其低水位标记）时，再响应写事件，并触发对应回调。</li>
<li>CONNECT事件：该事件是client触发的，由主动建立连接这一侧触发的。</li>
</ul>
<h3 id="任务处理机制"><a href="#任务处理机制" class="headerlink" title="任务处理机制"></a>任务处理机制</h3><p>任务处理也就是处理内部任务，这里也包括延时任务，延时任务到时后会移动到taskQueue然后被执行。任务处理是在IO事件处理之后进行的，IO事件和内部任务执行时间百分比可以通过ioRatio来调节，ioRatio表示执行IO时间所占百分比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* timeoutNanos：任务执行花费最长耗时/</span></span><br><span class="line"><span class="comment">protected boolean runAllTasks(long timeoutNanos) &#123;</span></span><br><span class="line"><span class="comment">    // 把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行。</span></span><br><span class="line"><span class="comment">    fetchFromScheduledTaskQueue();</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    // 非阻塞方式pollTask</span></span><br><span class="line"><span class="comment">    Runnable task = pollTask();</span></span><br><span class="line"><span class="comment">    if (task == null) &#123;</span></span><br><span class="line"><span class="comment">        afterRunningAllTasks();</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span></span><br><span class="line"><span class="comment">    long runTasks = 0;</span></span><br><span class="line"><span class="comment">    long lastExecutionTime;</span></span><br><span class="line"><span class="comment">    for (;;) &#123;</span></span><br><span class="line"><span class="comment">        // 执行task</span></span><br><span class="line"><span class="comment">        safeExecute(task);</span></span><br><span class="line"><span class="comment">        runTasks ++;</span></span><br><span class="line"><span class="comment">        // 依次从taskQueue任务task执行，每执行64个任务，进行耗时检查。</span></span><br><span class="line"><span class="comment">        // 如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</span></span><br><span class="line"><span class="comment">        if ((runTasks &amp; 0x3F) == 0) &#123;</span></span><br><span class="line"><span class="comment">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span></span><br><span class="line"><span class="comment">            if (lastExecutionTime &gt;= deadline) &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        task = pollTask();</span></span><br><span class="line"><span class="comment">        if (task == null) &#123;</span></span><br><span class="line"><span class="comment">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    afterRunningAllTasks();</span></span><br><span class="line"><span class="comment">    this.lastExecutionTime = lastExecutionTime;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，任务的处理过程中有个执行一定量任务后的执行时间耗时检查动作，这里是为了避免任务的处理时间过长，影响Netty网络IO的处理效率，毕竟Netty是要处理大量网络IO的。</p>
</blockquote>
<h2 id="对于NioEventLoop实现的思考"><a href="#对于NioEventLoop实现的思考" class="headerlink" title="对于NioEventLoop实现的思考"></a>对于NioEventLoop实现的思考</h2><p>EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理网络IO请求和内部任务，这里的selector和taskQueue是线程内部的。</p>
<p>Netty的BossGroup和WorkerGroup可能包含多个EventLoop，BossGroup接收到请求之后轮询交给WorkerGroup中的其中一个线程（对应一个NioEventLoop）来处理，也就是连接之间的处理是线程独立的，这也就是NioEventLoop流程的无锁化设计。</p>
<p>从EventLoop“无锁化”设计和常见的锁机制对比来看，要实现线程并发安全，有两种实现策略：</p>
<ul>
<li>数据隔离：数据隔离就是数据产生后就提交给不同的线程来处理，线程内部一般有一个数据容器来保存待处理的数据，这里的提交动作需要保证是安全的，比如Netty的BossGroup将建立好的连接注册到WorkerGroup时，是由内核来保证线程安全的（比如Linux就是通过epoll_ctl方法，该方法是线程安全的）；</li>
<li>数据分配：数据产生后统一放在数据容器中，由数据消费线程自己来获取数据进行处理，这里的获取动作需要保证是安全的，一般通过锁机制来保护，比如Java线程池中线程从阻塞队列中获取任务进行执行，就是由阻塞队列保证线程安全。</li>
</ul>
<p>对于数据隔离和数据分配来说，二者都有优缺点及适用场景。对于数据隔离来说，一般“锁”交互少成本较低，并且其隔离性较好，线程内部如果有新数据产生还继续由该线程来处理，但是可能造成数据负载不均衡；对于数据分配来说，“锁”交互较多，但是由于数据处理线程都是从同一数据容器消费数据，所以不会出现数据处理负载不均衡问题。</p>
<blockquote>
<p>如果想实现类似EventLoop中单个线程对应一个处理队列的方案，可以使用只配置一个线程的Java线程池，达到类似的实现效果。</p>
</blockquote>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/">http://luoxn28.github.io/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/" data-id="ck8ri1p1o002r8nci53viq6qc" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADMklEQVR42u3aQXbbMAwE0Nz/0u42XVieAZzWYr5WfVEi8VOLKQB+fcXX49v1/Sf53fwt7c/z59cXNjY29k3Yj8vr2YuTu/kT3vsxri3Y2NjYp7KvY+M6Kq7Z0SIu/+rZ3TwssbGxsbFnwdYGXhuHyXqwsbGxsZOyIYmT4eKCFhI2NjY2dt5UmgXYfsv+cy8NGxsb++PZ7Qj2k//9I/NtbGxs7A9mP0ZXu02zeEveOFw/NjY29kHsNiTyIWu7QTk+h70onLCxsbGPYLdHZ9oWUr73LSx/y4vvjI2NjX1z9vVr8jLjsbjysGzHvS9CFBsbG/todvKCfBDbHs3Zt5aiz4mNjY19BHt2ECdpHiXPzJtH7Za9WC02Njb2Qewk39qm/2aUm7f7k6HCiwjExsbGPoLdjkjbqGtHuT+xBat2EjY2NvbHszcD2lnU7Yuc9m40JMDGxsa+LXs2Xm0P+rQFySaDil4aNjY29hHsPTg/fNMWKpsxc1SoYGNjYx/Bzpvsedso375ks9qPUUcXNjY29hHsvKnUBthmQLvZ6Bebgo2NjX0oe3PsZlYD5W/ZgJ+WItjY2NjHsRNYWzzMomt/TGc408bGxsa+OXsWVHnjvt2OWXMqWjM2Njb2Qewkxjbt/n+ziXkRUhQk2NjY2Ddhbx66aQztR7bt3aKXho2NjX0rdt7WaQe6yaZsmkebsQQ2Njb2eey2/MijblY8zEqR9gNgY2Njn8GeNd+TTalLguAJmw/w111sbGzsg9htMLRD4rxJlI8Q2rVhY2Njn83OQ2UzHshb//nhnjwIh98WGxsb+ybsTVQki0gKkg27DUVsbGzs89izNtCsUGnLmHasm28iNjY29knsJDDykGsP9GxiNd/6qH+GjY2NfVv25j/9xbnOeBA7GyrUxQk2Njb2Qez8Sh46O5rZ/u0sRLGxsbHPZrehNRsJb34/37hizdjY2NjHsdtgSJo++zHwu5pKTwMMGxsb+5ex87Ih2b5NGbMpcrCxsbF/M7ttx78rzJKtqbtl2NjY2Mex2+HurLR4tvT8k+TPfPGb2NjY2Aex25B78wy53I7rMJu1n7CxsbFvy/4DgjrJXUsUjvMAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/netty/">netty</a></div><div class="post-nav"><a class="pre" href="/2019/11/30/nio-epoll-bug-dao-di-shi-shi-me/">nio epoll bug到底是什么</a><a class="next" href="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/">常见限流方案设计与实现</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/wang-luo-shu-ju-shi-ru-he-chuan-di-gei-jin-cheng-de/">网络数据是如何传递给进程的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/">进程是如何调度的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/">从sockert api看网络通信流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/">谈一谈TCP的4次挥手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/">深入理解TCP的3次握手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/linux-xin-hao/">Linux信号</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>