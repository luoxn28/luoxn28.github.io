<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>Docker命令 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Docker命令</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Docker命令</h1><div class="post-meta">Dec 29, 2019<span> | </span><span class="category"><a href="/categories/分布式/">分布式</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端命令"><span class="toc-number">1.</span> <span class="toc-text">客户端命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像命令"><span class="toc-number">1.1.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器命令"><span class="toc-number">1.2.</span> <span class="toc-text">容器命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-run参数"><span class="toc-number">1.3.</span> <span class="toc-text">docker run参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作容器"><span class="toc-number">1.4.</span> <span class="toc-text">操作容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端命令"><span class="toc-number">2.</span> <span class="toc-text">服务端命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker命令图谱"><span class="toc-number">3.</span> <span class="toc-text">Docker命令图谱</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>学习Docker，首先需要了解Docker基本概念，然后就开始“动手”了（也就是敲Docker命令）。Docker命令较多，这里笔者总结下常用的Docker命令，方便小伙伴们查阅。</p>
</blockquote>
<p>Docker是基于go语言开发，底层技术（Linux下）主要基于cgroups、namespace以及联合文件技术实现的一种进程级别的轻量级虚拟化解决方案。由于Docker进程隔离独立于宿主机上其他进程，因此也称为容器，Docker在容器的基础上，进行了更进一步的封装，从文件系统、网络到进程隔离等，极大简化了容器的创建管理维护工作，降低了开发者使用门槛，因此才在近几年流行开来（毕竟Docker的底层技术在Docker出现之前就已经存在了）。</p>
<p>Docker命令有2大类，分别是服务端命令和客户端命令，前者是操作docker服务端（dockerd），后者也就是开发者常用的docker命令，更多Docker命令可以使用 <code>docker help</code> 查看。</p>
<ul>
<li>客户端命令：基本命令格式为docker [OPTIONS] COMMAND [arg…]；</li>
<li>服务端命令：基本命令格式为dockerd [OPTIONS]。</li>
</ul>
<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p>centos下安装docker可使用命令<code>yum install docker</code>，mac下需要安装docker-for-mac，使用命令 <code>wget http://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/Docker.dmg</code>。安装完成之后可以使用如下命令使用Docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service docker start  启动docker服务</span><br><span class="line">docker version/info   查看docker版本/信息</span><br><span class="line">docker inspect  查看容器详细信息</span><br><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; xxxx   查看容器对应的pid</span><br><span class="line">docker logs 查看对应容器日志</span><br></pre></td></tr></table></figure>
<p>Docker有两个基本概念：镜像和容器，前者是打包后可执行的容器文件，后者是运行中的Docker实例，二者关系类似 <code>可执行文件</code> 和 <code>进程</code> 的概念。</p>
<h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p>镜像相关命令有搜索、查看、删除、存档和加载等，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker images  查看所有本地镜像，或者使用命令 docker image ls</span><br><span class="line">docker search xxx   搜索官方仓库中的镜像</span><br><span class="line">docker pull xxx:tag    下载镜像，也可以使用docker push 推送自己的镜像，docker run xxx命令会启动容器，当本地没有容器镜像是会从仓库中拉取</span><br><span class="line">docker rmi imageName   删除本地一个或多个镜像，注意不要和docker rm删除容器命令混淆</span><br><span class="line">docker rm xxx 删除一个或多个容器</span><br><span class="line">docker <span class="built_in">history</span> ubuntu:18.04  查看Ubuntu镜像的创建过程（各个层内容）</span><br><span class="line">docker save -o ubuntu_18.04.tar ubuntu:18.04   导出镜像到本地文件ubuntu_18.04.tar</span><br><span class="line">docker load -i ubuntu_18.04.tar  加载镜像，或者使用命令 docker &lt; ubuntu_18.04.tar</span><br></pre></td></tr></table></figure>
<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><p>围绕容器，Docker提供了十分丰富的操作命令，允许用户高效地管理容器的整个生命周期。可以使用<code>docker container help</code>命令查看Docker支持的容器操作子命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker ps  列出所有运行中的容器</span><br><span class="line">docker ps -a  列出所有容器，包括停止状态的</span><br><span class="line">docker ps -a -q   列出所有镜像的id</span><br><span class="line">docker rm containerId   删除某一个镜像</span><br><span class="line">docker rm $(docker ps -a -q)  删除所有处于终止状态的容器，注意不能删除正在运行中的容器</span><br><span class="line">docker run -it --rm ubuntu:14:04  bash       -it 这是两个参数，-t是开一个终端（伪终端绑定到容器的标准输入上），-i是交互式命令让容器的标准输入保持打开。--rm是容器退出后删除，默认情况下容器退出不会自动删除，方便排查问题。ubuntu:14:04使用的启动镜像。bash放在镜像后面的命令。执行<span class="built_in">exit</span>命令从容器中退出时，容器会自动退出。有时候需要让容器已后台守护态运行，此时需要增加-d参数，比如docker urn -d ubuntu。</span><br><span class="line">docker run ubuntu  <span class="built_in">echo</span> <span class="string">"hello world"</span>   在docker容器中运行命令输出hello world</span><br><span class="line">docker start containerId   启动处于created状态的容器</span><br><span class="line">docker resetart containerId   重启处于运行状态的容器</span><br><span class="line">docker stop containerId   停止容器运行</span><br><span class="line">docker logs xxx 查看容器xxx输出信息</span><br><span class="line">docker pause  [container]  暂停容器，恢复使用命令docker unpause xxx</span><br><span class="line">docker inspect [container] 查看容器的详细信息，创建时间、路径、状态配置等详细信息。</span><br><span class="line">docker top  [container]   查看容器内进程信息。</span><br><span class="line">docker stats   [container]   查看容器的CPU、内存、网络等统计信息，支持选项有：-a:输出所有统计信息，默认只输出运行中信息；-no-stream:不持续输出，默认会自动更新统计结果。</span><br><span class="line">docker cp zzz.txt 26755872da4d:/tmp：将本地zzz.txt文件复制到容器26755872da4d的/tmp目录下，也可以使用命令将容器内文件复制到本地机器，docker cp 26755872da4d:/tmp/zzz.txt /tmp。</span><br><span class="line">docker container  diff 26755872da4d：container diff命令查看容器内文件系统的变更。</span><br><span class="line">docker container  port 26755872da4d：查看容器端口映射。</span><br><span class="line">docker update --cpus 4 26755872da4d：限定容器使用CPU个数为4</span><br></pre></td></tr></table></figure>
<p><strong>container update</strong>命令可以更新容器的一些运行时配置，主要是一些资源限制份额。命令格式为docker [container] update [OPTIONS] CONTAINER [CONTAINER…]，支持的操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❑ -blkio-weight uint16：更新块IO限制，10～1000，默认值为0，代表着无限制；</span><br><span class="line">❑ -cpu-period int：限制CPU调度器CFS（Completely Fair Scheduler）使用时间，单位为微秒，最小1000；</span><br><span class="line">❑ -cpu-quota int：限制CPU调度器CFS配额，单位为微秒，最小1000；</span><br><span class="line">❑ -cpu-rt-period int：限制CPU调度器的实时周期，单位为微秒；</span><br><span class="line">❑ -cpu-rt-runtime int：限制CPU调度器的实时运行时，单位为微秒；</span><br><span class="line">❑ -c, -cpu-shares int：限制CPU使用份额；</span><br><span class="line">❑ -cpus decimal：限制CPU个数；</span><br><span class="line">❑ -cpuset-cpus string：允许使用的CPU核，如0-3,0,1；</span><br><span class="line">❑ -cpuset-mems string：允许使用的内存块，如0-3,0,1；</span><br><span class="line">❑ -kernel-memory bytes：限制使用的内核内存；</span><br><span class="line">❑ -m, -memory bytes：限制使用的内存；</span><br><span class="line">❑ -memory-reservation bytes：内存软限制；</span><br><span class="line">❑ -memory-swap bytes：内存加上缓存区的限制，-1表示为对缓冲区无限制；</span><br><span class="line">❑ -restart string：容器退出后的重启策略。</span><br></pre></td></tr></table></figure>
<h4 id="docker-run参数"><a href="#docker-run参数" class="headerlink" title="docker run参数"></a>docker run参数</h4><p>docker run 启动容器，可以指定参数设置容器启动策略，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d  容器会在后台运行并不会把输出（STDOUT）打印到宿主机上</span><br><span class="line">-t  让docker分配一个伪终端并绑定到容器的标准输入上</span><br><span class="line">-i  让容器的标准输入保持打开</span><br><span class="line">-p 映射本地端口和容器端口，格式为-p ip:hostPort:containerPort或者-p hostPort:containerPort。</span><br><span class="line">-P 大写的P，使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</span><br><span class="line">--rm   在容器执行完毕后将其删除，默认只能删除已停止的容器，如果想要删除正在运行中容器，可增加-f参数。</span><br><span class="line">--name   xxx   执行容器的name</span><br></pre></td></tr></table></figure>
<p><em>注意，容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</em>。</p>
<h4 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h4><p><strong>进入容器</strong></p>
<p>容器运行过程中，常常需要进入容器中执行操作场景，可使用如下命令进入容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attach：使用命令docker attach containerId/names进入容器，但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。注意，进入容器后，如果使用<span class="built_in">exit</span>退出容器，那么容器也会停止运行，可以使用命令Ctrl+P+Q来退出但不关闭容器。</span><br><span class="line">nsenter：nsenter 启动一个新的shell进程(默认是/bin/bash)，同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限</span><br><span class="line"><span class="built_in">exec</span>：使用<span class="built_in">exec</span>命令更加便捷，docker <span class="built_in">exec</span> -it 775c7c9ee1e1 /bin/bash  ，很方便的进入容器</span><br></pre></td></tr></table></figure>
<p><strong>导入/导出容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> -o test.tar [container]   将某个容器导出到本地</span><br><span class="line">docker import test.tar  导入某个容器导出文件（容器导出为镜像文件，这里相当于加载镜像文件）。实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker[container] import命令来导入一个容器快照到本地镜像库。这两者的区别在于：容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>
<p><strong>端口映射</strong></p>
<p>在启动容器的时候，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-P或-p参数来指定端口映射。当使用-P（大写的）标记时，Docker会随机映射一个49000～49900的端口到内部容器开放的网络端口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">500</span>:<span class="number">5000</span> xxxwebapp python app.py：启动容器并运行python app.py程序，映射本地<span class="number">500</span>端口到容器<span class="number">5000</span>端口。或者使用docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">500</span>:<span class="number">5000</span> xxxwebapp python app.py指定特定地址。</span><br><span class="line">docker run -it --name zzz ubuntu bash</span><br><span class="line">docker run -it --name zzz2 --link zzz:zzz ubuntu bash   zzz2容器和zzz容器建立互联关系。</span><br><span class="line">    --link参数的格式为--link name:alias，其中name是要链接的容器的名称，alias是别名。</span><br><span class="line">    Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射它们的端口到宿主主机上。</span><br><span class="line">    在启动db容器的时候并没有使用-p和-P标记，从而避免了暴露数据库服务端口到外部网络上。</span><br></pre></td></tr></table></figure>
<p><strong>数据管理</strong></p>
<p>Docker的数据管理主要分为2种：</p>
<ul>
<li>数据卷：容器内数据直接映射到本地；</li>
<li>数据卷容器：特定容器维护数据卷。</li>
</ul>
<p>数据卷（Data Volumes）是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount行为。如果直接挂载一个文件到容器，使用文件编辑工具，包括vi或者sed –in-place的时候，可能会造成文件inode的改变。从Docker 1.1.0起，这会导致报错误信息。所以推荐的方式是直接挂载文件所在的目录到容器内。</p>
<h3 id="服务端命令"><a href="#服务端命令" class="headerlink" title="服务端命令"></a>服务端命令</h3><p>dockerd命令负责启动服务端主进程，支持的命令选项如下表所示：</p>
<p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123704525.png" alt></p>
<p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123752366.png" alt></p>
<p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123800615.png" alt></p>
<h3 id="Docker命令图谱"><a href="#Docker命令图谱" class="headerlink" title="Docker命令图谱"></a>Docker命令图谱</h3><p>最后来一张Docker图谱作为结尾吧：</p>
<p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123859256.png" alt></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/12/29/docker-ming-ling/">http://luoxn28.github.io/2019/12/29/docker-ming-ling/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/12/29/docker-ming-ling/" data-id="ckc7rx86p0003oqcidb0s71mf" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJ0lEQVR42u3aQW7DMAwEwPz/0+m5SOPuUnFRy6NTkSqxxgeCIvl4xOv5spI9yc53/32csTAwMC7LeB6u5Igz5DtS8twfnoKBgXEDxnHge91zfJTk6MeRMz8bBgYGRrInWTkMAwMD47MB9zgdbK/EeWjGwMC4JyMJlG3JbJY+nn4Xx8DAuCAjD5F///cp/Q0MDIxLMZ7lysttbXFtZWFgYOzNyAPcLNVbaZS258HAwNiVcd7DVvbUMAwMjK0ZSUhdbwO06WPe5vyldoiBgbERY/0BbeNzZf+J7wkDA+NfMvICWTvO1aab0ThFMi2CgYGxHaP9Wj4S0bYEkk/q4IuBgbEFYxb+2vtx+yLqRikGBsbWjCRetc2D2aU3/7Wo3IaBgbEpY9YyzK+mbSktYT/y2IyBgXFZxkrjML+gzpLO4hVgYGBszVhJ4PKHzV5WfWHGwMDYmtEWwtrDJelj27CsmwQYGBiXZbRDWm2ymHw+A3z7LgYGxtaM9ro4HNVauKDORsowMDD2Y8wStfZh+cV1+PowMDBuw1hpFbRBc705ioGBcWdGWzg7piYDEy0MAwPjPoxnuT5VSpv9QtHTwMDA2IiRrzaxWx8pGw5bYGBgbMpoU708UOaFvFnAxcDAuBsjD3x5oW32moahHwMDA2M0TrFSdKsHOzAwMDDiAx3/2hkNUQwMjPsw8qGutpG5XmiLmgoYGBhbM2Yl/jxBnO1Mrs0YGBg3YHwBggxqmICkJ9QAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/docker/">docker</a></div><div class="post-nav"><a class="pre" href="/2020/01/04/cgroup-yuan-li-jie-xi/">cgroup原理解析</a><a class="next" href="/2019/12/21/ru-he-you-ya-di-zhi-xing-dubbo-dan-ce/">如何优雅地执行dubbo&quot;单测&quot;</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-provider-filter-lian-shi-ru-he-gou-jian-de/">Dubbo provider Filter链是如何构建的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-rpc-zai-provider-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在provider端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/dubbo-provider-shi-ru-he-qi-dong-de/">dubbo provider是如何启动的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/dubbo-lian-tong-xing-tao-lun/">Dubbo连通性讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/dubbo-xian-cheng-mo-xing/">Dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/04/dubbo-rpc-zai-consumer-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在consumer端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>