<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>深入理解ConcurrentHashMap | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入理解ConcurrentHashMap</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入理解ConcurrentHashMap</h1><div class="post-meta">Jun 19, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node结构"><span class="toc-number">1.</span> <span class="toc-text">Node结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put流程"><span class="toc-number">2.</span> <span class="toc-text">put流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get流程"><span class="toc-number">3.</span> <span class="toc-text">get流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remove流程"><span class="toc-number">4.</span> <span class="toc-text">remove流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rehash流程"><span class="toc-number">5.</span> <span class="toc-text">rehash流程</span></a></li></ol></div></div><div class="post-content"><p>以下ConcurrentHashMap以jdk8中为例进行分析，ConcurrentHashMap是一个线程安全、基于数组+链表(或者红黑树)的kv容器，主要特性如下：</p>
<ul>
<li>线程安全，数组中单个slot元素个数超过8个时会将链表结构转换成红黑树，注意树节点之间还是有next指针的；</li>
<li>当元素个数超过N（<code>N = tab.length - tab.length&gt;&gt;&gt;2，达到0.75阈值时</code>）个时触发rehash，成倍扩容；</li>
<li>当线程扩容时，其他线程put数据时会加入帮助扩容，加快扩容速度；</li>
<li>put时对单个slot头节点元素进行synchronized加锁，ConcurrentHashMap中的加锁粒度是针对slot节点的，rehash过程中加锁粒度也是如此；</li>
<li>get时一般是不加锁。如果slot元素为链表，直接读取返回即可；如果slot元素为红黑树，并且此时该树在进行再平衡或者节点删除操作，读取操作会按照树节点的next指针进行读取，也是不加锁的（因为红黑树中节点也是有链表串起来的）；如果该树并没有进行平衡或者节点删除操作，那么会用CAS加读锁，防止读取过程中其他线程该树进行更新操作（主要是防止破坏红黑树节点之间的链表特性），破坏“读视图”。</li>
</ul>
<p>ConcurrentHashMap默认数组长度16，map最大容量为<code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code>。创建ConcurrentHashMap并不是涉及数组的初始化，数组初始化是在第一次put数据才进行的。（注意：JDK1.8中舍弃了之前的分段锁技术，改用CAS+Synchronized机制）</p>
<h2 id="Node结构"><a href="#Node结构" class="headerlink" title="Node结构"></a>Node结构</h2><p>ConcurrentHashMap中一个重要的类就是Node，该类存储键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是有一些差别是ConcurrentHashMap的value和next属性都是volatile的（<code>保证了get数据时直接返回即可，volatile保证了更新的可见性</code>），且不允许调用setValue方法直接改变Node的value域，增加了find方法辅助map.get()方法，可在get方法返回的结果中更改对应的value值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap定义了三个原子操作，用于对数组指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得在i位置上的Node节点  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少  </span></span><br><span class="line"><span class="comment">//在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改  </span></span><br><span class="line"><span class="comment">//因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//利用volatile方法设置节点位置的值  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;  </span><br><span class="line">   U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就按照ConcurrentHashMap的 <strong>put / get / remove</strong> 来分析下其实现原理，中间涉及rehash、红黑树转换等。</p>
<h2 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h2><p>put操作流程如下：</p>
<ul>
<li>首先根据key的hashCode计算hash，然后根据hash计算应该在数组中存储位置，如果数据为null，新建数组；</li>
<li>然后通过tabAt（&amp;操作）直接获取对应slot。如果slot为null，则新建kv节点（Node类型）放到slot；</li>
<li>如果当前slot节点的hash值等于MOVED（等于-1），表示其类型为ForwardingNode，证明其他线程在进行rehash扩容操作，当前线程也会帮助一起进行扩容操作；</li>
<li>然后对slot节点进行synchronized加锁，如果slot节点hash值大于等于0，表示当前slot对应元素为链表结构，遍历当前链表，如果key存在则更新，否则添加到链表尾部；如果slot节点类型为TreeBin（其hash值为-2），表示slot对应元素为红黑树，则在红黑树中进行更新节点或者添加节点操作，注意，最后如果树不平衡会进行树的再平衡操作，此时对树root节点加CAS写锁。</li>
<li>最后，如果新添加了节点，会统计map size值；如果当前map数量超过了阈值（<code>N = tab.length - tab.length&gt;&gt;&gt;2</code>）会触发rehash扩容，按照成倍扩容。</li>
</ul>
<p>注意：因为往map中添加元素和增加元素统计值是两个步骤，不是原子的，所以获取map.size()时可能不是准确值。</p>
<p><strong>对key的hashCode计算hash</strong></p>
<p>存到map中的key并不是直接按照hashCode计算的，因为hashCode有可能为负的，并且不合理的hashCode实现可能导致较多冲突，因此ConcurrentHashMap中会对key对hashCode进行hash操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int hash = spread(key.hashCode());</span></span><br><span class="line"><span class="comment">// HASH_BITS = 0x7fffffff 符号位设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>红黑树节点比较</strong></p>
<p>既然使用到了红黑树，这就涉及到节点的大小比较问题（节点数据包含key、value信息）。进行节点的大小比较时，首先是比较节点的hash值，注意hash值不是hashCode，因为hash值是对象hashCode与自己无符号右移16位进行异或后的值。如果节点的hash值相等，判断节点的key对象是否实现了Comparable接口，实现的话就是用Comparable逻辑比较节点之间的大小。如果key对象未实现Comparable接口，则调用tieBreakOrder方法进行判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dir = tieBreakOrder(k, pk); k/pk，带比较两个节点，命名还是挺有意思的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">		(d = a.getClass().getName().</span><br><span class="line">		 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">		d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">			 -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这里调用了System.identityHashCode，将由默认方法hashCode()返回，如果对象的hashCode()被重写，则System.identityHashCode和hashCode()的返回值就不一样了。</em></p>
<p><strong>put源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// key value非空</span></span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">	<span class="comment">// slot对应元素个数，链表转换成红黑树时用</span></span><br><span class="line">	<span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">		Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">		<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">			tab = initTable();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">						 <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">				<span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">			<span class="comment">// 在rehash扩容，帮助扩容，扩容完成之后才能继续进行put操作</span></span><br><span class="line">			tab = helpTransfer(tab, f);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			V oldVal = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 加锁</span></span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 可能已经被更新需要再次进行判断</span></span><br><span class="line">					<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 节点更新或插入</span></span><br><span class="line">						binCount = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">							K ek;</span><br><span class="line">							<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">								((ek = e.key) == key ||</span><br><span class="line">								 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">								oldVal = e.val;</span><br><span class="line">								<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">									e.val = value;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							Node&lt;K,V&gt; pred = e;</span><br><span class="line">							<span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">								pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">														  value, <span class="keyword">null</span>);</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树更新或插入</span></span><br><span class="line">						Node&lt;K,V&gt; p;</span><br><span class="line">						binCount = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">													   value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">							oldVal = p.val;</span><br><span class="line">							<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">								p.val = value;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">					treeifyBin(tab, i);</span><br><span class="line">				<span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">					<span class="keyword">return</span> oldVal;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加统计值，可能触发rehash扩容</span></span><br><span class="line">	addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">	CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * counterCells非空表示当前put并发较大，按照counterCells进行分线程统计</span></span><br><span class="line"><span class="comment">	 * 参考LongAddr思想</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">		!U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">		CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">		<span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">			(a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">			!(uncontended =</span><br><span class="line">			  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">			fullAddCount(x, uncontended);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		s = sumCount();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">		<span class="comment">// 大于等于阈值数时进行扩容操作</span></span><br><span class="line">		<span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			<span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">			<span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">					sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">					transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">					transfer(tab, nt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">										 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">				transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">			s = sumCount();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h2><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件hash值相同同时 key相同（equals） ，对于节点可能在链表或树上的情况，需要分别去查找。</p>
<p>get时一般是不加锁（Node节点中value数据类型是volatile的，保证了内存可见性）。如果slot元素为链表，直接读取返回即可；如果slot元素为红黑树，并且此时该树在进行再平衡或者节点删除操作，读取操作会按照树节点的next指针进行读取，也是不加锁的；如果该树并没有进行平衡或者节点删除操作，那么会用CAS加读锁，防止读取过程中其他线程该树进行更新操作，破坏“读视图”。</p>
<h2 id="remove流程"><a href="#remove流程" class="headerlink" title="remove流程"></a>remove流程</h2><p>remove流程就是根据key找到对应节点，将该节点从链表（更改节点前后关系）或者红黑树移除的过程，注意，从红黑树中删除元素后，不会将红黑树转换为列表的，只能在put元素时列表可能有转换红黑树操作，不会有反向操作。</p>
<p>注意：hashMap有自动rehash扩容机制，但是当元素remove之后并没有自动缩容机制，如果数组经过多次扩容变得很大，并且当前元素较少，请将这些元素转移到一个新的HashMap中。</p>
<h2 id="rehash流程"><a href="#rehash流程" class="headerlink" title="rehash流程"></a>rehash流程</h2><p>rehash时是成倍扩容（老table和新tableNew），对于table中i位置的所有元素，扩容后会被分配到i和i+table.length这两个位置中。rehash主要的流程transfer方法中，具体不再展开。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/19/shen-ru-li-jie-concurrenthashmap/">http://luoxn28.github.io/2019/06/19/shen-ru-li-jie-concurrenthashmap/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/06/19/shen-ru-li-jie-concurrenthashmap/" data-id="ck8ri1p1w003d8nci3kie7j6r" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3awW7bMBAE0Pz/T7dAL0WRWpnZJesUeDoZtkDtUwAuM+THR3z9+HUlv37+/Pzr53E+X0kNqwsPDw9vVHo+dE7NX1BeVV4zHh4e3m1eMt0/39m+mqi4oP18YcHDw8N7Ky8ZLin0FS+5Ew8PD+//4uWNoQ04khHw8PDwvhtv88//jN2Wez1rwcPDw+sqqSfx936+uL+Hh4eHt9hVb7fwZ3c+N6FVtXh4eHgXeM9RbFtWEuy2ce3zi4vaBh4eHt41Xjvd5yHvMzKJG9rn/qUx4OHh4R3l5VPzrKCcl8e1bbvCw8PDO8VrH5+U1cYKbURbtDE8PDy8C7x8QbxZKA97VLJE3r8PPDw8vDUvmcTbTf08qpiNXwQQeHh4eEd5yYTeRgz5aKeC3ZcpNR4eHt5RXh6e5m1jtu5twUUNeHh4eBd4+TI3n/RnLzF/enFoAA8PD+8ob3bcKt/+z79p44ziNAQeHh7eUd5suLbQ2VGttrXg4eHh3ea1x0BPTdZ5+NseR/jjTjw8PLx/yMtLn5WSN6RZSFG/RTw8PLxyrt6EEe01e33twYKXJyPw8PDwDvFm8US7pE4enL+gNlbGw8PDO8trJ/RNTDCLffNQGA8PD+82b7MR1U7rw4404n3s99nw8PDwHnlttDr7/nB8sDkBgYeHh3doet1ECflxgXZZvKkHDw8P7wav/be/3c5PCt0vzb8YEw8PD+8ob7bhlES3+bbZ8G+SPBEPDw/vTbzk6NWmPewX7qvGgIeHhzc/77RKRPOleT5O3kKuB754eHh4R7f880Vz/k2yyK6zFjw8PLwLvP02/6nleNsAvohR8PDw8N7K27eTdsx8if/yezw8PLxvxpsdJmjjiby2w40BDw8P75HXbk0ly+s8RGipeTiCh4eHd4O33wBLimhh7Z0X9/fw8PDwfl8/ARPupkshaCkoAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/2019/06/27/sentinel-he-xin-gai-nian/">sentinel 核心概念</a><a class="next" href="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/">Redis 基础数据结构</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/wang-luo-shu-ju-shi-ru-he-chuan-di-gei-jin-cheng-de/">网络数据是如何传递给进程的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/">进程是如何调度的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/">从sockert api看网络通信流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/">谈一谈TCP的4次挥手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/">深入理解TCP的3次握手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/linux-xin-hao/">Linux信号</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>