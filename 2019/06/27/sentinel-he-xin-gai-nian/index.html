<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>sentinel 核心概念 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">sentinel 核心概念</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">sentinel 核心概念</h1><div class="post-meta">Jun 27, 2019<span> | </span><span class="category"><a href="/categories/框架研究/">框架研究</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#资源和规则"><span class="toc-number">1.</span> <span class="toc-text">资源和规则</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#核心概念"><span class="toc-number"></span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource"><span class="toc-number">1.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">2.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry"><span class="toc-number">3.</span> <span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultNode"><span class="toc-number">4.</span> <span class="toc-text">DefaultNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StatisticNode"><span class="toc-number">5.</span> <span class="toc-text">StatisticNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Slot"><span class="toc-number">6.</span> <span class="toc-text">Slot</span></a></li></ol></li></div></div><div class="post-content"><blockquote>
<p> 前段时间笔者在团队内部分享了sentinel原理设计与实现，主要讲解了sentinel基础概念和工作原理，工作原理部分大家听了基本都了解了，但是对于sentinel的几个概念及其之间的关系还有挺多同学有点模糊的，趁着这几天比较空，针对sentinel的几个核心概念，做了一些总结，希望能帮助一些sentinel初学者理清这些概念之间的关系。</p>
<p> PS：本文主要参考sentinel源码实现和部分官方文档，建议小伙伴阅读本文的同时也大致看下官方文档和源码，学习效果更好呦 : )*  官方文档讲解的其实还是挺详细的，但是对于这些概念之间的关系可能对于初学者来说还有点不够。</p>
<p> 估计挺多小伙伴还不知道Sentinel是个什么东东，Sentinel是一个以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的框架。github地址为：<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel</a></p>
</blockquote>
<h3 id="资源和规则"><a href="#资源和规则" class="headerlink" title="资源和规则"></a>资源和规则</h3><p><strong>资源</strong>是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<p>围绕资源的实时状态设定的<strong>规则</strong>，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p>
<p>sentinel中调用SphU或者SphO的entry方法获取限流资源，不同的是前者获取限流资源失败时会抛BlockException异常，后者或捕获该异常并返回false，二者的实现都是基于CtSph类完成的。简单的sentinel示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    entry = SphU.entry(KEY);</span><br><span class="line">    System.out.println(<span class="string">"entry ok..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">    <span class="comment">// 获取限流资源失败</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">    <span class="comment">// biz exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (SphO.entry(KEY)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"entry ok"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取限流资源失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SphU和SphO二者没有孰优孰略问题，底层实现是一样的，根据不同场景选举合适的一个即可。看了简单示例之后，一起来看下sentinel中的核心概念，便于理解后续内容。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>resource是sentinel中最重要的一个概念，sentinel通过资源来保护具体的业务代码或其他后方服务。sentinel把复杂的逻辑给屏蔽掉了，用户只需要为受保护的代码或服务定义一个资源，然后定义规则就可以了，剩下的通通交给sentinel来处理了。并且资源和规则是解耦的，规则甚至可以在运行时动态修改。定义完资源后，就可以通过在程序中埋点来保护你自己的服务了，埋点的方式有两种：</p>
<ul>
<li>try-catch 方式（<code>通过 SphU.entry(...)</code>），当 catch 到BlockException时执行异常处理(或fallback)</li>
<li>if-else 方式（<code>通过 SphO.entry(...)</code>），当返回 false 时执行异常处理(或fallback)</li>
</ul>
<p>以上这两种方式都是通过硬编码的形式定义资源然后进行资源埋点的，对业务代码的侵入太大，从0.1.1版本开始，sentinel加入了注解的支持，可以通过注解来定义资源，具体的注解为：SentinelResource 。通过注解除了可以定义资源外，还可以指定 blockHandler 和 fallback 方法。</p>
<p>在sentinel中具体表示资源的类是：ResourceWrapper ，他是一个抽象的包装类，包装了资源的 Name 和EntryType。他有两个实现类，分别是：StringResourceWrapper 和 MethodResourceWrapper。顾名思义，StringResourceWrapper 是通过对一串字符串进行包装，是一个通用的资源包装类，MethodResourceWrapper 是对方法调用的包装。</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context是对资源操作时的上下文环境，每个资源操作(<code>针对Resource进行的entry/exit</code>)必须属于一个Context，如果程序中未指定Context，会创建name为”sentinel_default_context”的默认Context。一个Context生命周期内可能有多个资源操作，Context生命周期内的最后一个资源exit时会清理该Context，这也预示这真个Context生命周期的结束。Context主要属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">// context名字，默认名字 "sentinel_default_context"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// context入口节点，每个context必须有一个entranceNode</span></span><br><span class="line">    <span class="keyword">private</span> DefaultNode entranceNode;</span><br><span class="line">    <span class="comment">// context当前entry，Context生命周期中可能有多个Entry，所有curEntry会有变化</span></span><br><span class="line">    <span class="keyword">private</span> Entry curEntry;</span><br><span class="line">    <span class="comment">// The origin of this context (usually indicate different invokers, e.g. service consumer name or origin IP).</span></span><br><span class="line">    <span class="keyword">private</span> String origin = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：一个Context生命期内Context只能初始化一次，因为是存到ThreadLocal中，并且只有在非null时才会进行初始化。</em></p>
<p>如果想在调用 SphU.entry() 或 SphO.entry() 前，自定义一个context，则通过ContextUtil.enter()方法来创建。context是保存在ThreadLocal中的，每次执行的时候会优先到ThreadLocal中获取，为null时会调用 <code>MyContextUtil.myEnter(Constants.CONTEXT_DEFAULT_NAME, &quot;&quot;, resourceWrapper.getType())</code>创建一个context。当Entry执行exit方法时，如果entry的parent节点为null，表示是当前Context中最外层的Entry了，此时将ThreadLocal中的context清空。</p>
<h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>刚才在Context身影中也看到了Entry的出现，现在就谈谈Entry。每次执行 SphU.entry() 或 SphO.entry() 都会返回一个Entry，Entry表示一次资源操作，内部会保存当前invocation信息。在一个Context生命周期中多次资源操作，也就是对应多个Entry，这些Entry形成parent/child结构保存在Entry实例中，entry类CtEntry结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtEntry</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Entry parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Entry child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ProcessorSlot&lt;Object&gt; chain;</span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> Node curNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Node&#125; of the specific origin, Usually the origin is the Service Consumer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node originNode;</span><br><span class="line">    <span class="keyword">private</span> Throwable error; <span class="comment">// 是否出现异常</span></span><br><span class="line">    <span class="keyword">protected</span> ResourceWrapper resourceWrapper; <span class="comment">// 资源信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry实例代码中出现了Node，这个又是什么东东呢 :(，咱们接着往下看：</p>
<h3 id="DefaultNode"><a href="#DefaultNode" class="headerlink" title="DefaultNode"></a>DefaultNode</h3><p>Node（<em>关于StatisticNode的讨论放到下一小节</em>）默认实现类DefaultNode，该类还有一个子类EntranceNode；context有一个entranceNode属性，Entry中有一个curNode属性。</p>
<ul>
<li><strong>EntranceNode</strong>：该类的创建是在初始化Context时完成的（ContextUtil.trueEnter方法），注意该类是针对Context维度的，也就是一个context有且仅有一个EntranceNode。</li>
<li><strong>DefaultNode</strong>：该类的创建是在NodeSelectorSlot.entry完成的，当不存在context.name对应的DefaultNode时会新建（new DefaultNode(resourceWrapper, null)，对应resouce）并保存到本地缓存（NodeSelectorSlot中private volatile Map&lt;String, DefaultNode&gt; map）；获取到context.name对应的DefaultNode后会将该DefaultNode设置到当前context的curEntry.curNode属性，也就是说，在NodeSelectorSlot中是一个context有且仅有一个DefaultNode。</li>
</ul>
<p>看到这里，你是不是有疑问？为什么一个context有且仅有一个DefaultNode，我们的resouece跑哪去了呢，其实，这里的一个context有且仅有一个DefaultNode是在NodeSelectorSlot范围内，NodeSelectorSlot是ProcessorSlotChain中的一环，获取ProcessorSlotChain是根据Resource维度来的。总结为一句话就是：<strong>针对同一个Resource，多个context对应多个DefaultNode；针对不同Resource，(不管是否是同一个context)对应多个不同DefaultNode</strong>。这还没看明白 : (，好吧，我不bb了，上图吧：</p>
<p><img src="/2019/06/27/sentinel-he-xin-gai-nian/./sentinel-核心概念/clipboard.png" alt="img"></p>
<p>DefaultNode结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultNode</span> <span class="keyword">extends</span> <span class="title">StatisticNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ResourceWrapper id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The list of all child nodes.</span></span><br><span class="line"><span class="comment">     * 子节点集合，注意：目前版本sentinel中子节点个数最多为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;Node&gt; childList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associated cluster node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClusterNode clusterNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Resouce只有一个clusterNode，多个defaultNode对应一个clusterNode，如果defaultNode.clusterNode为null，则在ClusterBuilderSlot.entry中会进行初始化。</p>
<p>同一个Resource，对应同一个ProcessorSlotChain，这块处理逻辑在lookProcessChain方法中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = chainMap.get(resourceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            chain = chainMap.get(resourceWrapper);</span><br><span class="line">            <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Entry size limit.</span></span><br><span class="line">                <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                chain = SlotChainProvider.newSlotChain();</span><br><span class="line">                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                    chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                newMap.putAll(chainMap);</span><br><span class="line">                newMap.put(resourceWrapper, chain);</span><br><span class="line">                chainMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StatisticNode"><a href="#StatisticNode" class="headerlink" title="StatisticNode"></a>StatisticNode</h3><p>StatisticNode中保存了资源的实时统计数据（基于滑动时间窗口机制），通过这些统计数据，sentinel才能进行限流、降级等一系列操作。StatisticNode属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticNode</span> <span class="keyword">implements</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒级的滑动时间窗口（时间窗口单位500ms）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT,</span><br><span class="line">        IntervalProperty.INTERVAL);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分钟级的滑动时间窗口（时间窗口单位1s）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The counter for thread count. </span></span><br><span class="line"><span class="comment">	 * 线程个数用户触发线程数流控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LongAdder curThreadNum = <span class="keyword">new</span> LongAdder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMetric</span> <span class="keyword">implements</span> <span class="title">Metric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeapArray&lt;MetricBucket&gt; data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricBucket</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 保存统计值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder[] counters;</span><br><span class="line">	<span class="comment">// 最小rt</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> minRt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中MetricBucket.counters数组大小为MetricEvent枚举值的个数，每个枚举对应一个统计项，比如PASS表示通过个数，限流可根据通过的个数和设置的限流规则配置count大小比较，得出是否触发限流操作，所有枚举值如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MetricEvent &#123;</span><br><span class="line">    PASS, <span class="comment">// Normal pass.</span></span><br><span class="line">    BLOCK, <span class="comment">// Normal block.</span></span><br><span class="line">    EXCEPTION,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    RT,</span><br><span class="line">    OCCUPIED_PASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>slot是另一个sentinel中非常重要的概念，sentinel的工作流程就是围绕着一个个插槽所组成的插槽链来展开的。需要注意的是每个插槽都有自己的职责，他们各司其职完好的配合，通过一定的编排顺序，来达到最终的限流降级的目的。默认的各个插槽之间的顺序是固定的，因为有的插槽需要依赖其他的插槽计算出来的结果才能进行工作。</p>
<p>但是这并不意味着我们只能按照框架的定义来，sentinel 通过 SlotChainBuilder 作为 SPI 接口，使得 Slot Chain 具备了扩展的能力。我们可以通过实现 SlotsChainBuilder 接口加入自定义的 slot 并自定义编排各个 slot 之间的顺序，从而可以给 sentinel 添加自定义的功能。</p>
<p>那SlotChain是在哪创建的呢？是在 CtSph.lookProcessChain() 方法中创建的，并且该方法会根据当前请求的资源先去一个静态的HashMap中获取，如果获取不到才会创建，创建后会保存到HashMap中。这就意味着，同一个资源会全局共享一个SlotChain。默认生成ProcessorSlotChain为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSlotChainBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/27/sentinel-he-xin-gai-nian/">http://luoxn28.github.io/2019/06/27/sentinel-he-xin-gai-nian/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/06/27/sentinel-he-xin-gai-nian/" data-id="ck8ri1p1c00268nciw38h6uon" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACH0lEQVR42u3aMW7DMAwF0N7/0u7axcYnmQYw9TwVqCPpZWBIkT8/8XP9efI37z71vFqyS/PBwMB4LeN6fO42zmF3u9wd/W6X5xUwMDBOYDwHvufjJoG1ulp+NgwMDIxJQEzezPfCwMDAqAa+/Li9MI2BgYHRK2J7KWOePn6pFsfAwHghI78s+/7f/9LfwMDAeBXjKj55MM2PeI0fDAyM3Yw8wFV5ObvXFsXAwDiHUS0X82ZkUnD2QnmhVsbAwFjBmF+K5cExSQ2rxfPt7wYGBsYiRvW4vRbCp4rh6HvCwMBYzcjDbp4CVknVERAMDIzTGJ+6ps+PmITXaE0MDIzVjGqYqx533hLI01AMDIytjGobIGf32gPVUhkDA+MERu8aLi9ckzWT/+aNBAwMjK2Mz45czBPH6leAgYGxmzHSxw3IecuhPGyBgYGxjpE3GqtjEL2EMi99yxMiGBgYL2fkS09aks2DPqeSGBgYqxm9VG8y7TBPLqP1MTAw1jF6l/KTUbC8MVBoJ2BgYBzGqLYeq0Nd1bQvCrsYGBjHMKqtgmr5Wp77yD+FgYGxlNEbHk2u2HrJYu/yDgMDYzdjHuyqI2I5r5csYmBgbGUkm03amTkgD7gYGBhnMnqBr7fxvDmKgYGBUWX0hi0K7clkZQwMDIwgEUxW6CWd0XUeBgbGAYwkdZsMb/XaDIXrPwwMjNWMvHTM35mnj5OfAQwMjEWMXz4dIuA7REJIAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/sentinel/">sentinel</a></div><div class="post-nav"><a class="pre" href="/2019/06/29/sentinel-hua-dong-chuang-kou-tong-ji-ji-zhi/">sentinel 滑动窗口统计机制</a><a class="next" href="/2019/06/19/shen-ru-li-jie-concurrenthashmap/">深入理解ConcurrentHashMap</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/wang-luo-shu-ju-shi-ru-he-chuan-di-gei-jin-cheng-de/">网络数据是如何传递给进程的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/">进程是如何调度的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/">从sockert api看网络通信流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/">谈一谈TCP的4次挥手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/">深入理解TCP的3次握手</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/linux-xin-hao/">Linux信号</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>