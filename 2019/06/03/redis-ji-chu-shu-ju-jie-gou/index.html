<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>Redis 基础数据结构 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis 基础数据结构</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis 基础数据结构</h1><div class="post-meta">Jun 3, 2019<span> | </span><span class="category"><a href="/categories/框架研究/">框架研究</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单动态字符串"><span class="toc-number">1.</span> <span class="toc-text">简单动态字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩列表"><span class="toc-number">3.</span> <span class="toc-text">压缩列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速列表"><span class="toc-number">4.</span> <span class="toc-text">快速列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典"><span class="toc-number">5.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳跃表"><span class="toc-number">6.</span> <span class="toc-text">跳跃表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数集合"><span class="toc-number">7.</span> <span class="toc-text">整数集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数树"><span class="toc-number">8.</span> <span class="toc-text">基数树</span></a></li></ol></div></div><div class="post-content"><p>Redis用到的底层数据结构有：简单动态字符串、双端链表、字典、压缩列表、整数集合、跳跃表等，Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些基础数据结构创建了一个对象系统，这写对象包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象等。<br><a id="more"></a></p>
<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>redis自定义了简单动态字符串数据结构（sds），并将其作为默认字符串表示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt; &#123;</span></span><br><span class="line">    T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">    T len; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">byte</span> flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">    <span class="keyword">byte</span>[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sds结构如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603013520254.png" alt></p>
<p>因为使用<code>len</code>表示当前字符串长度，<code>capacity</code>表示内存分配空间，当往sds字符串中添加过多字符(len达到capacity大小)，则会触发扩容，在字符串长度大小小于1M时，扩容策略为成倍扩容；大于1M时，每次新增1M空间，避免空间浪费。</p>
<p>比如执行如下命令 <code>redis&gt; set name Redis</code>，Redis将在数据库中创建一个新的键值对，其中键是一个字符串，一个保存着”name”的sds；值是一个字符串，一个保存着”Redis”的sds。使用sds作为字符串存储结构，有以下优势：</p>
<ul>
<li>O(1)复杂度获取字符长度</li>
<li>避免缓冲区溢出</li>
<li>减少修改字符操作时引起的内存分配次数</li>
<li>二进制安全的</li>
<li>兼容部分C字符串函数（因为字符串后面以’\0’结尾）</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表在Redis应用较广泛，比如作为列表的底层实现，当列表中元素较多时会使用链表作为底层数据结构。链表定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p>
<p>链表提供了表头指针head、表尾指针tail及链表长度len，而<code>dup/free/match</code>用于实现存储类型无关的特性函数。dup用于复制一个链表节点、free用于释放一个链表节点、match用于匹配链表节点和输入的值是否相等。结构图如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603013650477.png" alt></p>
<p>每个链表节点由一个listNode结构表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis中链表是双向链表。每个链表使用一个list结构表示，这个结构有表头节点指针、表尾节点指针、以及链表长度信息。通过将链表设置不同类型的特定函数，使得Redis链表可存储不同类型的值（是不是类似Java中的模板类）。链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项是小整数或者短的字符串，那么会使用压缩列表作为列表键的底层实现。压缩列表是Redis为了节约内存开发的，由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含多个节点，每个节点保存一个字节数组或者一个整数值。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103003252.png" alt></p>
<p>zltail_offset记录了左后一个entry的偏移量，通过它可以很快定位到尾节点。entry根据保存元素的不同，会有不一样的结构，不过类似于存储多个TLV消息一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen; <span class="comment">// 前一个 entry 的字节长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">// 元素类型编码</span></span><br><span class="line">    optional <span class="keyword">byte</span>[] content; <span class="comment">// 元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist（压缩列表） 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。考虑到链表的附加空间相对太高， prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。</p>
<p>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103100747.png" alt></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称为符号表、映射，是一种保存键值对的数据结构。字典在Redis中应用相当广泛，比如Redis的数据库就是在使用字典作为底层实现的，对于数据库的CURD操作就是构建在对字典的操之上。比如当执行以下命令时：<code>redis&gt; set msg &quot;hello world&quot;</code></p>
<p>在数据库中创建了一个键为msg，值为hello world的键值对时，这个键值对就保存在代表数据库的字典里面的。除了用作数据库之外，字典还是哈希键的底层实现之一。</p>
<p>Redis的字典由dict结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 哈希计算</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 比较键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 销毁值的函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数，Redis会为不同用途的字典设置不同的特定函数。privdata属性则保存了需要传给那些特定函数的可选参数。ht属性包含2项，每一项都是一个dictht哈希表，一般情况下字典只使用ht[0]，ht[1]只在对ht[0]哈希表进行rehash时使用。字典结构图如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103216086.png" alt><br>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希。哈希表使用分离连接法解决键冲突问题，被分配到同一个索引上多个键值会连接成一个单向链表。在对哈希表进行扩展或者缩容操作时，需要将现有哈希表中键值对rehash到新哈希表中，这个rehash过程不是一次性完成的，而是渐进的。</p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针来达到快速访问节点的目的。Redis使用跳跃表作为有序集合的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合元素是比较长的字符串，Redis就会使用跳跃表作为有序集合的底层实现。</p>
<p>Redis中的跳跃表由zskiplistNode和zskiplist两个结构体定义，其中zskiplistNode表示跳跃表节点，zskiplist表示跳跃表信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj; <span class="comment">// Redis对象</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 用于记录两个节点之间的距离，指向NULL的forward值都为0</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<p>header和tail指针分表指向跳跃表的表头和表尾节点，通过length属性记录表长度，level属性用于保存跳跃表中层高最大的节点的层高值。每个跳跃表节点层高都是1~32的随机值，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的。当分值相同时，节点按照成员对象的大小排序。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103314259.png" alt></p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是集合的底层实现之一，当一个集合只包含整数元素时，并且集合中元素数量不多时，Redis就会使用整数集合作为集合建的底层实现。整数集合是Redis中用于保存整数的集合抽象数据结构，它可以保存int16_t/int32_t/int64_t的值，并且保证集合中元素不会重复。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 16/32/64编码</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p>encoding编码的是int型整数的话，那么contents数组中每4项用于保存一个int型整数。</p>
<p>因为contents数组可以保存int16/int32/int64的值，所以可能会出现升级现象，也就是本来是int16编码方式，需要升级到int32编码方式，这时数组会扩容，然后将新元素添加到数组中，这期间数组始终会保持有序性。一旦整数集合进行了升级操作，编码就会一直保持升级后的状态，也就是不会出现降级操作。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103405935.png" alt></p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>Rax 是 Redis 内部比较特殊的一个数据结构，它是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操作。 Redis 五大基础数据结构里面，能作为字典使用的有 hash 和 zset。 hash 不具备排序功能， zset 则是按照 score 进行排序的。 rax 跟 zset 的不同在于它是按照 key 进行排序的（可类比于InnoDB中的B+树）<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103424586.png" alt></p>
<p>Rax 被用在 Redis Stream 结构里面用于存储消息队列，在 Stream 里面消息 ID 的前缀是时间戳 + 序号，这样的消息可以理解为时间序列消息。使用 Rax 结构进行存储就可以快速地根据消息 ID 定位到具体的消息，然后继续遍历指定消息之后的所有消息。</p>
<p>rax 中有非常多的节点，根节点、叶节点和中间节点，有些中间节点带有 value，有些中间节点纯粹是结构性需要没有对应的 value。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isKey; <span class="comment">// 是否没有 key，没有 key 的是根节点</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isNull; <span class="comment">// 是否没有对应的 value，无意义的中间节点</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isCompressed; <span class="comment">// 是否压缩存储，这个压缩的概念比较特别</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">29</span>&gt; <span class="built_in">size</span>; <span class="comment">// 子节点的数量或者是压缩字符串的长度 (isCompressed)</span></span><br><span class="line">    <span class="keyword">byte</span>[] data; <span class="comment">// 路由键、子节点指针、 value 都在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rax 是一棵比较特殊的 radix tree，它在结构上不是标准的 radix tree。如果一个中间节点有多个子节点，那么路由键就只是一个字符。如果只有一个子节点，那么路由键就是一个字符串。后者就是所谓的「压缩」形式，多个字符压在一起的字符串。如下结构（蓝色的表示压缩节点）：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103457487.png" alt></p>
<p>参考资料：</p>
<ol>
<li>Redis设计与实现</li>
<li>Redis深度历险</li>
</ol>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/">http://luoxn28.github.io/2019/06/03/redis-ji-chu-shu-ju-jie-gou/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2019/06/03/redis-ji-chu-shu-ju-jie-gou/" data-id="ckc7rx87n001foqciw2mynrwy" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3awW7cMAwE0P3/n06BngK068yQUpMCz6fFJmvz+SARI75e8fXx+/r8+fP15/fPd2i/eb7zgQsPDw9vVPq7K3/Mu7/mJT6Dn+t5e388PDy8a7xkM3jGzJbv5xea1/P2ezw8PLxv5eWLfo7Pi8bDw8P7f3nPbW7+2zzCwMPDw/uZvCSMmJW+f2VJOHIga8HDw8OLebMDsO/9fP18Dw8PD290qr7ZKmajA3kkEdWJh4eHd4F3Izhog+BZe13Eu3h4eHhHeafC2Xb5zkvPG/3X5p3h4eHhlbw2jGhfU958J08phsPw8PDwLvDa8aZZszsLF06Nf+Hh4eGd5e1jhaQVngW++2ACDw8P7x4vD21vFNrOABQbBh4eHt4F3vNSnhc0Y5yNKoocBQ8PD2/B2wcK7T3zSKJ90X/5Hzw8PLwLvDrlLRf32yt2sSHh4eHhHeLlI1NJmJtsBvkwVtJSf/Ei8PDw8C7zNgdXbcC6uUNy4eHh4d3jJSHpvym0be7rRhwPDw/vEC9fZGefZ+Fsvuh/UQkeHh7eBV5+wJ8v3HmM2y767eEZHh4e3j1e8uD2OOrsoVrbjuPh4eHd4yUF5dFAS23vVm9UeHh4eBd4+yY43wzyxj2PHqJn4eHh4R3lfVy42uGqNtgtYgs8PDy8C7zNtS/61GRU2z/j4eHhbXiz5rVtc9tEOR84+OJXeHh4eBd4swW63Vv27fVmEAEPDw/vLG8WNORHU7Mhqn0Tj4eHh3eP1y7u7bhAW+iGMdu08PDw8Ga8/YFWOyaVR7T5UMJw98PDw8Nb8PIHzw6x8vb6VOSBh4eH93N4m/Z3P2rQVoKHh4f3vbw8sJg12XkDXdwZDw8P7xpvFkbksez+ECsftzqWteDh4eGlecKrXbJz/KzcvIk/cL6Hh4eH9/SUXwLVSt9kv8KVAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/redis/">redis</a></div><div class="post-nav"><a class="pre" href="/2019/06/19/shen-ru-li-jie-concurrenthashmap/">深入理解ConcurrentHashMap</a><a class="next" href="/2019/06/03/ni-de-redis-you-lei-zhuan-huan-yi-chang-me/">你的Redis有类转换异常么</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-provider-filter-lian-shi-ru-he-gou-jian-de/">Dubbo provider Filter链是如何构建的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-rpc-zai-provider-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在provider端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/dubbo-provider-shi-ru-he-qi-dong-de/">dubbo provider是如何启动的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/dubbo-lian-tong-xing-tao-lun/">Dubbo连通性讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/dubbo-xian-cheng-mo-xing/">Dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/04/dubbo-rpc-zai-consumer-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在consumer端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>