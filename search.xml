<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dubbo的发展历程</title>
      <link href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/"/>
      <url>/2020/07/03/dubbo-de-fa-zhan-li-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">Apache Dubbo™</a> 是一款高性能Java RPC框架。说起dubbo，国内开发者几乎都知道它的大名，既然现在的dubbo很流行，那么让我们回顾下过去的dubbo吧，一起看下dubbo的发展历程：</p><ul><li>2011年10月27日，阿里巴巴（B2B部门）开源自己的SOA服务化治理方案的核心框架Dubbo。</li><li>2012年10月23日发布Dubbo2.5.3版本，至此之后，阿里基本停止了对Dubbo的主要升级；仅在13、14年进行过几次更新维护版本然后就停止了所有的维护工作；同时Dubbo对Srping的支持也停留在了Spring 2.5.6版本上。在阿里停止维护和升级Dubbo期间，当当网开始维护自己的Dubbo分支版本Dubbox，支持了新版本的Spring，并对外开源了Dubbox。</li><li>2017年9月7日发布Dubbo的2.5.4版本，距离上一个版本2.5.3发布已经接近快5年时间了。在随后的几个月中，阿里Dubbo开发团队以差不多每月一版本的速度开始快速升级迭代，修补了Dubbo老版本多年来存在的诸多bug，并对Spring等组件的支持进行了全面升级。（不知道是不是因为KPI的压力 ^_^）</li><li>2018年1月8日发布Dubbo 2.6.0版本，新版本将之前当当网开源的Dubbo分支Dubbox进行了合并，实现了Dubbo版本的统一整合。</li><li>2018年1月8日，Dubbo创始人之一梁飞在Dubbo交流群里透露了Dubbo 3.0正在动工的消息。Dubbo 3.0内核与Dubbo2.0完全不同，但兼容Dubbo 2.0。Dubbo 3.0将以Streaming为内核，不再是Dubbo时代的RPC，但是RPC会在Dubbo3.0中变成远程Streaming对接的一种可选形态。Dubbo 3.0将支持可选Service Mesh，多加一层IPC，这主要是为了兼容老系统，而内部则会优先尝试内嵌模式。代理模式Ops可独立升级框架，减少业务侵入，而内嵌模式可以带业务测试、部署节点少、稳定性检测方便。同时，可以将Dubbo3.0启动为独立进程，由dubbo-mesh进行IPC，路由、负载均衡和熔断机制将由独立进程控制。</li><li>2018年2月15日，阿里将Dubbo开源贡献给Apache，即incubator-dubbo。</li><li>2019 年 5 月 20 日，Apache 软件基金会在马萨诸塞州维克菲尔德宣布，Apache Dubbo 升级为顶级项目。</li><li>2019年12月29日，<a href="https://github.com/apache/dubbo/releases/tag/dubbo-2.7.5" target="_blank" rel="noopener">apache-dubbo-2.7.5</a> 发布，支持http2 grpc、服务自省能力，为走向云原生打下基础。</li></ul><p><img src="/2020/07/03/dubbo-de-fa-zhan-li-cheng/./dubbo的发展历程/image-20200703125809080.png" alt></p><p>从dubbo最初开源的火热，到14-17年的基本停滞，再到17年下半年到现在的迅猛发展，可以从github上commits图看出来明显变化：</p><p><img src="/2020/07/03/dubbo-de-fa-zhan-li-cheng/./dubbo的发展历程/image-20200703125724197.png" alt></p><p>目前已有150+公司在使用，包括阿里巴巴集团、中国人寿、中国电信、当当网、滴滴出行、海尔、中国工商银行、网易、去哪儿、有赞等。dubbo提供的主要能力是基于接口的远程代理，容错和负载均衡，以及自动服务注册和发现等，功能包括：</p><ul><li>基于透明接口的 RPC：提供基于高性能接口的 RPC，对用户而言是透明的。</li><li>智能负载平衡：支持多种开箱即用的负载均衡策略，可感知下游服务状态，从而降低整体延迟，提高系统吞吐量。</li><li>自动服务注册和发现：支持多个服务注册，可即时在线 / 离线检测服务。</li><li>高可扩展性：微内核和插件设计确保了它可容易地通过第三方实现跨核心功能（如协议、传输和序列化等）。</li><li>运行时流量路由：可在运行时进行配置，使流量可根据不同的规则进行路由，这使得能够轻松支持蓝绿部署、数据中心感知路由等功能。</li><li>可视化服务治理：为服务治理和维护提供丰富的工具，如查询服务元数据、运行状况和统计信息。</li></ul><h2 id="dubbo的开源"><a href="#dubbo的开源" class="headerlink" title="dubbo的开源"></a>dubbo的开源</h2><blockquote><p>这里不得不提一个人，梁飞，花名（虚极），2009 年加入阿里巴巴，负责中间件的开发，Dubbo 开源分布式服务框架作者。</p></blockquote><p>Dubbo 项目诞生于 2008 年。梁飞最早进入阿里的时候，Dubbo 项目还没有 Dubbo 这个名字，那时的 Dubbo 还是一个阿里内部的系统。2010 年，Dubbo 项目进行了重构。2011 年的阿里，憋了一股劲儿要成为一家技术人向往的企业。那个时候，开发者刚刚成为国内各大厂商争相夺取的宝贵资产,靠什么吸引最顶尖的开发者？黑客文化、工程师文化、开源文化。</p><p>当时在淘宝、在阿里 B2B，都有团队在推动开源。阿里 B2B 这边决定先拿 Dubbo 项目开源出去。当时淘宝（2C）也有一个和dubbo类似的项目叫做HSF，也是一个中间件服务框架，跟 Dubbo 做的事情高度重合。当时的情况是：整个淘系都在用 HSF，而阿里金融、集团、B2B 都在用 Dubbo。</p><p>在Dubbo和HSF的”竞争”中，从最初的开始让 HSF 合并到 Dubbo 里面，但是由于时间未达到预期实际上并没有合并起来，后来就决定反向合并，把 Dubbo 合并到 HSF 里面去。之后，Dubbo就在14年之后没更新过了，同时Dubbo 团队调整，去到了各个地方。</p><blockquote><p>不过，墙内开花墙外香，阿里之外，还是吸引很多公司和开发者使用dubbo的，比如当当网开发的扩展版本Dubbox 后来就在持续发展。</p></blockquote><p>关于dubbo和HSF的竞争中失败，这里不讨论技术上实现哪个更好？（严格来讲，二者实现思想不同，前者更加轻量级、扩展性强，后者稍微重量级、依赖较多）而是结合当时环境来分析，当时阿里处于系统大重构过程中，特别是淘宝的系统大重构，由于淘宝用的是HSF，已经与淘宝系统深度融合了，根植于淘系的基因了，因此后续换一个新的技术，成本较大收益不明显。</p><h2 id="dubbo的重生"><a href="#dubbo的重生" class="headerlink" title="dubbo的重生"></a>dubbo的重生</h2><p>既然dubbo都已经好长时间不维护更新了，那么怎么在17年会突然宣布维护并且推动孵化Apache呢？难道是传说中的KPI的原因？</p><blockquote><p>实际上dubbo的转机，在于阿里云的流行。</p></blockquote><p>2017 年的阿里云，发现有一批客户上云之后，想要用 Dubbo。因为他们 Dubbo 已经用的很熟了，不想因为上云而被迫改变自己的使用习惯。</p><p>于是，阿里云就把 Dubbo 服务作为自己的一个产品，卖给了这些客户。但是，客户们又提出了一个问题：</p><blockquote><p>“你看你们 Dubbo 都不怎么更新代码了是吧？你们自己都不维护了，我们用你的框架就觉得特别不放心。”</p></blockquote><p>这下好了，真正的客户提出要求了，提升客户对 Dubbo 的信心，成为了一件在公司层面有价值的事情。因此阿里进一步升级Dubbo并把它捐赠给Apache。2018 年初，Dubbo 项目正式进入了 Apache 的孵化器。</p><h2 id="dubbo的进化"><a href="#dubbo的进化" class="headerlink" title="dubbo的进化"></a>dubbo的进化</h2><p>dubbo的重生和进入Apache，已经说明dubbo旺盛的生命力了，但是如何让这种生命力更强呢？</p><p>拥有更强的生命力，不仅是dubbo本身发展的需要，也是适应未来技术发展的需要。dubbo在Apache孵化阶段，Dubbo正在从一个微服务领域的高性能 Java RPC 框架，演进到微服务框架 Dubbo Ecosystem，打造出一个完整的微服务生态。</p><p>为什么dubbo需要完成的微服务生态，这里拿Spring Cloud做个对比：</p><blockquote><p>Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。比如使用Spring Cloud Config 可以实现统一配置中心，对配置进行统一管理；使用Spring Cloud Netflix 可以实现Netflix 组件的功能 - 服务发现（Eureka）、智能路由（Zuul）、客户端负载均衡（Ribbon）。</p></blockquote><p>关于服务治理的配置中心、服务发现、降级熔断等等，dubbo同样也是需要的，但是dubbo目前对这些的支持还不是很完善，需要开发人员自定义并引入对应组件，这种就提高了使用成本。因此构建一个dubbo版的微服务生态，也是Dubbo社区满足开发者更高效的构建微服务体系期望的使命和担当。 关于Dubbo Ecosystem系统构建，阿里开源了Nacos、Sentinel、seata等项目。</p><p>云原生越来越火热，dubbo为了更好地适配云原生，在2.7.5版本新引入了一种基于实例（应用）粒度的服务发现机制，这是为 Dubbo 适配云原生基础设施的一步重要探索。</p><p>除了上述的这些，Dubbo 3.0 的规划也在全面进行中，如何让应用级服务发现成为未来下一代服务框架 Dubbo 3.0 的基础服务模型，解决云原生、规模化微服务集群扩容与可伸缩性问题，也已经成为Dubbo发展的重点。</p><blockquote><p>最后，对于Dubbo的发展，我们应该抱有更大的信心，一方面是国内互联网业务复杂度，发展迅猛，将带来更多样的应用场景，对于开源技术和项目的推动落地，提供了一个很好的试验场；另一方面是国内公司对开源技术越来越重视，社区文化越来越浓重。</p></blockquote><p>参考资料：</p><ol><li><a href="https://www.infoq.cn/article/LHqFdI_X9kdHdeXkZ7xf" target="_blank" rel="noopener">https://www.infoq.cn/article/LHqFdI_X9kdHdeXkZ7xf</a></li><li><a href="https://www.infoq.cn/article/3F3Giujjo-QwSw2wEz7u" target="_blank" rel="noopener">https://www.infoq.cn/article/3F3Giujjo-QwSw2wEz7u</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链的2种实现方式</title>
      <link href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/"/>
      <url>/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>责任链模式是日常开发或者框架中经常被使用的一种设计模式，典型的责任链有2种实现方式，不知道各位小伙伴更pick哪一种呢？下面就一起来比较下这2种实现方式吧~</p><h2 id="责任链是什么"><a href="#责任链是什么" class="headerlink" title="责任链是什么"></a>责任链是什么</h2><p>责任链是属于行为型模式，在这种模式中，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>责任链类图下图：</p><p><img src="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/./责任链的2种实现方式/image-20200620215443800.png" alt="image-20200620215443800"></p><p>责任链模式在开源项目中应用场景还是比较常见的，比如Tomcat中的Filter处理链、Netty中的ChannelHandler处理链、Dubbo RPC中的consumer侧的Filter链等等。责任链模式应用在业务流程中的 多个同类型操作场景，相当于对一个复杂较长的操作进行分段处理，这样对扩展性友好，新增操作阶段时更加灵活。这种可以理解为分片思想，降低业务流程操作的复杂度。</p><h2 id="责任链的2种实现"><a href="#责任链的2种实现" class="headerlink" title="责任链的2种实现"></a>责任链的2种实现</h2><p>常见的责任链流程如下：</p><p><img src="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/./责任链的2种实现方式/image-20200620215503303.png" alt="image-20200620215503303"></p><h3 id="节点传递方式"><a href="#节点传递方式" class="headerlink" title="节点传递方式"></a>节点传递方式</h3><p>节点传递方式也就是，责任链中当前节点处理完成之后，自己传递给下一个处理节点继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractHandler <span class="title">setNextHandler</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        doProcess(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.process(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的责任链处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler1] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler2] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler3] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/./责任链的2种实现方式/image-20200620215550879.png" alt="image-20200620215550879"></p><h3 id="统一传递方式"><a href="#统一传递方式" class="headerlink" title="统一传递方式"></a>统一传递方式</h3><p>统一传递方式也就是，不由责任链中处理节点传递给下一个节点，而是由统一的传递逻辑进行传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerWrap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerWrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handlerList.add(<span class="keyword">new</span> Handler1());</span><br><span class="line">        handlerList.add(<span class="keyword">new</span> Handler2());</span><br><span class="line">        handlerList.add(<span class="keyword">new</span> Handler3());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlerList) &#123;</span><br><span class="line">            handler.process(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler1] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler2] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[Handler3] process "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/./责任链的2种实现方式/image-20200620215623531.png" alt="image-20200620215623531"></p><h2 id="两种实现方式的比较"><a href="#两种实现方式的比较" class="headerlink" title="两种实现方式的比较"></a>两种实现方式的比较</h2><p>上述两种实现方式差别就是谁来进行下一个节点的传递工作，节点传递方式 是责任链中当前处理节点处理完成之后，自己传递给下一个节点；统一传递方式 是在统一的地方进行传递工作，减轻处理节点的“负担”。</p><p>二者本质上是一样的，不过前一种实现方式初始化成本较高，还要注意处理节点的前后顺序，这种调整一个节点的位置时特别要注意前后节点的关系，否则处理链顺序就错乱了。</p><p><strong>后续开发中，建议使用第二种实现方式，这种责任链初始化成本较低，调整责任链成本较小</strong>。不过有些责任链使用场景中，会将前一个处理节点的返回结果作为下一个处理节点的入参，这种场景一般推荐使用第一种实现方式，就像Netty中的ChannelHandler处理链流程类似。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux mmap</title>
      <link href="/2020/04/19/linux-mmap/"/>
      <url>/2020/04/19/linux-mmap/</url>
      
        <content type="html"><![CDATA[<p>mmap系统调用的作用是在调用进程的虚拟地址空间中创建一个新的内存映射。根据内存背后有无实体文件与之关联，映射可以分成以下两种：</p><ul><li>文件映射：内存映射区域有实体文件与之关联。mmap系统调用将普通文件的一部分内容直接映射到调用进程的虚拟地址空间。一旦完成映射，就可以通过在相应的内存区域中操作字节来访问文件内容。这种映射也被称为基于文件的映射。</li><li>匿名映射：匿名映射没有对应的文件。这种映射的内存区域会被初始化成0。</li></ul><p>内存映射根据有无文件关联，分成文件与匿名；根据映射是否在进程间共享，分成私有（fork之后mmap对应内存会进行写时复制）和共享。这两个维度两两组合，内存映射共分成4种类型：</p><p><img src="/2020/04/19/linux-mmap/./Linux mmap/image-20200419144219124.png" alt="image-20200419144219124"></p><p>mmap函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure><p>参数addr用于指定将文件对应的内容映射到进程地址空间的起始地址，一般为了可以执行不建议自行指定地址，而是传NULL让系统自己决定起始地址。参数prot用于设置对内存映射区域的保护，取值如下：</p><p><img src="/2020/04/19/linux-mmap/./Linux mmap/image-20200419144531466.png" alt="image-20200419144531466"></p><blockquote><p>其中fd、offset和length这三个参数指定了内存映射的源，即将fd对应的文件，从offset位置起，将长度为length的内容映射到进程的地址空间。对于文件映射，调用mmap之前需要调用open取到对应文件的文件描述符。</p></blockquote><p>需要注意的是mmap系统调用的操作单元是页，参数addr和offset都必须按页对齐，即必须是页面大小的整数倍。如果length参数不是页的整数倍会被向上取整。如果不再需要对应的内存映射了，可以调用munmap函数，解除该内存映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span></span><br></pre></td></tr></table></figure><p>其中addr是mmap返回的内存映射的起始地址，length是内存映射区域的大小。执行过munmap后，如果继续访问内存映射范围内的地址，那么进程会收到SIGSEGV信号，引发段错误。需要注意的是，关闭对应文件的文件描述符并不会引发munmap。</p><h3 id="mmap回写策略"><a href="#mmap回写策略" class="headerlink" title="mmap回写策略"></a>mmap回写策略</h3><p>说了这么多mmap的东东，那么如果是mmap文件映射，什么时候进行回写呢？</p><ul><li>内存不足</li><li>进程crash</li><li>调用 msync 或者 munmap</li><li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux管道</title>
      <link href="/2020/04/19/linux-guan-dao/"/>
      <url>/2020/04/19/linux-guan-dao/</url>
      
        <content type="html"><![CDATA[<p>管道是最早出现的进程间通信的手段，在shell中执行命令，经常会将上一个命令的输出作为下一个命令的输入，由多个命令配合完成一件事情。管道的作用是在有亲缘关系的进程之间传递消息，因为共同主先进程调用过pipe函数，打开的管道文件就会在fork之后，被各个后代进程所共享，打开的管道可以由其中一个进程写入数据，然后另一个具有亲属关系的进程读取。</p><blockquote><p>严格来说，家族里面的多个进程都可以往同一个秘密场所里面扔消息，也可以都从同一个秘密场所里面取消息，但是真的这么做的话又会存在风险。管道实质是一个字节流，并非前面提到的消息，没有消息的边界。如果多个进程发送的字节流混在一起，则无法辨认出各自的内容。所以一般是两个有亲缘关系的进程用管道来通信。</p></blockquote><p>一般来讲，进程中数据流是单向的，并且是阅后即焚的。管道是一种文件，可以调用read、write和close等操作文件的接口来操作管道。另一方面管道又不是一种普通的文件，它属于一种独特的文件系统：pipefs。管道的本质是内核维护了一块缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区内存的操作。</p><p>Linux下创建管道函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure><p>成功调用pipe函数之后，会返回两个打开的文件描述符，一个是管道的读取端描述符pipefd[0]，另一个是管道的写入端描述符pipefd[1]。管道没有文件名与之关联，因此程序没有选择，只能通过文件描述符来访问管道，只有那些能看到这两个文件描述符的进程才能够使用管道。如果进程执行了fork操作，那么管道就变成如下所示：</p><p><img src="/2020/04/19/linux-guan-dao/./Linux管道/image-20200419135558057.png" alt="image-20200419135558057"></p><p>一般来说管道是单向使用，所以fork之后，新老进程一个会关闭write fd，另一个会关闭read fd，避免读取读写混淆。在shell中执行管道命令就是这种情景，只是略有特殊之处，其特殊的地方是管道描述符占用了标准输入和标准输出两个文件描述符。</p><blockquote><p>单向使用管道，也就是说，如果没有用到管道的进程应该尽早释放管道文件fd，这么做不仅仅是为了让数据的流向更加清晰，也不仅仅是为了节省文件描述符，更重要的原因是：关闭未使用的管道文件描述符对管道的正确使用影响重大。</p></blockquote><p>管道有如下3个特性：</p><ul><li>只有当所有的写入端描述符都已关闭，且管道中的数据都被读出，对读取端描述符调用read函数才会返回0（即读到EOF标志）。</li><li>如果所有读取端描述符都已关闭，此时进程再次往管道里面写入数据，写操作会失败，errno被设置为EPIPE，同时内核会向写入进程发送一个SIGPIPE的信号。</li><li>当所有的读取端和写入端都关闭后，管道才能被销毁。</li></ul><p>管道的本质是一片内存区域，默认大小是65536字节，不过可以调用fcntl来获取和修改这个值的大小。因此在使用管道的过程中要注意写入数据是否能及时消费的问题，一旦管道满了，写入就会被阻塞；对于读取端，要及时地读取，防止管道被写满，造成写入阻塞。</p><p>上面说的都是常见的管道形式，也就是匿名管道，因为没有实体文件与之关联，所以只能在具有亲属关系的进程间使用。因此就出现了另一种管道形式，命名管道，其最大的差别就是有实体文件与之关联。由于存在实体文件，不相关的没有亲缘关系的进程也可以通过使用FIFO来实现进程之间的通信。</p><p>创建命名管道函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">modt_t</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>命名管道支持的管道操作和匿名管道是一样的，只不过它多了一个关联文件，有文件名，这样任何进程通过文件名来使用它而已。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络数据是如何传递给进程的</title>
      <link href="/2020/04/19/wang-luo-shu-ju-shi-ru-he-chuan-di-gei-jin-cheng-de/"/>
      <url>/2020/04/19/wang-luo-shu-ju-shi-ru-he-chuan-di-gei-jin-cheng-de/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在分析网卡数据是如何传递给进程的流程之前，要知道数据是如何从进程写到网卡的，因为只有发起方写数据到网卡然后接收方才能接收到并处理。</p></blockquote><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>发送方的发送数据的处理流程大致为：用户空间 -&gt; 内核 -&gt; 网卡 -&gt; 网络。</p><p>在用户态空间，调用发送数据接口 <code>send/sento/wirte</code> 等写数据包，在内核空间会根据不同的协议走不同的流程。以TCP为例，TCP是一种流协议，内核只是将数据包追加到套接字的发送队列中，真正发送数据的时刻，则是由TCP协议来控制的。TCP协议处理完成之后会交给IP协议继续处理，最后会调用网卡的发送函数，将数据包发送到网卡。</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>接收方的接收数据的处理流程大致为：网络 -&gt; 网卡 -&gt; 内核(epoll等) -&gt; 进程(业务处理逻辑)。</p><p>网络中数据首先到达网卡，对于网卡来说，数据包的到达是一个无法预料的事件，系统需要通过某种手段来得知该事件。一般来说，有2种方案：<strong>轮询和通知</strong>，轮询机制就是不断轮询网卡看数据有没有到来，该方式无疑会浪费较多的CPU资源，没数据时会造成大量的空轮询。通知机制就是网卡接收到数据时再通知CPU，然后再读取数据即可。</p><p>网卡的数据通知机制看起来很完美了，但是实际应用中，CPU响应中断处理时，为了不影响当前的工作，需要将当前工作的上下文保存起来，然后再进行中断处理。试想，当前千兆、万兆网卡已经非常普遍，若是那时网卡满负载，那么每秒钟就会产生大量的中断。除了切换过程带来的计算代价，上下文的切换还会导致CPU Cache的失效，对于高性能服务器来说，这是一个不容忽视的问题。因此，Linux做了优化，组合了通知和轮询的机制，简单来说，在CPU响应网卡中断时，不再仅仅是处理一个数据包就退出，而是使用轮询的方式继续尝试处理新数据包，直到没有新数据包到来，或者达到设置的一次中断最多处理的数据包个数。</p><blockquote><p>注意网卡的硬中断处理是在网卡驱动中进行的，硬中断处理是一个特殊的上下文，CPU会屏蔽掉绝大部分中断，并且有不少的限制。所以硬中断应尽可能快地处理，以提高系统的响应速度，因此内核将具体的处理工作放到了软中断中。</p></blockquote><p>数据离开网卡驱动之后就进入到了协议栈，经过IP层、网络层协议的处理，就会触发IO读事件，比如epoll的reactor模型中，就会触发对应的读事件，然后回调对应的IO处理函数，数据之后会交给业务线程来处理，比如Netty的数据接收处理流程就是这样的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程是如何调度的</title>
      <link href="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/"/>
      <url>/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统运行过程中，CPU都忙于在不同进程（或线程）间执行指令，这就涉及到进程调度，进程调度是到底执行了哪些操作呢？</p></blockquote><p>首先是将当前进程的上下文状态信息予以保护，以便将来能够重新恢复执行，然后将要执行的进程所需的环境准备好，包括设置寄存器、栈指针、状态字等操作。最后跳转到选中的进程，也就是设置或恢复其程序计数器，开始执行进程指令。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>操作系统选择进程调度的大致流程如下：</p><ul><li>因时序或外部中断或进程挂起而导致操作系统获得CPU控制权；</li><li>操作系统在所有<strong>就绪</strong>的进程中按照某种算法选择进程；</li><li>操作系统将当前进程（中断或挂起的进程）状态予以保护便于后续恢复执行；</li><li>将选中的进程的环境布置好（设置寄存器、栈指针、状态字等）；</li><li>跳到选中进程开始执行指令。</li></ul><p>进程调度的目标就是增大系统吞吐量、减少进程响应时间，同时提供某种程度的公平机制。常见的进程调度算法有FCFS（先来先到 First Come First Serve）、时间片轮转、短任务优先、优先级调度策略等，由于每种调度算法都有其优缺点，为了取长补短，一般会使用组合调度策略，比如带优先级的时间片调度策略，就是将所有进程分成不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，则处于高优先级大类的进程优先执行；如果两个进程处于同一个大类，则采用时间片轮转来执行。</p><h3 id="进程状态流转"><a href="#进程状态流转" class="headerlink" title="进程状态流转"></a>进程状态流转</h3><p>操作系统为了跟踪和管理进程，会定义多种进程状态及对应的流转策略，以此控制进程执行。不同的操作系统可能定义的进程状态不太一致，不过基本的状态都包含如下3中：</p><ul><li>运行态：进程占用CPU，并在CPU上运行；</li><li>就绪态：进程已经具备运行条件，但是CPU还没有分配过来；</li><li>阻塞态：进程因等待某件事发生而暂时不能运行。</li></ul><p>这3种状态的流转如下：</p><p><img src="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/./进程是如何调度的/image-20200418223743294.png" alt="image-20200418223743294"></p><p>更详细一点的进程状态流转如下（已时间片轮转调度的进程状态转换）：</p><p><img src="/2020/04/18/jin-cheng-shi-ru-he-diao-du-de/./进程是如何调度的/image-20200418224030003.png" alt="image-20200418224030003"></p><p>挂起和睡眠是主动的，挂起恢复需要主动完成，睡眠恢复则是自动完成的，因为睡眠有一个睡眠时间，睡眠时间到则恢复到就绪态。而阻塞是被动的，是在等待某种事件或者资源的表现，一旦获得所需资源或者事件信息就自动回到就绪态。</p><blockquote><p>注意，睡眠和挂起是两种行为，阻塞则是一种状态。进程sleep时，运行状态流转到阻塞状态，进程释放了CPU，也就是不会占用CPU资源，等到定时器时间到时会唤醒该进程，此时状态变为就绪状态。</p></blockquote><p>参考资料：</p><p>1、<a href="https://www.zhihu.com/question/42962803" target="_blank" rel="noopener">https://www.zhihu.com/question/42962803</a></p><p>2、<a href="https://blog.csdn.net/yusiguyuan/article/details/47805091" target="_blank" rel="noopener">https://blog.csdn.net/yusiguyuan/article/details/47805091</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从sockert api看网络通信流程</title>
      <link href="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/"/>
      <url>/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说了网络通信，大家肯定都不会陌生，比如各种分布式系统、大数据框架等等都要涉及到网络通信，由于大多数通信都是基于TCP协议来的，因此本文就以TCP为例，结合socket api来分析Linux下的网络通信流程。</p></blockquote><p>TCP协议是基于IP协议之上的面向流并且可靠传输的通信协议，同时TCP也拥有流量控制和拥塞控制机制。说起TCP，就绕不开的TCP的3次握手和4次挥手，因此先看下握手和挥手流程：</p><p><img src="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/./谈一谈TCP的4次挥手/image-20200418092247425.png" alt="image-20200418092247425"></p><h3 id="socket-api"><a href="#socket-api" class="headerlink" title="socket api"></a>socket api</h3><p>常用的网络通信socket api有socket、bind、listen、accept和connect等。</p><p>为了进行网络通信，进程需要首先调用socket函数获取一个socket fd，可以指定通信协议类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// family指定协议族，type指定套接字类型，protocol指定某个协议类型常值，或者设为0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>bind函数把一个本地协议地址赋予一个套接字，至于协议地址的含义则取决于协议本身，对于TCP，调用bind函数可以指定一个端口号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">// 返回：成功为0，出错-1</span></span><br></pre></td></tr></table></figure><blockquote><p>bind函数绑定特定的IP地址必须属于其所在主机的网络接口之一，服务器在启动时绑定它们众所周知的端口，如果一个TCP客户端或服务端未曾调用bind绑定一个端口，当调用connect或listen时，内核就要为响应的套接字选择一个临时端口。让内核选择临时端口对于TCP客户端来说是正常的，但是对于TCP服务端来说确实罕见的，因为服务端通过他们众所周知的端口被大家认识的。</p></blockquote><p>socket创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的一个客户套接字。listen函数把一个未连接的套接字转换为一个被动套接字，指示内核应接受指向该套接字的连接请求，调用listen函数将导致套接字从CLOSEE状态转换到LISTEN状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// 返回：成功返回0，出错-1</span></span><br></pre></td></tr></table></figure><blockquote><p>backlog表示某个给定套接字上内核为之排队的最大已完成连接数，也就是3次握手中已完成队列的大小。</p></blockquote><p>accept函数由服务器调用，用于从已完成队列中获取下一个已完成连接，如果已完成队列为空，则进程被投入睡眠（如果该套接字为阻塞方式的话）。如果accept成功，那么其返回值是由内核自动生成的一个全新套接字，代表与返回客户的TCP连接，函数的第一个参数为监听套接字，返回值为已连接套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>; <span class="comment">//  返回：成功返回已连接描述符(非负)，出错-1</span></span><br></pre></td></tr></table></figure><p>连接建立完成之后就可以进行读写操作了，对应read/write等方法。</p><p><img src="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/./从socket api看网络通信流程/image-20200418220653756.png" alt="image-20200418220653756"></p><p>连接读写完成之后就可以进行关闭连接操作了，close一个TCP套接字的默认行为是把该套接字标记为已关闭，然后立即返回到调用进程。注意，close实质把该套接字引用值减1，如果该引用值大于0，则对应的套接字不会被真正关掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>; <span class="comment">// 若成功返回0，出错-1</span></span><br></pre></td></tr></table></figure><p>close时的详细的4次挥手流程如下：</p><p><img src="/2020/04/18/cong-socket-api-kan-wang-luo-tong-xin-liu-cheng/../../%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/./%E8%B0%88%E4%B8%80%E8%B0%88TCP%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B/image-20200418092345166.png" alt="image-20200418092345166"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈TCP的4次挥手</title>
      <link href="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/"/>
      <url>/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<p>TCP是全双工传输协议，也就是说双方都可进行读写操作，当一方不需要写数据时，会通过发送FIN报文告知对方，我要关闭连接了，对方接受到并返回ACK报文，这就表示一方的连接已经关闭，此时另一方的连接还是OK的，也就是说另一方还是可以继续写数据的，等到另一方也发完数据之后就可以发送FIN报文。</p><blockquote><p>注意，接收到FIN报文时系统只能返回一个ACK，它无法发出FIN报文，因此FIN报文的发出是由业务层来触发的。</p></blockquote><h3 id="4次挥手流程"><a href="#4次挥手流程" class="headerlink" title="4次挥手流程"></a>4次挥手流程</h3><p>TCP建立连接到4次挥手流程如下：</p><p><img src="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/./谈一谈TCP的4次挥手/image-20200418092247425.png" alt="image-20200418092247425"></p><p>注意，4次挥手流程有一个TIME_WAIT阶段（TIME_WAIT的作用是保证关闭连接后这个连接在网络中的所有数据包都过期，否则的话可能存在这样的问题，连接关闭了但是网络中还残留旧连接的报文，这样如果以同样的TCP 4元组新建的连接可能会接收到该旧报文，会以为是新连接的报文而导致问题），更详细的4次挥手流程如下：</p><p><img src="/2020/04/18/tan-yi-tan-tcp-de-4-ci-hui-shou/./谈一谈TCP的4次挥手/image-20200418092345166.png" alt="image-20200418092345166"></p><h3 id="4次挥手中的问题分析"><a href="#4次挥手中的问题分析" class="headerlink" title="4次挥手中的问题分析"></a>4次挥手中的问题分析</h3><p>从4次挥手的流程来看，可能存在问题的地方有，主动断开连接端的FIN_WAIT_2和TIME_WAIT阶段，被动断开连接端的CLOSE_WAIT阶段：</p><h4 id="CLOSE-WAIT阶段"><a href="#CLOSE-WAIT阶段" class="headerlink" title="CLOSE_WAIT阶段"></a>CLOSE_WAIT阶段</h4><p>正常情况下CLOSE_WAIT存在的时间很短，因为稍后被动关闭端会发出FIN报文，然后进到 LAST_ACK 状态。如果系统中存在较多的CLOSE_WAIT 状态的连接，说明是本端服务没有处理好，比如：</p><ul><li><strong>本身程序问题</strong>：应用层忘记进行close，或者close不及时，再或者应用没有及时对端发送来的FIN报文响应close动作；</li><li><strong>新建连接太多问题</strong>：比如存在（3次握手中的）已连接队列中的连接未被应用及时accept导致客户端已经close了，此时连接就处于CLOSE_WAIT阶段了。</li></ul><p>出现了CLOSE_WAIT 状态连接过多，只要确定了是什么原因，就可以对症解决了，这里不再赘述。</p><h4 id="FIN-WAIT-2阶段"><a href="#FIN-WAIT-2阶段" class="headerlink" title="FIN_WAIT_2阶段"></a>FIN_WAIT_2阶段</h4><p>正常情况下FIN_WAIT_2阶段的存在时间也很短，因为对端会很快发出FIN报文，如果发现处于FIN_WAIT_2状态的连接过多，说明是对端没有及时发出FIN报文，这个是对端的原因，本端无法控制，不过本端可以设置FIN_WAIT_2的超时时间，对于配置项为 <code>net.ipv4.tcp_fin_timeout</code> ，来避免该问题。</p><h4 id="TIME-WAIT阶段"><a href="#TIME-WAIT阶段" class="headerlink" title="TIME_WAIT阶段"></a>TIME_WAIT阶段</h4><p>当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态，TIME_WAIT存在的意义是保证关闭连接后这个连接在网络中的所有数据包都过期，否则的话可能存在这样的问题，连接关闭了但是网络中还残留旧连接的报文，这样如果以同样的TCP 4元组新建的连接可能会接收到该旧报文，会以为是新连接的报文而导致问题，因此TIME_WAIT 的存在是为了保证网络中迷失的数据包正常过期。</p><p>说到过期时间，就不得不提 最大分段寿命（MSL, Maximum Segment Lifetime），它表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃。</p><blockquote><p>MSL 的时长被 RFC 定义为 2分钟，但在不同的 unix 实现上，这个值不并确定，我们常用的 centOS 上，它被定义为 30s，我们可以通过 /proc/sys/net/ipv4/tcp_fin_timeout 这个文件查看和修改这个值。</p></blockquote><p>TIME_WAIT阶段存在的问题是 TIME_WAIT 状态连接过多，会占用过多的句柄资源，严重时系统无法发起新的连接。可以通过配置来设定超时时间、TIME_WAIT连接重用等机制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解TCP的3次握手</title>
      <link href="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/"/>
      <url>/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说起TCP的三次握手，大多数小伙伴多少都听说过一些，因此本文不再赘述三次握手的详细流程，而是重点关注三次握手中半连接队列和全连接队列流程，以及二者队列满了时的处理机制，最后分析下常见的三次握手的问题，这些问题大都也是和半连接队列和全连接队列相关的。</p></blockquote><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP三次握手大致流程如下：</p><ol><li>client 发送 syn 到server 发起握手；</li><li>server 收到 syn后回复syn+ack给client；</li><li>client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack，这时表示连接建立完成。</li></ol><p><img src="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/./深入理解TCP的3次握手/image-20200417223702161.png" alt="image-20200417223702161"></p><p>三次握手对应抓包如下：</p><p><img src="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/./深入理解TCP的3次握手/image-20200417223741532.png" alt="image-20200417223741532"></p><h3 id="半连接队列-全连接队列"><a href="#半连接队列-全连接队列" class="headerlink" title="半连接队列/全连接队列"></a>半连接队列/全连接队列</h3><p>上面说的TCP三次握手并没有提到半连接队列和全连接队列，其实三次握手流程中还涉及到半连接和全连接队列之间的流转动作，对应的流程如下：</p><ol><li>client 发送 syn 到server 发起握手；</li><li>server 收到 syn后回复syn+ack给client，同时server端会将连接放到半连接队列；</li><li>client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack，这时表示连接建立完成，此时server端会将连接放到全连接队列（这时连接已经建立OK了，只不过进程还无感知，进程需要主动调用accept之后拿到该连接信息，并分配对应fd之后就可以进行IO读写操作了）。</li></ol><p><img src="/2020/04/17/shen-ru-li-jie-tcp-de-3-ci-wo-shou/./深入理解TCP的3次握手/image-20200417224752248.png" alt="image-20200417224752248"></p><blockquote><p>如上图所示，这里有两个队列：syns queue(半连接队列）；accept queue（全连接队列）。</p></blockquote><h3 id="队列满时处理机制"><a href="#队列满时处理机制" class="headerlink" title="队列满时处理机制"></a>队列满时处理机制</h3><p>半连接队列和全连接队列满时有以下3种场景：</p><ul><li><strong>半连接满了，全连接未满</strong>：当半连接满了时，默认处理机制是，TCP忽略请求，也不发送RST，为什么要这么处理呢？因为这样做是暂时的，客户端将重新发送SYN，期望不久就能得到服务。假如服务端响应一个RST，客户端的connect就会返回错误，而不是让重传机制来处理，这样客户无法区分SYN的RST是因为<strong>“该端口没有在监听”还是”该端口在监听，只不过它的队列满了”</strong>。</li><li><strong>半连接未满，全连接满了</strong>：当全连接队列满了时，再往全连接队列塞时操作系统会按照 <code>tcp_abort_on_overflow</code> 的指示执行，默认为0表示扔掉client发过来的ack（在server端认为连接还没建立起来），为1表示发送一个reset包给client。</li><li><strong>半连接和全连接都满了</strong>：相当于集中了以上所述的2种场景的最差场景，新连接默认不处理让TCP重传机制进行重试，往全连接队列塞时默认按照 <code>tcp_abort_on_overflow</code> 指示来执行。</li></ul><p>半连接/全连接队列的大小到底是多少呢？</p><blockquote><p>准确来说，全连接队列的大小取决于：min(backlog, somaxconn) . backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数，也就是/proc/sys/net/core/somaxconn的大小。半连接队列的大小取决于：max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。 不同版本的os会有些差异。</p></blockquote><h3 id="常见问题分析"><a href="#常见问题分析" class="headerlink" title="常见问题分析"></a>常见问题分析</h3><ul><li>网站服务中常见的syn floods攻击，就是针对半连接队列攻击的，攻击客户端不停地新建连接，但是它只、不会处理接收到的第二步的响应结果，导致server端半连接队列满了而无法处理正常进来的建立连接请求。</li><li>压测场景中可能存在的连接建立不上问题，可能是默认的backlog较小导致，这样很容易导致队列满了，然后忽略该请求报文，客户端迟迟建立不上连接。</li><li>全连接队列攻击，攻击客户端只连接而不进行发送数据的一种攻击方式，如果服务端使用的是一个线程一个连接的处理方式，会白白占用很多线程资源；如果是NIO处理方式，虽然不用多占用线程资源，但是也是会白白占用fd资源的。</li></ul><p><strong>最后我们想一下，TCP为什么需要3次握手呢？</strong></p><p>一句话总结就是：3次握手保证了连接的可靠性与效率。3次握手过程中，会交换各自的一些信息，比如窗口大小、初始报文序号等，如果只有2次握手，不能保证客户端一定能收到服务端的响应报文（SYN+ACK）。</p><p><strong>参考资料</strong>：</p><p>1、<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53374516</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="/2020/04/12/linux-xin-hao/"/>
      <url>/2020/04/12/linux-xin-hao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>信号是一种异步处理的软中断，内核会发送给进程某些异步事件，这些异步事件可能来自硬件，比如除0或者访问了非法地址；也可能来自其他进程或用户输入，比如ctrl+c。</p></blockquote><p>信号是一种进程间通信机制，信号都有一个对应的默认处理行为，信号触发时，信号处理函数和进程正常的执行流程同时存在，这会给编程带来隐患，如果信号处理函数中调用了不可重入函数的话。信号同其他进程间通信技术（管道、共享内存）相比，传递的信息还是有限的，由于信息较少所以也方便管理，一般在系统管理中使用，比如终止或者恢复进程等。</p><p>信号的默认处理操作有：</p><ul><li><strong>显式地忽略信号</strong>：即内核将会丢弃该信号，信号不会对目标进程产生任何影响。</li><li><strong>终止进程</strong>：很多信号的默认处理是终止进程，即将进程杀死。</li><li><strong>生成核心转储文件并终止进程</strong>：进程被杀死，并且产生核心转储文件。核心转储文件记录了进程死亡现场的信息。用户可以使用核心转储文件来调试，分析进程死亡的原因。</li><li><strong>停止进程</strong>：停止进程不同于终止进程，终止进程是进程已经死亡，但是停止进程仅仅是使进程暂停，将进程的状态设置成TASK_STOPPED，一旦收到恢复执行的信号，进程还可以继续执行。</li><li><strong>恢复进程的执行</strong>：和停止进程相对应，某些信号可以使进程恢复执行。</li></ul><blockquote><p>如果想要自定义信号处理逻辑，可以使用signal/sigaction函数接口来设置信号处理函数。</p></blockquote><p>Linux信号可以分为两类：可靠信号和不可靠信号，信号值在<code>[1，31]</code> 之间的所有信号，都被称为不可靠信号；在<code>[SIGRTMIN，SIGRTMAX]</code> 之间的信号，被称为可靠信号。这二者之间是如何实现的呢？</p><p>对于不可靠信号，内核用位图来记录该信号是否处于挂起状态。如果收到某不可靠信号，内核发现已经存在该信号处于未决状态，就会简单地丢弃该信号。因此发送不可靠信号，信号可能会丢失，即内核递送给目标进程的次数，可能小于信号发送的次数。对于可靠信号，内核内部有队列来维护，如果收到可靠信号，内核会将信号挂到相应的队列中，因此不会丢失。严格说来，内核也设有上限，挂起信号的个数也不能无限制地增大，因此只能说，在一定范围之内，可靠信号不会被丢弃。</p><blockquote><p>信号未决状态是指 从生成信号到信息处理逻辑执行的这段时间。</p></blockquote><p>常见的Linux信号如下（可以通过命令kill -l查看）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP 1 终端挂起或控制进程终止。当用户退出Shell时，由该进程启动的所有进程都会收到这个信号，默认动作为终止进程。</span><br><span class="line">SIGINT 2 键盘中断。当用户按下组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</span><br><span class="line">SIGQUIT 3 键盘退出键被按下。当用户按下或组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为退出程序。</span><br><span class="line">SIGFPE 8 发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</span><br><span class="line">SIGKILL 9 无条件终止进程。进程接收到该信号会立即终止，不进行清理和暂存工作。该信号不能被忽略、处理和阻塞，它向系统管理员提供了可以杀死任何进程的方法。</span><br><span class="line">SIGALRM 14 定时器超时，默认动作为终止进程。</span><br><span class="line">SIGTERM 15 程序结束信号，可以由 kill 命令产生。与SIGKILL不同的是，SIGTERM 信号可以被阻塞和终止，以便程序在退出前可以保存工作或清理临时文件等。</span><br></pre></td></tr></table></figure><h3 id="信号的执行时机"><a href="#信号的执行时机" class="headerlink" title="信号的执行时机"></a>信号的执行时机</h3><p>每个进程有一个对应的”信号表“的东东，当内核传递给进程信号时，会在该进程对应的信号表中写入信号，当进程由内核态切换到用户态时，会查信号表，如果有信号，则会执行信号处理逻辑。从信号生成到执行信号处理逻辑这段时间，信号是未决的。</p><p>在信号处理函数期间，有可能还会收到其他信号，当然也有可能再次收到正在处理的信号。如果在处理A信号期间再次收到A信号，会发生什么呢？</p><blockquote><p>对于传统的System V信号机制，在信号处理期间，不会屏蔽对应的信号，而这就会引起信号处理函数的重入。这算是传统的System V信号机制的另一个弊端了。BSD信号处理机制修正了这个缺陷。当然了，BSD信号处理机制只是屏蔽了当前信号，并没有屏蔽当前信号以外的其他信号。</p></blockquote><h3 id="信号与线程"><a href="#信号与线程" class="headerlink" title="信号与线程"></a>信号与线程</h3><p>目前进程大都是多线程的，如果向某个多线程的进程发信号，到底由哪个线程来处理呢？</p><p>注意信号处理是属于进程维度的，我们都知道每个线程可以有自己的信号掩码，在POSIX标准下，发给进程的信号会在进程下某个未阻塞该信号的线程中随机选择。如果信号默认行为是终止操作，那么所有线程都会game over的，而不仅仅是接收到信号的那个线程。</p><p>注意这里讨论的信号和Java中的信号量不是一回事，Java中的 <code>Semaphore</code> 信号量是用来控制同时访问特定资源的线程数量，它通过协调各个线程，保证合理的使用公共资源。Semaphore可用作流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p><p><strong>参考资料</strong>：</p><p>1、<a href="https://www.jianshu.com/p/9c9b74f6a222" target="_blank" rel="noopener">https://www.jianshu.com/p/9c9b74f6a222</a></p><p>2、Linux环境编程：从应用到内核</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux inode那些事儿</title>
      <link href="/2020/04/11/linux-inode-na-xie-shi-er/"/>
      <url>/2020/04/11/linux-inode-na-xie-shi-er/</url>
      
        <content type="html"><![CDATA[<p>在理解inode之前，先了解下磁盘扇区，磁盘的最小单位，我们都知道，磁盘一个扇区是512个字节。磁盘读写是都是按照块来操作的，一个块一般是4K，也就是连续的8个扇区，以块为单位读写是为了提高性能。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>磁盘上<strong>inode节点存储</strong>和<strong>数据“块”</strong>存储是在两个不同的区域，inode存储文件的元数据，但是不包括变长的文件名信息，因此inode大小是固定的，包含的元数据如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 文件的字节数</span><br><span class="line">* 文件拥有者的User ID</span><br><span class="line">* 文件的Group ID</span><br><span class="line">* 文件的读、写、执行权限</span><br><span class="line">* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">* 链接数，即有多少文件名指向这个inode</span><br><span class="line">* 文件数据block的位置</span><br></pre></td></tr></table></figure><p>可以使用 <em>stat file_name</em> 查看文件的inode数据，硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>因此，对于存储大量小文件来说，可能文件系统的inode不够用，如果inode资源耗尽，就无法新建文件。比如阿里的TFS（专门用于存储小文件的分布式存储）就是将小文件合并成“大块”文件来存储的，节省inode资源。</p><p>可以使用 df -i 查看各个分区的Inode使用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[luoxn28@localhost ~]$ df -i</span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on</span><br><span class="line">/dev/sda3      9283072 297711 8985361    4% /</span><br><span class="line">devtmpfs        180632    384  180248    1% /dev</span><br><span class="line">tmpfs           184648      1  184647    1% /dev/shm</span><br><span class="line">tmpfs           184648    914  183734    1% /run</span><br><span class="line">tmpfs           184648     16  184632    1% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       153600    334  153266    1% /boot</span><br><span class="line">tmpfs           184648     20  184628    1% /run/user/1000</span><br></pre></td></tr></table></figure><h3 id="innode号码"><a href="#innode号码" class="headerlink" title="innode号码"></a>innode号码</h3><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。使用<code>*ls -i file_name*</code>命令可以查看inode号码。</p><h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><p>目录也是一种文件，也有自己的inode，其inode本身存储该目录的元信息，对应的块内容存储一系列文件（目录+文件），每个文件包括文件名及其对应的inode编号。</p><h3 id="硬链接与软连接"><a href="#硬链接与软连接" class="headerlink" title="硬链接与软连接"></a>硬链接与软连接</h3><p>硬链接和软连接都是对应同一个文件块，只不过：</p><ul><li><strong>硬链接</strong>：两个文件名对应同一个inode节点，只不过inode节点的连接数为2，删除其中一个硬链接时不会真正删除文件，只有在inode连接数为0时才会删除文件；</li><li><strong>软连接</strong>：两个文件名分别对应各自的inode节点，这两个inode节点指向同一个文件块，通过原来文件名删除文件后，建立的软连接无法使用了，软连接类似于windows的快捷方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面更换算法</title>
      <link href="/2020/04/11/ye-mian-geng-huan-suan-fa/"/>
      <url>/2020/04/11/ye-mian-geng-huan-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统为什么需要页面更换呢，因为物理内存不够，不可能同时加载所需的所有数据页，因此只能加载正在或最近要使用的内存页。页面更换的目标是，尽量替换掉不再使用或者一段时间内不再使用的内存页，要不然会很容易触发缺页中断，该操作代价较大，涉及到从磁盘加载，因此页面更换可不是随便的事情。</p></blockquote><p>为了达到降低随后发生缺页中断的次数或者概率，人们设计出了各种各样的页面替换算法，这些算法大致可分为公平算法和非公平算法。</p><ul><li>公平算法：随机算法、FIFO算法、时钟算法。</li><li>非公平算法：NRU算法、LRU算法、工作集算法。</li></ul><h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p>这种就是简单的随机选择进行页替换，无需多言，简单粗暴。</p><h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><p>这种就是先来后到，可以使用链表记录页分配的先后顺序，淘汰时按照顺序淘汰即可，也是非常的简单粗暴。</p><h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>内存使用中的页按照时钟的逻辑形状，淘汰页时按照时钟顺序检查，如果页未访问到（每个页对应一个访问标识，未访问到时设置为0），则直接替换；如果访问过则设置访问位为0，方便下次淘汰。时钟逻辑图如下：</p><p><img src="/2020/04/11/ye-mian-geng-huan-suan-fa/./页面更换算法/image-20200411171144181.png" alt="image-20200411171144181"></p><h3 id="NRU算法"><a href="#NRU算法" class="headerlink" title="NRU算法"></a>NRU算法</h3><p>最近未使用算法，将最近一段时间没有访问过的页面进行替换，作出这种选择是基于程序访问的时空局域性。依据时空局域性，一个最近没有访问过的页面，在随后的时间内也不太可能被访问，而NRU的实现就是利用页面的访问和修改位来实现的。</p><blockquote><p>时空局限性在很多程序设计思想中有体现，比如rocketmq中page cache缓存最近读写的消息数据等。</p></blockquote><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>LRU是对NRU算法的改进，其考虑的是最近使用的频率而不是最近是否使用过。LRU算法的实现必须以某种方式记录每个页面被访问的次数，简单的办法就是在页表的记录项里面增加一个计数域，一个页面被访问一次，则这个计数器的值加1；或者使用链表结构，每访问一次就将该页移动到链表头。</p><h3 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h3><p>考虑到LRU算法实现，其需要对每个页面保持某种记录，并在每次页面访问时或周期性对这些记录更新，造成时间空间成本高。工作集概念来源于程序访问的时空局域性，在一段时间内，程序访问的页面将局限在一组页面集合上。</p><p>例如，最近K次访问均发生在某m个页面上，那么m就是参数为k时的工作集。用w(k, t)表示时间t时k次访问所涉及的页面数量。显然随着k的增长，w(k, t)的值将随之增长，在k增长至某个数值后，w(k, t)值增长将及其缓慢甚至接近停滞，并维持一段时间。</p><p><img src="/2020/04/11/ye-mian-geng-huan-suan-fa/./页面更换算法/image-20200411171208269.png" alt="image-20200411171208269"></p><p>工作集算法就是操作系统局限性的一种体现，一段时间内，CPU操作的数据大都集中在少量数据上，因此可以应用工作集算法来进行页的替换操作。</p><h2 id="Redis中的内存淘汰"><a href="#Redis中的内存淘汰" class="headerlink" title="Redis中的内存淘汰"></a>Redis中的内存淘汰</h2><p>以上分析了操作系统中的页面更换算法，更广义来讲，页面更换就是内存淘汰，操作系统的页面更换算法可能不能直接让开发者<code>感同身受</code>，毕竟这是OS层面的东东。下面就以实际开发中常用到的Redis为例，来分析下<strong>Redis内存淘汰策略</strong>，对比加深对内存淘汰的理解。</p><p><strong>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据</strong>。目前Redis的内存淘汰策略有如下几种：</p><ul><li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><p>对于LRU（Least Recent Used），淘汰掉最不经常使用的，LRU可以通过<code>hashMap + 双向链表</code>来实现，如果Redis也基于hashMap + 双向链表实现，显然要对目前的数据结构做较大改动，为了追求空间的利用率，Redis采用权衡的实现方案：<strong>Redis会基于server.maxmemory_samples配置选取固定数目的key，然后比较它们的lru访问时间，然后淘汰最近最久没有访问的key，maxmemory_samples的值越大，Redis的近似LRU算法就越接近于严格LRU算法，但是相应消耗也变高，对性能有一定影响，样本值默认为5</strong>。</p><blockquote><p>从Redis的内存淘汰实现方案来看，虽然遵循了LRU思想但不完全照搬，根据实际应用场景进行trade-off。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>磁盘IO</title>
      <link href="/2020/04/08/ci-pan-io/"/>
      <url>/2020/04/08/ci-pan-io/</url>
      
        <content type="html"><![CDATA[<p>基本概念：</p><ul><li>IOPS：每秒输入输出量（读写次数）。</li><li>吞吐量：单位时间内成功传输的数据量。</li></ul><h3 id="VFS（虚拟文件系统层）"><a href="#VFS（虚拟文件系统层）" class="headerlink" title="VFS（虚拟文件系统层）"></a>VFS（虚拟文件系统层）</h3><p>VFS是虚拟文件系统层（进程与文件系统之间的抽象层），与它相关的数据结构只存在于物理内存当中。其目的是屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一接口，正是由于VFS的存在，Linux中允许多个不同的文件系统共存。</p><p>VFS中包含着向物理文件系统转换的一系列数据结构，如VFS超级块、VFS的Inode、各种操作函数的转换入口等。Linux中VFS依靠四个主要的数据结构来描述其结构信息，分别为超级块、索引结点、目录项和文件对象，这些数据结构大都会与磁盘上的对应上。</p><ul><li><strong>超级块（Super Block）</strong>：超级块对象表示一个文件系统。它存储一个已安装的文件系统的控制信息，包括文件系统名称（比如Ext2）、文件系统的大小和状态、块设备的引用和元数据信息（比如空闲列表等等）。超级块与磁盘上文件系统的超级块对应。</li><li><strong>索引结点（Inode）</strong>：索引结点对象存储了文件的相关元数据信息，例如：文件大小、设备标识符、用户标识符、用户组标识符等等。Inode分为两种：一种是VFS的Inode，一种是具体文件系统的Inode。前者在内存中，后者在磁盘中。所以每次其实是将磁盘中的Inode调进填充内存中的Inode，这样才是算使用了磁盘文件Inode。当创建一个文件的时候，就给文件分配了一个Inode。一个Inode只对应一个实际文件，一个文件也会只有一个Inode（Unix/Linux系统中目录也是一种文件，打开目录实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码）。</li><li><strong>目录项（Dentry）</strong>：引入目录项对象的概念主要是出于方便查找文件的目的。不同于前面的两个对象，目录项对象只存在于内存中，实际对应的是磁盘的目录innode对象。VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的Inode，那么沿着目录项进行操作就可以找到最终的文件。</li><li><strong>文件对象（File）</strong>：文件对象描述的是进程已经打开的文件。因为一个文件可以被多个进程打开，所以一个文件可以存在多个文件对象，但多个文件对象其对应的索引节点和目录项对象肯定是惟一的，关系如下图：</li></ul><p><img src="/2020/04/08/ci-pan-io/./磁盘IO/image-20200411060303200.png" alt="image-20200411060303200"></p><blockquote><p>由于进程中File对象有独立的文件偏移量（current file offset），因此多个进程可以读写文件的不同位置的数据，但是一般不建议这样玩，因为系统不保证该情况下的写的原子性，多进程可以通过文件锁实现对文件内容的写保护。</p></blockquote><h3 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h3><p>Page cache是通过将磁盘中的数据缓存到内存中，从而减少磁盘I/O操作，从而提高性能。此外，还要确保在page cache中的数据更改时能够被同步到磁盘上，后者被称为page回写（page writeback）。一个inode对应一个page cache对象，一个page cache对象包含多个物理page。</p><p>当内核发起一个读请求时（例如进程发起read()请求），首先会检查请求的数据是否缓存到了page cache中，如果有，那么直接从内存中读取，不需要访问磁盘，这被称为cache命中（cache hit）。如果cache中没有请求的数据，即cache未命中（cache miss），就必须从磁盘中读取数据。然后内核将读取的数据缓存到cache中，这样后续的读请求就可以命中cache了。page可以只缓存一个文件部分的内容，不需要把整个文件都缓存进来。</p><p>当内核发起一个写请求时（例如进程发起write()请求），同样是直接往cache中写入，此时不会立即同步到磁盘，而是将写入的page设置为脏页，并将其加入dirty list中，内核会负责定期同步到磁盘保持二者一执行。</p><p>page cache另一个主要工作是回收page释放内存空间，此时会选择合适的page进行释放，如果是脏页会先同步到磁盘然后释放。此时是如何选择cache页的呢？Linux使用的策略是基于LRU改进的Two-List策略：</p><blockquote><p>Two-List策略维护了两个list，active list 和 inactive list。在active list上的page被认为是hot的，不能释放。只有inactive list上的page可以被释放的。首次缓存的数据的page会被加入到inactive list中，已经在inactive list中的page如果再次被访问，就会移入active list中。两个链表都使用了伪LRU算法维护，新的page从尾部加入，移除时从头部移除，就像队列一样。如果active list中page的数量远大于inactive list，那么active list头部的页面会被移入inactive list中，从而位置两个表的平衡。</p></blockquote><p>触发脏页回写到磁盘时机如下：</p><ul><li>用户进程调用sync() 和 fsync()系统调用；</li><li>空闲内存低于特定的阈值（threshold）；</li><li>Dirty数据在内存中驻留的时间超过一个特定的阈值。</li></ul><h3 id="追加写"><a href="#追加写" class="headerlink" title="追加写"></a>追加写</h3><p>一个良好的写性能优化策略是使用追加写，因为追加写是顺序的，拥有良好的写操作性能。但是该方式下，针对数据更新操作的读操作会多花费一些时间，需要多扫描一些数据找到对应数据，比如LSM等。追加写比较适合数据更新不频繁但是读较频繁场景，比如：</p><ul><li><strong>数据被整体访问，HDFS</strong>：HDFS建立在一次写多次读的模型之上。在HDFS中就是采用了追加写并且设计为高数据吞吐量；高吞吐量必然以高延迟为代价，所以HDFS并不适用于对数据访问要求低延迟的场景；由于采用是的追加写，也并不适用于任意修改文件的场景。HDFS设计为流式访问大文件，使用大数据块并且采用流式数据访问来保证数据被整体访问，同时最小化硬盘的寻址开销，只需要一次寻址即可，这时寻址时间相比于传输时延可忽略，从而也拥有良好的读性能。HDFS不适合存储小文件，原因之一是由于NameNode内存不足问题，还有就是因为访问大量小文件需要执行大量的寻址操作，并且需要不断的从一个datanode跳到另一个datanode，这样会大大降低数据访问性能。</li><li><strong>消息的追加写，Kafka</strong>：在Kafka中，采用消息追加的方式来写入每个消息，每个消息读写时都会利用Page Cache的预读和后写特性，同时partition中都使用顺序读写，以此来提高I/O性能。虽然Kafka能够根据偏移量查找到具体的某个消息，但是查找过程是顺序查找，因此如果数据很大的话，查找效率就很低。所以Kafka中采用了分段和索引的方式来解决查找效率问题。Kafka把一个patition大文件又分成了多个小文件段，每个小文件段以偏移量命名，通过多个小文件段，不仅可以使用二分搜索法很快定位消息，同时也容易定期清除或删除已经消费完的文件，减少磁盘占用。为了进一步提高查找效率，Kafka为每个分段后的数据建立了索引文件，并通过索引文件稀疏存储来降低元数据占用大小。</li></ul><p>在面对更复杂的读场景（比如按key）时，如何来保证读操作的性能呢？简单的方式是像Kafka那样，将文件数据有序保存，使用二分查找来优化效率；或者通过建索引的方式来进行优化；也可以采用hash的方式将数据分割为不同的桶。以上的方法都能增加读操作的性能，但是由于在数据上强加了数据结构，又会降低写操作的性能。比如如果采用索引的方式来优化读操作，那么在更新索引时就需要更新B-tree中的特定部分，这时候的写操作就是随机写。那么有没有一种办法在保证写性能不损失的同时也提供较好的读性能呢？一个好的选择就是使用LSM-tree。LSM-tree与B-tree相比，LSM-tree牺牲了部分读操作，以此大幅提高写性能。</p><blockquote><p>日志结构的合并树LSM（The Log-Structured Merge-Tree）是HBase，LevelDB等NoSQL数据库的存储引擎。Log-Structured的思想是将整个磁盘看做一个日志，在日志中存放永久性数据及其索引，每次都添加到日志的末尾。并且通过将很多小文件的存取转换为连续的大批量传输，使得对于文件系统的大多数存取都是顺序的，从而提高磁盘I/O。LSM-tree就是这样一种采用追加写、数据有序以及将随机I/O转换为顺序I/O的延迟更新，批量写入硬盘的数据结构。LSM-tree将数据的修改增量先保存在内存中，达到指定的大小限制后再将这些修改操作批量写入磁盘。因此比较旧的文件不会被更新，重复的纪录只会通过创建新的纪录来覆盖，这也就产生了一些冗余的数据。所以系统会周期性的合并一些数据，移除重复的更新或者删除纪录，同时也会删除上述的冗余。在进行读操作时，如果内存中没有找到相应的key，那么就是倒序从一个个磁盘文件中查找。如果文件越来越多那么读性能就会越来越低，目前的解决方案是采用页缓存来减少查询次数，周期合并文件也有助于提高读性能。在文件越来越多时，可通过布隆过滤器来避免大量的读文件操作。LSM-tree牺牲了部分读性能，以此来换取写入的最大化性能，特别适用于读需求低，会产生大量插入操作的应用环境。</p></blockquote><h3 id="小文件优化策略"><a href="#小文件优化策略" class="headerlink" title="小文件优化策略"></a>小文件优化策略</h3><p>目前的大多数文件系统，如XFS/Ext4、GFS、HDFS，在元数据管理、缓存管理等实现策略上都侧重大文件。常见文件系统在海量小文件应用下性能表现不佳的根本原因是磁盘最适合顺序的大文件I/O读写模式，而非常不适合随机的小文件I/O读写模式。主要原因体现在元数据管理低效和数据布局低效：</p><ul><li>元数据管理低效：由于小文件数据内容较少，因此元数据的访问性能对小文件访问性能影响巨大。Ext2文件系统中Inode和Data Block分别保存在不同的物理位置上，一次读操作需要至少经过两次的独立访问。在海量小文件应用下，Inode的频繁访问，使得原本的并发访问转变为了海量的随机访问，大大降低了性能。另外，大量的小文件会快速耗尽Inode资源，导致磁盘尽管有大量Data Block剩余也无法存储文件，会浪费磁盘空间。</li><li>数据布局低效：Ext2在Inode中使用多级指针来索引数据块。对于大文件，数据块的分配会尽量连续，这样会具有比较好的空间局部性。但是对于小文件，数据块可能零散分布在磁盘上的不同位置，并且会造成大量的磁盘碎片，不仅造成访问性能下降，还大量浪费了磁盘空间。数据块一般为1KB、2KB或4KB，对于小于4KB的小文件，Inode与数据的分开存储破坏了空间局部性，同时也造成了大量的随机I/O。</li></ul><blockquote><p>对于海量小文件应用，常见的I/O流程复杂也是造成磁盘性能不佳的原因。对于小文件，磁盘的读写所占用的时间较少，而用于文件的open()操作占用了绝大部分系统时间，导致磁盘有效服务时间非常低，磁盘性能低下。针对于问题的根源，优化的思路大体上分为：</p></blockquote><ol><li>针对数据布局低效，采用小文件合并策略，将小文件合并为大文件。</li><li>针对元数据管理低效，优化元数据的存储和管理。针对这两种优化方式，业内也出现了许多优秀的开源软件。</li></ol><p><strong>小文件合并 </strong>小文件合并为大文件后，首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的I/O操作延时。其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。同时，合并存储能够有效的减少小文件存储时所产生的磁盘碎片问题，提高了磁盘的利用率。</p><blockquote><p>合并之后小文件的访问流程也有了很大的变化，由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可。如何寻址这个大文件中的小文件呢？其实就是利用一个旁路数据库来记录每个小文件在这个大文件中的偏移量和长度等信息。其实小文件合并的策略本质上就是通过分层的思想来存储元数据。中控节点存储一级元数据，也就是大文件与底层块的对应关系；数据节点存放二级元数据，也就是最终的用户文件在这些一级大块中的存储位置对应关系，经过两级寻址来读写数据。比如阿里的TFS就采用了小文件合并存储的策略，TFS中默认Block大小为64M，每个块中会存储许多不同的小文件，但是这个块只占用一个Inode。</p></blockquote><p><strong>元数据管理优化</strong> 一般来说元数据信息包括名称、文件大小、设备标识符、用户标识符、用户组标识符等等，在小文件系统中可以对元数据信息进行精简，仅保存足够的信息即可。元数据精简可以减少元数据通信延时，同时相同容量的Cache能存储更多的元数据，从而提高元数据使用效率。另外可以在文件名中就包含元数据信息，从而减少一个元数据的查询操作。最后针对特别小的一些文件，可以采取元数据和数据并存的策略，将数据直接存储在元数据之中，通过减少一次寻址操作从而大大提高性能。</p><blockquote><p>TFS中文件命名就隐含了位置信息等部分元数据，从而减少了一个元数据的查询操作。</p></blockquote><p><strong>参考资料</strong>：</p><p>1、<a href="https://tech.meituan.com/2017/05/19/about-desk-io.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/05/19/about-desk-io.html</a></p><p>2、<a href="https://www.linuxidc.com/Linux/2018-12/156117.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2018-12/156117.htm</a></p><p>3、<a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/12/inode.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基本概念</title>
      <link href="/2020/04/08/cao-zuo-xi-tong-ji-ben-gai-nian/"/>
      <url>/2020/04/08/cao-zuo-xi-tong-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><p>内核态和用户是程序执行的两个状态，二者执行时的权限不同，内核态可以访问计算机所有资源，因此对于内核态程序的安全性要求较高。</p><blockquote><p>一般来说，如果一个程序能够运行于用户态，就应该让它运行在用户态。只在迫不得已的情况下，才让程序运行于内核态。凡是牵扯到计算机本体根本运行的事情都应该在内核态下执行，只与用户数据和应用相关的东西则放在用户态执行。另外，对时序要求特别高的操作，也应该在内核态完成。</p></blockquote><p>操作系统怎么知道一个程序是在内核态还是用户态的呢？操作系统通过处理器的一个状态位作为标志来区分的。内核态是特权态，用户态是非特权态，我们都知道对资源的限制访问，是通过对程序执行的每一条指令进行检查判断的，这个检查就是地址翻译时完成的。内核态程序可以绕过地址翻译的检查直接执行指令，这样就不会进行资源限制。</p><blockquote><p>注意用户态程序操作的地址都是虚拟内存地址，只有内核态程序才能够操作物理内存地址。</p></blockquote><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用要经过3个阶段：<strong>参数准备、系统调用识别、系统调用执行</strong>。</p><p>以 <code>read(fd, buffer, nbytes)</code> 为例，在参数准备阶段，需要使用系统服务的程序将系统调用所需要的参数，如上述例子中的fd、buffer、nbytes，压入栈中或者存放到对应寄存器中，然后调用read库函数，然后将read系统调用的代码放在一个约定好的寄存器里，通过陷入（trap，一种中断方式）将控制交给操作系统，后续会进行内核态执行。操作系统获得控制权后，将系统调用代码从寄存器里取出，与操作系统维护的一张系统调用表进行比较，获得read系统调用的程序体所在的内存地址。然后开始执行系统调用函数，执行完毕返回给用户程序，如下图。</p><p><img src="/2020/04/08/cao-zuo-xi-tong-ji-ben-gai-nian/./操作系统基本概念/image-20200408231131880.png" alt="image-20200408231131880"></p><blockquote><p>系统调用中参数传递有可能不是通过栈来传递的，比如x86下，系统调用函数中参数由寄存器传递，只有超过8个参数时，超过的部分参数才通过栈来传递。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>磁盘操作</title>
      <link href="/2020/04/08/ci-pan-cao-zuo/"/>
      <url>/2020/04/08/ci-pan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>磁盘作为计算机的底层存储，重要性不言而喻，操作系统的启动程序就是存在在磁盘的开始位置上的。</p></blockquote><p>磁盘是由多个盘片组成的，每个盘边两面都是可以存储数据。每个盘边对应一个读写磁头，所有读写磁头都是在同一个磁臂上，盘片则以每分钟3500转到10000转速率运转，即大约每6毫秒到17毫秒旋转一圈。该磁头由少量的空气垫层浮起，悬浮在盘面上方约几个微米的高度，磁头在盘面上的移动操作由一个伺服机构（<code>ser-vomechanism</code>）负责控制，注意不管是有多少个磁头，同一时间点只能有一个磁头处于活跃状态进行数据读写操作。</p><p>磁盘结构图如下：</p><p><img src="/2020/04/08/ci-pan-cao-zuo/./磁盘操作/image-20200408224459298.png" alt="image-20200408224459298"></p><p><strong>一个磁道上可以有多个扇区，一般扇区大小是512字节，扇区也是磁盘IO的最小单位</strong>。也就是说，磁盘读写的时候都是以扇区为最小寻址单位的，不可能往某个扇区的前半部分写入一部分数据。一个扇区的大小是512B，每次磁头连续读写的时候，只能以扇区为单位，即使一次只写了一个字节的数据，那么下一次新的文件写操作就不能再向这个扇区剩余的部分接着写入，而是要寻找一个空扇区来写。</p><p>磁道按照从外到圆心进行0、1…N的序号编号，不同盘面上相同编号则组成了一个柱面。注意磁盘读写都是按照柱面进行的，即磁头读写数据时首先在同一柱面内从0磁头开始进行操作，依次向下在同一柱面的不同盘面( 即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面，因为选取磁头只需通过电子切换即可 ，而选取柱面则必须通过机械切换。电子切换比从在机械上磁头向邻近磁道移动快得多。因此，数据的读写按柱面进行，而不按盘面进行。 读写数据都是按照这种方式进行，尽可能提高了硬盘读写效率。</p><h2 id="磁盘读写耗时"><a href="#磁盘读写耗时" class="headerlink" title="磁盘读写耗时"></a>磁盘读写耗时</h2><p>在了解了磁盘的结构之后，可以看出来磁盘读写耗时主要如下：</p><ul><li>寻道时间：磁头移动到指定磁道所需要的时间。</li><li>旋转时间：磁头在某个磁道上时，扇区移动到磁头下的时间。</li><li>传输时间：传输时间是磁头从删除进行数据读写的时间。<blockquote><p>磁盘读写耗时主要是花费在寻道和旋转时间上了，而从扇区读写数据通常较快，这也是预读能大幅提高性能的原因所在。</p></blockquote></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>磁盘读写耗时主要是花费在寻道和旋转时间上（前2个是机械运动），且这2个机械运动中瓶颈在于寻道时间，为了提高磁盘的读写效率，需要降低磁盘的寻道时间，实现的手段则是磁盘调度。因此调度算法有如下几种：</p><ul><li>先来先服务FCFS（First Come,First Serve）：先到先得，很公平，但是效率较低。</li><li>短任务优先STF（Shortest Task First）：读写数据较少的先执行，但是由于磁盘读写主要是花在寻道和旋转因此该方案收益不大。</li><li>短寻道优先SSF（Shortest Seek First）：考虑当前磁头离谁的数据最近，谁就优先，此种策略似乎正中要害，能够缩短磁盘访问时间，但是如果在极端场景下反而不太好，比如来回的闪电型走位。</li><li>电梯调度ES（Elevator Scheduling）：先满足一个方向的所有请求，再满足所有反方向的请求，这样循环往复。</li><li>提前查看电梯调度ESLA（Elevator Scheduling with Look Ahead）：ES的简单优化，如果一个方向上不再有任务，提前反转运行，不用”撞到南墙”再返回。</li><li>单向电梯调度OWES（One Way Elevator Scheduling）：ESLA的不同版本，每次都是朝着同一方向运行，一个方向上不再有任务时回到原地再朝着原来同一方向执行一遍。</li></ul><p><strong>参考资料</strong>：</p><p>1、<a href="https://www.cnblogs.com/xiangsikai/p/9629243.html" target="_blank" rel="noopener">磁盘存放数据原理</a></p><p>2、《操作系统之哲学原理》</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据存储的秘密之分区</title>
      <link href="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/"/>
      <url>/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分区，又称为分片，是解决大数据存储的常见解决方案，大数据存储量超过了单节点的存储上限，因此需要进行分区操作将数据分散存储在不同节点上，通常每个单个分区可以理解成一个小型的数据库，尽管数据库能同时支持多个分区操作；分区引入多分区概念，可以同时对外服务提高性能。</p></blockquote><p>常常和分区一并提及的概念是复制，分区通常与复制结合使⽤，使得每个分区的副本存储在多个节点上。 这意味着，即使每条记录属于⼀个分区，它仍然可以存储在多个不同的节点上以获得容错能⼒。分区在许多技术或框架中都有体现，例如MQ中topic下的分区消息实现，如kafka中的partion、rocketmq中的queue等；例如SQL/NoSQL中分区数据储存实现，如ElascticSearch中的Shards分片、MySQL中的分表等。</p><p>关于分区，本文主要讨论下键值分区的几种方式、分区再平衡策略和请求路由处理机制等，最后以ES（ElascticSearch）的查询请求处理为例，分析分区下查询的请求处理流程。话不多说，Let’s Go~</p><h2 id="键值分区的几种方式"><a href="#键值分区的几种方式" class="headerlink" title="键值分区的几种方式"></a>键值分区的几种方式</h2><p>如果有大量数据需要分散存储，应该如何进行分区呢？分区的目前就是将数据均衡的分散在各节点，这样同时也能分散对数据的处理请求，如果分区不均衡，那么会造成某些分区有大量的数据或查询请求，这就是常说的倾斜。数据倾斜会造成高负载节点形成热点，避免热点可以使用随机路由方式将数据散列到各分区中。对数据进行分区操作，不能仅仅是随机数据存储，因为存储之后肯定还是要进行查询的，所以要按照固定键值来进行散列分区操作，方便后续查询请求的路由。常见的键值分区方式有按照范围分区、按照键的散列分区：</p><h4 id="按照范围分区"><a href="#按照范围分区" class="headerlink" title="按照范围分区"></a>按照范围分区</h4><p>按照范围分区就是每个分区存储指定一段连续的数据，比如按照时间戳来存储数据，最简单常见的日志按照时间分割为不同的文件；按照编号id来存储数据，如图书馆书籍陈列，编号连续数据存放在同一个书架上。按照范围分区有时候会造成分区数据不均衡，比如按照时间戳，可能某段时间内数据比较少而某些时间段数据较多而造成分区不均衡。</p><h4 id="键值散列分区"><a href="#键值散列分区" class="headerlink" title="键值散列分区"></a>键值散列分区</h4><p>由于按照范围分区容易造成数据负载不均衡问题，所以一般应用场景下（非顺序类型数据）为了避免偏斜和热点的⻛险，会使⽤散列函数来确定给定键的分区。一个好的散列函数会尽量随机分区，许多语言内都内置了散列函数，但是有些可能不太适合分区场景，比如Java的 Object.hashCode()和Ruby的 Object#hash，其同⼀个键可能在不同的进程中有不同的哈希值。<br>有了合适的散列函数，有时候想要让一定散列范围内的数据分布在同一分区，此时可使用一致性哈希，一致性哈希可减小因为分区变动造成会已有数据分区映射的影响。</p><h4 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h4><p>哈希分区可帮助减少热点，但是无法避免，极端情况下可能存在所有请求都打到同一分区中。热点分区问题解决思路是：一种是给热点分区再分区操作，比如针对热点数据的key再路由分散多个分区中；还有一种是热点数据增加冗余（也就是复制），增加热点数据的复制节点，一同对外提供服务。</p><h2 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h2><p>随着时间的推移，分区数据会有以下变化：</p><ul><li>查询吞吐量增加，所以您想要添加更多的CPU来处理负载。</li><li>数据集⼤⼩增加，所以您想添加更多的磁盘和RAM来存储它。</li><li>机器出现故障，其他机器需要接管故障机器的责任。</li></ul><p>所有这些更改都需要数据和请求从⼀个节点移动到另⼀个节点。 将负载从集群中的⼀个节点向另⼀个节点移动的过程称为再平衡（reblancing），再平衡过程一般要求如下：再平衡之后数据尽量均衡、在平衡时分区要正常地外提供服务、节点之间只移动必要数据以加快再平衡进度。（一般来说直接使用取余方式散列的分区再平衡时大都需要将所有数据重新取余再分区，成本较大。）</p><h4 id="固定数目的分区"><a href="#固定数目的分区" class="headerlink" title="固定数目的分区"></a>固定数目的分区</h4><p>为了避免分区的扩容再平衡操作，可以创建⽐节点更多的分区，并为每个节点分配多个分区。例如，运⾏在10个节点的集群上的数据库可能会从⼀开始就被拆分为1000个分区，因此⼤约有100个分区被分配给每个节点。比如ES就是用了这种再平衡方式，ES中的shards分片在运行时是无法更改的，因此生产环境一般会建议针对分区数设定留一定的余量，方便后续扩容操作。这样的话，分区的数量不会变化，知识分区数据会在节点间移动而已，键所指定的分区也不会改变。唯⼀改变的是分区所在的节点。这种变更并不是即时的，在⽹络上传输⼤量的数据需要⼀些时间，所以在传输过程中，原有分区仍然会接受读写操作。如下图所示：</p><p><img src="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/./大数据存储的秘密之分区/image-20200101144605809.png" alt></p><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>对于使用键范围场景来说，具有固定边界的固定数量的分区将⾮常不便：如果出现边界错误，则可能会导致⼀个分区中的所有数据或者其他分区中的所有数据为空。⼿动重新配置分区边界将⾮常繁琐。因此，按键范围进行分区的数据库（如HBase和RethinkDB）会动态创建分区。当分区增⻓<br>到超过配置的⼤⼩时（在HBase上，默认值是10GB），会被分成两个分区，每个分区约占⼀半的数据。与之相反，如果⼤量数据被删除并且分区缩⼩到某个阈值以下，则可以将其与相邻分区合并，类似B树的过程类似。<br>动态分区的⼀个优点是分区数量适应总数据量。如果只有少量的数据，少量的分区就⾜够了，所以开销很⼩；如果有⼤量的数据，每个分区的⼤⼩被限制在⼀个可配置的最⼤值，当超过阈值时触发分区操作。</p><blockquote><p>再平衡操作触发时，到底应该由人为触发还是由程序自动触发呢？程序自动触发，一般是检测节点负载过高或者（通过网络心跳发现）某个节点挂了，自动再平衡可能因为某些外界环境的影响就执行了，可能达不到我们的预期，因此，一个合理的方案是，程序自动发现应该执行再平衡时，可以报警通知到运维人员，由人工介入来处理后续的再平衡执行。</p></blockquote><h2 id="请求路由处理"><a href="#请求路由处理" class="headerlink" title="请求路由处理"></a>请求路由处理</h2><p>当处理请求时，如何确定哪个节点执行呢？随着分区再平衡，分区对节点的分配也发生变化，为了回答这个问题，需要有⼈知晓这些变化：如果我想读或写键“foo”，需要连接哪个节点IP地址和端⼝号？这个问题本质上就是<strong>服务发现</strong>，它不仅仅体现在数据库，任何网络通信场景都有这个问题，特别是如果它的⽬标是⾼可⽤性（在多台机器上运⾏冗余配置），都需要服务发现。概括来说，请求路由处理，有以下几种处理方案：</p><ol><li>允许客户联系任何节点（例如，通过循环策略的负载均衡（Round-Robin Load Balancer））。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求;否则，它将请求转发到适当的节点，接收回复并传递给客户端。</li><li>⾸先将所有来⾃客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。</li><li>要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，⽽不需要任何中介代理。</li></ol><p><img src="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/./大数据存储的秘密之分区/image-20200101162127730.png" alt><br>以上所有情况的关键问题是，做出路由决策的组件（可能是节点之一、客户端或者路由代理）如何知道分区-节点之间的映射关系。映射关系可以使固定写死在代码中，也可以是配置在配置中心中。许多分布式数据系统都依赖于⼀个独⽴的协调服务，⽐如ZooKeeper来跟踪集群元数据。 每个节点在ZooKeeper中注册⾃⼰，ZooKeeper维护分区到节点的可靠映射。 其他参与者（如路由层或分区感知客户端）可以在ZooKeeper中订阅此信息。 只要分区分配发⽣的改变，或者集群中添加或删除了⼀个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</p><p><img src="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/./大数据存储的秘密之分区/image-20200101162150745.png" alt></p><h4 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h4><p>请求处理查询可分为两种场景，单节点查询和集群查询，前者一般是针对一类数据的查询并且该类数据存储在同一个节点上，后者是同时发给多个节点，最后再做聚合操作。集群查询也称为并行查询，通常⽤于分析的⼤规模并⾏处理（MPP, Massively parallel processing） 关系型数据库产品在其⽀持的查询类型⽅⾯要复杂得多。⼀个典型的数据仓库查询包含多个连接，过滤，分组和聚合操作。</p><h3 id="ES的查询处理流程"><a href="#ES的查询处理流程" class="headerlink" title="ES的查询处理流程"></a>ES的查询处理流程</h3><p>ES使用开源的Lucene作为存储引擎，它赋予ES高性能的数据检索能力，但Lucene仅仅是一个单机索引库。ES基于Lucene进行分布式封装，以支持集群管理、分布式查询、聚合分析等功能。</p><p>从使用的直观感受看，ES查询分为2个阶段，query和fetch阶段。在query阶段会从所有的shard上读取相关document的docId及相关的排序字段值，并最终在coordinating节点上收集所有的结果数进入一个全局的排序列表后，然后获取根据from+size指定page页的数据，获取这些docId后再构建一个multi-get请求发送相关的shard上从_source里面获取需要加载的数据，最终再返回给client端。</p><p><strong>query阶段：</strong></p><p><img src="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/./大数据存储的秘密之分区/image-20200101162224238.png" alt><br><strong>fetch阶段</strong>：</p><p><img src="/2020/04/06/da-shu-ju-cun-chu-de-mi-mi-zhi-fen-qu/./大数据存储的秘密之分区/image-20200101162247519.png" alt><br>所有的搜索系统一般都是两阶段查询，第一阶段查询到匹配的DocID，第二阶段再查询DocID对应的完整文档，这种在Elasticsearch中称为query_then_fetch，还有一种是一阶段查询的时候就返回完整Doc，在Elasticsearch中称作query_and_fetch，一般第二种适用于只需要查询一个Shard的请求。由上图可知，ES允许客户联系任何节点，如果该节点恰巧拥有请求的分区，则它可以直接处理该请求;否则，它将请求转发到适当的节点，接收回复然后聚合并传递最终的聚合结果给客户端。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>大数据量场景在单台机器上存储和处理不再可⾏，则分区⼗分必要。分区的⽬标是在多台机器上均匀分布数据和查询负载，避免出现热点（负载不成⽐例的节点）。这需要选择适合于您的数据的分区⽅案，并在将节点添加到集群或从集群删除时进⾏再分区。</p><p>常见的键值分区方式有按照范围分区、按照键的散列分区两种。请求的处理机制一般有客户端处理、代理处理、服务节点处理3种方式，不管哪种方式，都需要其知道分区-节点之间的映射关系，一般映射关系是保存在配置中心上，比如zookeeper。</p><p>参考资料：</p><p>1、<a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">https://book.douban.com/subject/30329536/</a></p><p>2、elascticsearch 查询机制</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据序列化那些事</title>
      <link href="/2020/04/06/shu-ju-xu-lie-hua-na-xie-shi/"/>
      <url>/2020/04/06/shu-ju-xu-lie-hua-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于数据序列化，首先要了解为什么需要序列化以及数据序列化的意义是什么，然后再了解下当前较为广泛的几种序列化方式。</p></blockquote><p><strong>为什么需要数据序列化呢</strong>？因为数据要“传输”，比如将数据网络通信传递给其他服务器，或者持久化到磁盘。那么<strong>传输为什么需要序列化呢</strong>？因此在内存中的数据，当前进程是知道数据格式和内容的，但是数据传输是二进制（或文本格式），所以需要有一个内存数据格式转换为二进制（或文本格式）的过程。数据序列化，可以进行数据压缩、数据格式多语言兼容等。下面就按照序列化的技术演变过程一起看下序列化的发展之路。</p><p><strong>文本格式序列化</strong></p><p>直接将数据转变为文本格式，也就是字符串形式的文本保存，如果一个数据存在多个字段可使用固定分隔符（比如”,”）分隔，该方案存储简单但是针对复杂对象比如嵌套数据，存储起来较为麻烦，并且无法表示本来就是二进制格式的数据，比如图片、视频等。</p><p><strong>语言内置序列化</strong></p><p>目前编程语言基本都内置了至少一种数据序列化机制，比如Java的 Serialization、Python的pickle等，语言内置的序列化机制大都和该语言绑定，也就是说反序列化也必须是该语言才行，因此很难做到跨语言的读取写入。</p><p><strong>跨语言序列化</strong></p><p>语言内置的序列化大都和语言绑定，因此有了应用范围广泛、跨语言的数据序列化格式，例如json、xml等，但是这些跨语言序列化方案存在的最大劣势就是有性能问题，并且无数据类型信息，同时数据序列化冗余较大，比如json会保存每个属性名字。除了json和xml这种跨语言序列化之外，还有类似于hession这种跨语言序列化（这是序列化框架本身支持跨语言，目前只会Python/Java/C++等）的机制，序列化数据是二进制格式，并且包含数据类型信息。</p><p><strong>带schema描述序列化</strong></p><p>带有schema描述的数据表示格式，通过统一化的schema描述，可约束每个字段的类型，进而为存储和解析数据带来优化的可能。此外，统一schema的引入，可减少属性名称重复存储带来的开销，同时，也有利于数据共享。带有schema描述的序列化常用的有<code>Thrift、Protocol Buffers和Avro</code>，它们一般被称为<code>Language Of Data</code>，使得跨语言序列化成为可能，并且它们提供了代码生成工具，方便为开发者生成各个语言的代码。Language Of Data具有特性如下：</p><ul><li>提供<code>IDL（Interface Description language）</code>用以描述数据schema，用来定义结构化或者非结构化数据；</li><li>跨语言支持，至少支持<code>Java、Python和C/C++</code>；</li><li>数据编码压缩，比如字符串压缩和整数变长编码等；</li><li>数据序列化兼容，保证序列化的向后兼容性，比如旧schema序列化的数据可由新schema反序列化，新schema序列化也可以由旧schema解析等。</li></ul><p>关于protobuf为什么这么快可以参考文档：<a href="https://www.jianshu.com/p/72108f0aefca" target="_blank" rel="noopener">https://www.jianshu.com/p/72108f0aefca</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高可用的本质-复制</title>
      <link href="/2020/04/06/gao-ke-yong-de-ben-zhi-fu-zhi/"/>
      <url>/2020/04/06/gao-ke-yong-de-ben-zhi-fu-zhi/</url>
      
        <content type="html"><![CDATA[<p>服务和数据的高可用性本质上是靠“复制”来解决的，比如服务通过集群部署多台机器来完成，数据通过冗余的多副本机制来完成。对于服务来说，只需要部署多个实例即可，特别是无状态服务，常见的微服务(dubbo/spring cloud)几乎都是通过集群部署对外提供服务能力，更进一步的还可使用k8s+docker技术自动管理服务的副本容量；对于数据来说，需要通过数据复制来保证数据节点的一致性，由于数据是有状态的，因此实现难度较服务复制成本要高。</p><p>复制除了提高可用性之外（多机房数据复制提高机房容错性），还可以提高性能，比如读写分离、使数据副本离用户更近等，用户可优先就近读取数据。对于数据来说，常见的复制策略有主从复制、多主复制和无主复制，除了这些之外，还有一种常见的广义上“复制”策略-快照，比如Redis快照等。本文就针对上述几种复制策略展开分析，话不多少，Let’s go~</p><blockquote><p>本文后续讨论的复制无特殊说明都是针对数据复制来分析的，这里的复制讨论都是基于一个节点能保存所有数据为前提，因为数据量过大需要使用分区机制，而分区机制不在本文讨论范围之内 :(</p></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>如果数据不随着时间而变化，那么只需复制一次即可，复制的难处在于数据始终在变化，因此复制时有很多权衡，比如是否同步，复制失败的副本如何处理等。主从复制是常见的复制策略，写操作发生在主节点，然后将更新的数据同步到从节点。基于主从的复制模型如下：</p><p><img src="/2020/04/06/gao-ke-yong-de-ben-zhi-fu-zhi/./高可用的本质-复制/image-20191229224426641.png" alt><br>主从复制是许多数据库的内置功能，比如PostgreSQL（从9.0版本开始），MySQL，Oracle Data Guard和SQL Server等，当然也有一些非关系型数据库也支持此类功能，比如MongoDB等，不仅仅是数据库，像kafka（分区的多副本）和rabbitmq的队列为了实现高可用，也实现了主从复制功能，甚至一些存储设备本身也具有复制机制。</p><h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>复制中一个重要的细节是<strong>同步复制</strong>还是<strong>异步复制</strong>，同步复制拥有更强的数据一致性保证，如果主库失效可以保证能在从库中找到对应数据；但是缺点也很突出，那就是从库会拖慢复制性能，如果从库故障或者网络原因，主库无法处理请求直到从库或者网络正常为止。在多从库场景中，针对网络异常或者单个从库故障的异常场景，可以使用quorum机制来保证大多数节点复制OK即可（比如zookeeper的主从同步机制），或者广播复制只要有一个从库复制OK即可（比如MySQL的半同步机制）。</p><p>异步复制拥有更好的性能保证，异步不影响请求的处理，主节点请求处理之后可以继续处理下一个请求，但是异步复制由于是最终一致性的体现，所以存在一定的数据不一致时期。如果主库失效，所有尚未同步给从库的数据会丢失。大多数场景下使用异步复制策略就能满足业务场景，如果业务对数据一致性有较高的要求，可以使用同步复制机制或者将请求发给主节点处理。</p><h3 id="新从库"><a href="#新从库" class="headerlink" title="新从库"></a>新从库</h3><p>有时候需要替换故障从库或者新增从库，如何确保新从库和主库数据一致呢？简单的从主节点快照数据复制到新从库是不行的，因为数据始终可能发生更新；锁定主库然后进行快照复制也不值得推荐，因此这违背了高可用原则。启动新从库，理论上可以做到不停机，过程如下：</p><ol><li>某个时刻获取主库快照，大多数数据库都具备该功能；</li><li>将快照复制到新从库节点并应用；</li><li>从库连接到主库，开始拉取快照触发之后发生变更的数据，这要求快照与主库复制日志中的位置可以精确关联，比如MySQL中的⼆进制⽇志坐标（binlog coordinates）；</li><li>当从库追上主库之后，二者达到一致状态，可以继续处理后续数据变更了。</li></ol><blockquote><p>并不是所有场景都能不停机起新从库，比如升级从库时有的数据库复制协议不能向后兼容，还有分区扩容场景下的复制等。</p></blockquote><h3 id="复制日志"><a href="#复制日志" class="headerlink" title="复制日志"></a>复制日志</h3><p>主从复制底层由以下几种实现方案，比如基于语句、基于WAL（预写日志）、基于行日志和基于触发器等，不同方案有不同的优缺点，下面简要分析下：</p><ul><li><strong>基于语句</strong>：最简单的同步方式，主库将每个更新语句（udpate/delete/create）都转发给从库，从库解析之后应用到本地，这种方式看上去很合理，不过如果sql中包含非确定值函数的语句，则会造成主从库不一致，比如NOW()获取当前时间；</li><li><strong>基于WAL</strong>：数据库的数据故障恢复能力，一般都是基于预写日志实现，因为直接写到数据页或索引中相当于随机写，而预写日志是追加方式的顺序写，性能较高；PostgreSQL和Oracle等使⽤这种复制⽅法，主要缺点是⽇志记录的数据⾮常底层：WAL包含哪些磁盘块中的哪些字节发⽣了更改（比如Mysql redo日志），这使复制与存储引擎紧密耦合。如果数据库将其存储格式从⼀个版本更改为另⼀个版本，通常不可能在主库和从库上运⾏不同版本的数据库软件；</li><li><strong>基于行日志</strong>：也称为逻辑日志，关系型数据库通常是基于行粒度来描述数据的写入序列，对于插入的行，行日志包含所有列的值；对于更新操作，行日志包含列更新前后的值，MySQL的binlog日志就是基于这种方式实现的（statement模式下）；</li><li><strong>基于触发器</strong>：上面几种复制策略都是数据库本身提供的机制，而基于触发器机制涉及到应用程序代码，当数据有更新操作时触发对应的用户程序进行对应的复制逻辑。</li></ul><h3 id="复制延时问题"><a href="#复制延时问题" class="headerlink" title="复制延时问题"></a>复制延时问题</h3><p>异步复制模式下存在复制延时问题，当网络异常或者服务异常时延时问题更严重，有的业务对数据延时容忍度较大，比如用户信息更新对于其他用户可见来说，延时一定时间无所谓。在读写分离场景中，如果读都是走从库并且存在延时较长时，会出现用户刚更新完信息查看信息还是老的，好像刚才更新的数据丢失了，也就是说 <strong>⽤户写⼊后从旧副本中读取数据，这种情况需要读写一致性来保证</strong>。这是⼀个保证，如果⽤户重新加载⻚⾯，他们总会看到他们⾃⼰提交的任何更新。它不会对其他⽤户的写⼊做出承诺：其他⽤户的更新可能稍等才会看到。它保证⽤户⾃⼰的输⼊已被正确保存。</p><p>在主从复制场景中，应该如何实现读写一致性呢？首先可以明确的是，在可能存在复制延时场景中需要从主库读取数据，比如当前用户查看更新自己的信息都走主库，或者用户更新完成之后读取数据都走主库等。如果是公共信息（多个用户可以同时编辑）的更新操作，可以在客户端增加更新时间戳，在时间戳最近一定时间内的所有读取操作都走主库。</p><h2 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h2><p>主从复制要求更新操作都走主库，如果客户端无法连接到主库则不能进行更新，而基于多主复制的策略中，允许多个节点接收写入操作。复制仍然以同样的⽅式发⽣：处理写⼊的每个节点都必须将该数据更改转发给所有其他节点， 称之为多领导者配置（也称多主、多活复制，比如多机房的异地多活）。在这种情况下，每个领导者同时扮演其他领导者的追随者。</p><h3 id="多主复制场景"><a href="#多主复制场景" class="headerlink" title="多主复制场景"></a>多主复制场景</h3><p>比较常见的多主复制场景是多数据中心，要求每个数据中心都有一个主库，每个数据中心内部使用主从同步，数据中心之间是多主复制，也就是一个数据中心的主库会复制其他数据中心主库的数据，多数据中心的多主复制如下图：</p><p><img src="/2020/04/06/gao-ke-yong-de-ben-zhi-fu-zhi/./高可用的本质-复制/image-20191229224449389.png" alt><br>多数据中心对于公司服务运维能力要求较高，一般只有较大公司才玩的转，毕竟是有一定成本的。多数据中心对于服务来说，需要进行挺大的改造的，比如主键ID就需要接入分布式ID方案，不能采用单机数据库的ID自增方案；多数据中心的多主复制方案可以容忍数据中心停机而不中断服务，大大提高公司对外服务高可用性。</p><h3 id="写入冲突"><a href="#写入冲突" class="headerlink" title="写入冲突"></a>写入冲突</h3><p>讨论多数据中心的写入冲突之前，先看下协同编辑场景中存在的写入冲突问题，协同编辑比如google docs允许多人同时对一个文件进行编辑操作，为了解决冲突，可以采取用户在编辑前锁定文档，然后编辑之后另一个用户才能编辑，但是这种方案锁粒度太大，因此可以使用更小粒度的方案，比如针对文档中的一个单元格进行锁定操作。</p><p>多领导者复制的最⼤问题是可能发⽣写冲突，这意味着需要解决冲突，常见的冲突解决可以采用版本思想，比如按照最新时间戳，最大版本号等，但是这种方案可能导致数据覆盖丢失问题；除了版本思路之外，还可以保留冲突数据，当用户再次查看数据时，让用户选择使用哪一个冲突版本的数据，比如git的merge冲突等。</p><h2 id="无主复制"><a href="#无主复制" class="headerlink" title="无主复制"></a>无主复制</h2><p>⼀些数据存储系统采⽤不同的⽅法，放弃主库的概念，并允许任何副本直接接受来⾃客户端的写⼊。由于无主复制没有主库概念，但是也要保证多副本机制，因此需要在客户端向多个从节点进行写操作，比如bookkeeper的写入策略，就是客户端并发些，只要收到大多数数据节点的ack就认为此次数据写入成功，这样就能保证数据的“一致性”。</p><h2 id="快照技术"><a href="#快照技术" class="headerlink" title="快照技术"></a>快照技术</h2><p>快照技术就是将当前数据状态存储到文件，便于存档，当故障发生时可以使用最近一次的快照恢复数据，由于快照执行一次的成本相对较大，但是为了保证快照数据具有实时性，因此会折中在多少次更新操作或者多长时间后触发一次快照操作，比如Redis会默认当900s内有一次更新操作，或者300s内有10次更新操作，或者60s内有10000次更新操作，就会触发RDB持久化（Redis数据快照）。常说的快照技术也就是全量数据保存，还有一种是增量数据保存，比如Redis中的AOF持久化策略。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>俗话说，要想提高可用性就进行一次复制操作；如果再想提高可用性，那就再复制一次。复制的本质是冗余数据，提高可用性，注意，复制也不是冗余越多越好，毕竟越多网络开销更大，从而影响整体服务性能，需要根据特定场景特定考虑，一般针对数据来说，冗余3份即可。</p><p>复制可分为同步复制和异步复制两种模式，一般来说前者有较高的数据一致性保证，后者有更好的性能保证。复制策略常见的有主从同步、多主同步和无主复制等，主从同步模式容易理解，无主复制需要应用程序多做一些额外的操作保证数据一致性。快照技术也是一种复制模式，常见于本地数据的归档保存，比如于故障恢复场景。复制是为了解决高可用问题，如果数据量更大，往往会使用分区+复制的策略来保证高性能和高可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>页式内存管理</title>
      <link href="/2020/03/31/ye-shi-nei-cun-guan-li/"/>
      <url>/2020/03/31/ye-shi-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>操作系统中两个重要的概念是CPU和内存，CPU管理相对来说比较”直男”一点，只顾着执行指令，最多忙到100%或者超频执行；但对于内存来说，它是资源有限的，如果进程占用内存较大甚至大于物理内存，并且要同时执行多个进程，这就涉及到内存管理。</p><p>理想情况下用户对内存的期待是大容量、高速度和持久性，但是现实中却是一个由缓存、主存、磁盘组成的内存架构，该架构中，缓存低容量、速度快但是成本高，主存中速度、中容量和中成本，磁盘就是大容量、持久性但是速度慢。</p><p>内存管理就是要对”用户”提供一个统一的抽象，屏蔽缓存、主存和磁盘之间的差异，甚至感知不到它们的存在。用户无需担心程序是存储在缓存、主存或者磁盘上，反正运行、输出的结果都是一样的，这种抽象就是通过虚拟内存来实现的。</p><p>操作系统中要同时执行多个进程程序，要保证它们之间互不干扰，也就是说一个进程不能访问另一个进程的内存空间。程序中读写特定内存数据时，不能直接映射到物理内存，也就是说程序发出的内存地址和物理内存要是独立的。综上所述，内存管理的目标就是：</p><ul><li><strong>地址保护</strong>：一个程序不能访问另一个程序地址空间。</li><li><strong>地址独立</strong>：程序发出的地址应与物理主存地址无关。</li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是操作系统发展史上一个重要的里程碑，虚拟内存的使用，避免程序直接和主存（物理内存）打交道，并且对缓存、主存和磁盘做了统一抽象，这样程序就可以突破物理内存的大小限制，当然程序还是要受制于虚拟内存的大小限制的。</p><p>应用程序、虚拟内存和物理内存的关系如下：<br><img src="/2020/03/31/ye-shi-nei-cun-guan-li/./页式内存管理/20200328220306478_388886772.png" alt></p><p>程序中看到的内存地址是虚拟内存地址，程序读写内存时会被映射到实际的物理内存中，这个映射称为翻译，这个翻译工作是由MMU（内存管理单元）来完成，MMU接收CPU发出的虚拟地址，将其翻译为物理地址后发送给内存，内存按照该物理地址进行相应访问后读出或写入相关数据。</p><h2 id="分页内存"><a href="#分页内存" class="headerlink" title="分页内存"></a>分页内存</h2><p>分页系统的核心是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。</p><p>只是简单说说可能体现不出来分页管理的优势，让我们思考下，除了分页管理之外，简单的内存管理该如何做呢？很容易想到的是分配和程序所需内存同样大小的虚拟/物理内存，也就是基址极限管理，限定内存开始结束位置，随着应用的执行，如果程序还需要更多空间，可以先swap到磁盘，再找一个大的连续空间然后再swap回内存，如果找不到就尴尬了，程序就stop the world了。这样看起来也是一个方案，但是存在一个问题是，这样分配内存的粒度太大，容易造成内存碎片，并且多个内存碎片加在一起可以满足程序使用时也不能直接使用。</p><p>可能有的小伙伴会想，那就进行内存碎片整理，通过移动进程在内存里面的位置将空闲空间连成一片。但是这种操作需要将进程swap到磁盘上，再重新加载，效率十分低下。在进行碎片整理的过程中，系统的响应延迟将显著增加，这种方案不太可取。</p><h3 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h3><p>在分页系统下，一个程序发出的虚拟地址由两部分组成：页面号和页内偏移值。为了解决程序比内存大的问题，我们可以允许一个进程的部分虚拟页面存放在物理页面之外，也就是磁盘上。在需要访问这些外部虚拟页面时，再将其调入物理内存，需要腾出空间时，将暂时不同的内存swap到磁盘。</p><p>分页管理对于任一虚拟页面，系统知道该页面是否在物理内存中，如果在的话，其对应的物理页面是哪个；如果不在的话，则产生一个系统中断（缺页中断），并将该虚页从磁盘转到内存，然后将分配给它的物理页面号返回，这个过程也就是前面说到的地址翻译：<br><img src="/2020/03/31/ye-shi-nei-cun-guan-li/./页式内存管理/20200328222936686_1405412998.png" alt></p><blockquote><p>注意：地址翻译只是针对页面号的翻译，即虚拟地址页和物理地址页的映射关系翻译，因为二者一一对应，页内偏移量无需翻译。</p></blockquote><p>内存页的翻译是通过查表进行的，系统对于每个进程都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。每当为一个虚拟页面寻找到一个物理页面后，就在页表里面增加一个记录来保留该虚拟页面到物理页面的映射关系，随着虚拟页面进出物理内存，页表的内容页不断发生变化。</p><p>进程发出一个虚拟地址给内存管理单元后，内存管理单元首先将地址里面页号部分的字位分离出来，然后判断该虚拟页面是否有效，是否存放在内存，是否受到保护。如果页面无效，即该虚拟页面不存在或没有在内存，也就是说该虚拟页面在物理内存里面没有对应。如果该页面受到保护，即对该页面的访问被禁止，则产生一个系统中断来处理这些特殊情况。对于无效页面访问，需要终止发出该无效访问的进程。对于合法但不在物理内存中的页面，我们通过缺页中断将该虚拟页面放进物理内存。对于受保护的页面，同样终止该进程。判断页是否合法的信息也是存在页面中的，如果页面合法，则通过页表找对对应物理页号。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表的根本功能是提供从虚拟页面到物理页面的映射，因此其地位十分关键，内存管理单元依赖页表来进行一切与页面有关的管理活动。这些活动包括判断某一页面号是否在内存里，页面是否受到保护，页面是否非法空间等。由于页表的特殊地位（使用非常频繁），因此只能由硬件来实现，也即是说它是一个硬件数据结构。<br><img src="/2020/03/31/ye-shi-nei-cun-guan-li/./页式内存管理/20200328223645442_603624033.png" alt></p><p>对于32位寻址的虚拟地址，如果页面大小为4KB，则虚拟页面数最多可以达到2的20次方，即1048576个虚拟页面，那么页表的记录条数就为1048576条。这样就占用较多空间，如何减少页表空间呢？这时可以使用多级页，表页表根据存放的内容可分为：顶级页表、一级页表、二级页表、三级页表等。顶级页表里面存放的是一级页表的信息，一级页表里面存放的是二级页表的信息，以此类推，到最后一级页表存放的才是虚拟页面到物理页面的映射，就和MySQL中非聚集索引和聚集索引的关系类似。二级页面结构如下：<br><img src="/2020/03/31/ye-shi-nei-cun-guan-li/./页式内存管理/20200328224838668_396374203.png" alt></p><h3 id="页表快速翻译"><a href="#页表快速翻译" class="headerlink" title="页表快速翻译"></a>页表快速翻译</h3><p>地址翻译因增加了内存访问次数而降低了系统效率。如果只使用单级页表，则每次内存访问变为两次内存访问，速度的下降还尚可以忍受。但如果使用多级页表或反转页表，则每次内存访问将变为多于两次的内存访问，这样效率的下降将非常明显。我们都知道，程序的执行有时空局限性，即在一段时间内，程序所要访问的地址空间有一定的空间局域性。如果一个页面被访问，则该页面的其他地址可能也将被随后访问。这样，我们可以将该页面的翻译结果存放在缓存里，而无须在访问该页面的每个地址时再翻译一次。这样就可以大大提高系统的执行效率。</p><p>这种存放翻译结果的缓存称为<strong>翻译快表（Translation Look-Aside Buffer,TLB）</strong>。TLB里面存放的是从虚拟页面到物理页面的映射，其记录的格式与内容和正常页表的记录格式与内容一样：<br><img src="/2020/03/31/ye-shi-nei-cun-guan-li/./页式内存管理/20200328225436715_366956827.png" alt></p><p>TLB是线性表结构，那么它的时间复杂度是多少呢？O(1)，是不是不可思议？解决方案就是使用硬件，TLB的比较不是顺序执行的，而是一次性比较其中所有数据，因此只需要一次查找就能确定一个虚拟页面号是否在TLB里。这种设计需要同时配备多套比较电路，比较电路的套数需与TLB的大小一样。这也就是为什么TLB非常昂贵。</p><p>显然，采用多级页表的分页系统的效率将取决于TLB的命中率。如果命中率很高，则系统效率高；如果命中率低，则系统效率低。例如，Linux使用的是三级页表，按照常理来说，这将使得系统的执行效率大大降低，但许多人并没有感觉到Linux特别慢，这就是因为Linux的TLB命中率高，据称其命中率达98%。</p><p><strong>参考资料</strong>：</p><p>1、《操作系统之设计哲学》</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>group by中子查询order by排序失效问题分析</title>
      <link href="/2020/03/17/group-by-zhong-zi-cha-xun-order-by-pai-xu-shi-xiao-wen-ti-fen-xi/"/>
      <url>/2020/03/17/group-by-zhong-zi-cha-xun-order-by-pai-xu-shi-xiao-wen-ti-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过sql分组查询数据时，一般通过group by来完成，group by默认取相同的分组列(一列或者多列)中第一个数据。</p></blockquote><p>如果想获取sql分组中id最大的记录，我们可能想到的sql如下（name列作为分组）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> tt <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure><p>不过执行该sql发现并不能达到我们的目的，输出数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 表数据如下：</span><br><span class="line">id,name</span><br><span class="line">1,name1</span><br><span class="line">2,name1</span><br><span class="line">3,name2</span><br><span class="line">4,name2</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> tt <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br><span class="line">// 输出结果如下：</span><br><span class="line"><span class="keyword">id</span>,<span class="keyword">name</span></span><br><span class="line"><span class="number">1</span>,name1</span><br><span class="line"><span class="number">3</span>,name2</span><br></pre></td></tr></table></figure><p>这是为什么呢？<strong>因为mysql 5.6之后版本对排序的sql解析做了优化，子查询中的排序是会被忽略的，所以上面的order by id desc未起到作用。</strong>如果子语句中排序不做优化那不就可以了么，查阅资料发现可以在子语句中加上limit来避免这种优化（加上limit相当于临时表限定了取值范围不会进行优化，如果是全表的话就被优化掉了）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 加上limit</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> tt <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1024</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">// 输出结果如下：</span><br><span class="line"><span class="keyword">id</span>,<span class="keyword">name</span></span><br><span class="line"><span class="number">2</span>,name1</span><br><span class="line"><span class="number">4</span>,name2</span><br></pre></td></tr></table></figure><p>除了上述这种直接通过group by分组得到id最大记录之外，还可以通过分组获取到最大记录id，然后通过id获取对应记录（这里的id只要是记录的关键key即可）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过分组获取关键key，然后再获取对应记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> tt <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> tt <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)</span><br><span class="line"></span><br><span class="line">// 输出结果如下：</span><br><span class="line"><span class="keyword">id</span>,<span class="keyword">name</span></span><br><span class="line"><span class="number">2</span>,name1</span><br><span class="line"><span class="number">4</span>,name2</span><br></pre></td></tr></table></figure><p>其实除了group by获取分组最后一个记录之外，还可以通过关联子查询方式来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> tt a <span class="keyword">where</span> <span class="keyword">id</span> = (<span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> tt <span class="keyword">where</span> <span class="keyword">name</span> = a.name) <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">// 输出结果如下</span><br><span class="line"><span class="keyword">id</span>,<span class="keyword">name</span></span><br><span class="line"><span class="number">2</span>,name1</span><br><span class="line"><span class="number">4</span>,name2</span><br></pre></td></tr></table></figure><p>通过以上group by和关联子查询两种方式的实现，获取分组的最后一条记录要么直接通过分组直接来获取，要么先获取到记录关键key然后通过关键key获取对应的记录即可。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transmittable-Thread-Local：线程间上下文传递解决方案</title>
      <link href="/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/"/>
      <url>/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TTL（transmittable-thread-local）是一个线程间传递ThreadLocal，异步执行时上下文传递的解决方案。整个库的核心是构建在TransmittableThreadLocal类（继承并加强InheritableThreadLocal类）之上，同时包含线程池修饰（ExecutorService/ForkJoinPool/TimerTask）以及Java Agent支持，代码小于1k行，短小精悍。</p></blockquote><p>在往下看之前，最好大致看下 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a> 文档，效果会更好。JDK的InheritableThreadLocal类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时的ThreadLocal值传递</strong>到 <strong>任务执行时</strong>。原理是使用TtlRunnable/Ttlcallable包装了Runnable/Callable类：</p><ol><li>在TtlRunnable/Ttlcallable初始化时<strong>capture</strong> TransmittableThreadLocal变量</li><li>在run方法调用runnable.run()前进行<strong>replay</strong>，设置到当前线程ThreadLocal</li><li>在run方法调用runnable.run()后进行<strong>restore</strong>，上下文还原，也就是replay的反向操作</li></ol><p>注意，步骤1和步骤2/3不是在同一个线程中执行的。</p><p>既然TTL的TransmittableThreadLocal是继承并加强InheritableThreadLocal类的，那么首先需要分析下InheritableThreadLocal是什么东东，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建线程时，如果当前inheritableThreadLocals非空，则会获取当前inheritableThreadLocals传递给新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal变量的set/get/remove操作都是在inheritableThreadLocals上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建inheritableThreadLocals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类中有两个ThreadLocal相关的ThreadLocalMap属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals：ThreadLocal变量使用</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals：InheritableThreadLocal变量使用</span><br></pre></td></tr></table></figure><p>新建线程时，将当前线程的inheritableThreadLocals传递给新线程，这里的传递是对InheritableThreadLocal变量的数据做浅拷贝（引用复制），这样新线程可以使用同一个InheritableThreadLocal变量查看上一个线程的数据。</p><p>下面分析下使用InheritableThreadLocal的一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: value-set-in-parent</span></span><br></pre></td></tr></table></figure><p>上面代码在submit任务时会伴随着（线程池工作）线程的创建，会继承当前线程的InheritableThreadLocal，所以会有上述输出结果。如果将代码改成下面的样子，会有什么不同呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; &#123;&#125;); <span class="comment">// 先进行工作线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line">    executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: null</span></span><br></pre></td></tr></table></figure><p>因为创建线程时当前线程并没有inheritableThreadLocals，所以线程池中线程打印结果为null。这种场景下如何才能获取到parent变量的数据呢？这时就该TTL出场了，将上述代码改成TTL方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testTtlInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; &#123;&#125;); <span class="comment">// 先进行工作线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用TTL</span></span><br><span class="line">    <span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line">    <span class="comment">// 将Runnable通过TtlRunnable包装下</span></span><br><span class="line">    executor.submit(TtlRunnable.get(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: value-set-in-parent</span></span><br></pre></td></tr></table></figure><p>下面以TtlRunnable.get()为起点分析TTL的设计实现，TtlRunnable.get源码如下（TtlRunnable.get流程对应的初始化时<strong>capture</strong>操作，保存快照。TtlCallable和TtlRunnable流程类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title">get</span><span class="params">(@Nullable Runnable runnable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(runnable, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title">get</span><span class="params">(@Nullable Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun, <span class="keyword">boolean</span> idempotent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (runnable <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line"><span class="comment">// 幂等时直接返回，否则执行会产生问题，直接抛异常</span></span><br><span class="line"><span class="keyword">if</span> (idempotent) <span class="keyword">return</span> (TtlRunnable) runnable;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already TtlRunnable!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TtlRunnable(runnable, releaseTtlValueReferenceAfterRun);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(@Nonnull Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());</span><br><span class="line"><span class="keyword">this</span>.runnable = runnable;</span><br><span class="line"><span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="comment">// 从holder获取所有threadLocal，存到captured，这里相当于对当前线程holder做一个快照保存</span></span><br><span class="line"><span class="comment">// 到TtlRunnable实例属性中，在执行TtlRunnable时进行回放</span></span><br><span class="line"><span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">captured.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> captured;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新建TtlRunnable过程中，会保存下TransmittableThreadLocal.holder到captured，记录到TtlRunnable实例中的capturedRef字段，TransmittableThreadLocal.holder类型是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note about holder:</span></span><br><span class="line"><span class="comment">// 1. The value of holder is type Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; (WeakHashMap implementation),</span></span><br><span class="line"><span class="comment">//    but it is used as *set*. 因为没有WeakSet的原因</span></span><br><span class="line"><span class="comment">// 2. WeakHashMap support null value.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">        <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>从上面代码我们知道初始化TtlRunnable时已经将TransmittableThreadLocal保存下来了，那么什么时候应用到当前线程ThreadLocal中呢，这是就需要看下TtlRunnable.run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object captured = capturedRef.get();</span><br><span class="line">    <span class="comment">// captured不应该为空，releaseTtlValueReferenceAfterRun为true时设置capturedRef为null，防止当前Runnable重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"TTL value reference is released after run!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// captured进行回放，应用到当前线程中</span></span><br><span class="line">    Object backup = replay(captured);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restore(backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，TTL中的replay操作是以captured为当前inheritableThreadLocals的（处理逻辑是在TtlRunable run时，会以TtlRunnable.get时间点获取的captured（类似TTL快照）为准，holder中不在captured的先移除，在的会被替换）。关于replay中的clean extra TTL value讨论可以参考：<a href="https://github.com/alibaba/transmittable-thread-local/issues/134。回放captured和执行完runnable.run之后，再restore恢复到原来inheritableThreadLocals的状态。" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local/issues/134。回放captured和执行完runnable.run之后，再restore恢复到原来inheritableThreadLocals的状态。</a></p><p>说完了TTL中的capture、replay和restore流程，再看下官方提供的这个时序图，是不是感觉清晰很多。</p><p><img src="/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/./transmittable-thread-local：线程间上下文传递解决方案/image-20200315174314526.png" alt="image-20200315174314526"></p><p>除了通过TtlRunable.get()修饰用户自定义的task之外，还可以修饰线程池和使用Java Agent修饰JDK线程池实现类的方式实现TTL功能。</p><p>修饰线程池省去每次Runnable和Callable传入线程池时的修饰，这个逻辑可以在线程池中完成，其实就是在提交task时调用TtlRunable.get()修饰下。通过工具类com.alibaba.ttl.threadpool.TtlExecutors完成，有下面的方法：</p><ul><li>getTtlExecutor：修饰接口Executor</li><li>getTtlExecutorService：修饰接口ExecutorService</li><li>getTtlScheduledExecutorService：修饰接口ScheduledExecutorService</li></ul><p>使用Java Agent来修饰JDK线程池实现类，这种方式，实现线程池的传递是透明的，代码中没有修饰Runnable或是线程池的代码。即可以做到应用代码无侵入。关于 无侵入 的更多说明参见文档 <a href="https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md#java-agent方式对应用代码无侵入" target="_blank" rel="noopener">Java Agent方式对应用代码无侵入</a>。</p><p>使用Java Agent 实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动参数中需加上 -javaagent:path/transmittable-thread-local-x.x.x.jar</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><p>TTL代码实现来看，确实短小精悍，值得花几个小时看下源码。通过看源码，我发现了，可以通过new ThreadLocal对象时，直接重写其initialValue方法，可以在threadLocal.get为空时初始化一个值，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"init"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">local.set(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println(local.get()); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">local.remove();</span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池如何传递线程上下文信息</title>
      <link href="/2020/03/13/xian-cheng-chi-ru-he-chuan-di-xian-cheng-shang-xia-wen-xin-xi/"/>
      <url>/2020/03/13/xian-cheng-chi-ru-he-chuan-di-xian-cheng-shang-xia-wen-xin-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>业务开发中，一般都会使用ThreadLocal保存一些上下文信息，但是在线程池中执行对应逻辑时，由于是不同线程所以无法获取之前线程的上下文信息。</p></blockquote><p>线程池的线程上下文传递，实现方案就是在提交任务时记录当前线程上下文信息，在线程池中线程执行用户任务前将之前保存的上下文塞到当前线程的上下文中，在执行用户任务之后移除该上下文即可。简单来说就是，外部线程提交任务时要记录上下文信息，内部线程执行任务时获取之前记录的上下文信息设置到当前线程上下文中。</p><p>实现线程上下文传递的2种方式：</p><ul><li>一种是在用户任务中直接进行手动获取/设置上下文逻辑。</li><li>另一种是实现一个自定义的线程池，在提交任务时对任务进行包装并保存上下文信息，然后任务执行前设置上下文信息。</li></ul><p>两种实现方式的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; CONTEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorWrap = <span class="keyword">new</span> ThreadPoolExecutorWrap(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CONTEXT.set(<span class="string">"main context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：在用户任务中直接进行手动获取/设置上下文逻辑</span></span><br><span class="line">    executor.submit(<span class="keyword">new</span> RunnableWrap(() -&gt; System.out.println(<span class="string">"hello world: "</span> + CONTEXT.get())));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：自定义线程池，封装成支持保存/设置上下文的任务</span></span><br><span class="line">    executorWrap.submit(() -&gt; System.out.println(<span class="string">"hello world: "</span> + CONTEXT.get()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorWrap</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutorWrap</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(<span class="keyword">new</span> RunnableWrap(task), <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableWrap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String contextValue;</span><br><span class="line">    <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableWrap</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contextValue = CONTEXT.get();</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CONTEXT.set(contextValue);</span><br><span class="line">            <span class="comment">// 用户任务逻辑</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CONTEXT.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于线程间上下文传递，阿里给出了一个解决方案：TTL（transmittable-thread-local）是一个线程间传递ThreadLocal，异步执行时上下文传递的解决方案。整个库的核心是构建在TransmittableThreadLocal类（继承并加强InheritableThreadLocal类）之上，同时包含线程池修饰（ExecutorService/ForkJoinPool/TimerTask）以及Java Agent支持，代码小于1k行，短小精悍。</p><p>我们都知道，JDK的InheritableThreadLocal类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时的ThreadLocal值传递</strong>到 <strong>任务执行时</strong>。原理是使用TtlRunnable/Ttlcallable包装了Runnable/Callable类：</p><ol><li>在TtlRunnable/Ttlcallable初始化时<strong>capture</strong> TransmittableThreadLocal变量</li><li>在run方法调用runnable.run()前进行<strong>replay</strong>，设置到当前线程ThreadLocal</li><li>在run方法调用runnable.run()后进行<strong>restore</strong>，上下文还原，也就是replay的反向操作</li></ol><p>注意，步骤1和步骤2/3不是在同一个线程中执行的，这个流程和本文最初说的实现方案是一致的。</p><p>TTL的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testTtlInheritableThreadLocal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; &#123;&#125;); <span class="comment">// 先进行工作线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用TTL</span></span><br><span class="line">    <span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line">    <span class="comment">// 将Runnable通过TtlRunnable包装下</span></span><br><span class="line">    executor.submit(TtlRunnable.get(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: value-set-in-parent</span></span><br></pre></td></tr></table></figure><p>TTL实现原理和文章开头说的实现线程上下文传递大致一致，感兴趣的小伙伴可以直接看下TTL源码（<a href="https://github.com/alibaba/transmittable-thread-local），这里不再赘述。" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local），这里不再赘述。</a></p><p>最后关于ThreadLocal再提一下，我们可以重写其initialValue方法，这样可以在threadLocal.get为空时初始化一个值，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"init"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">local.set(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println(local.get()); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">local.remove();</span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToString如何反序列化</title>
      <link href="/2020/03/08/tostring-ru-he-fan-xu-lie-hua/"/>
      <url>/2020/03/08/tostring-ru-he-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<p>不知道小伙伴们有没有这样的困扰，平常开发中写单测，要mock一个复杂的对象，并且也知道了该对象的toString格式数据（比如从日志中获取），但是该怎么构建这个对象呢？</p><blockquote><p>如果是json格式可以直接通过json反序列化得到对象，那么toString格式如何反序列得到对象呢？</p></blockquote><p>从反序列化原理来看，我们首先要解析出对象的一个个属性，toString对象属性格式为 <code>k1=v1,k2=v2</code> ，那么可以按照逗号 <code>,</code> 作为分隔符解析出一个个token，注意一个token可以是基本类型的kv，比如 <code>int/Interger/…/String</code> 这种；也可以是对象类型，比如 <code>object/array/list/map</code> 等。解析出来token之后，基本类型的token可以直接通过反射将v设置到对象属性（Field）中；对象类型的token可以继续按照toString格式进行反序列化，直到全部数据都反序列化成功为止；针对 <code>array/list/map</code> 的数据要获取到对应元素的实际类型才能知道要反序列化的对象。对应的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString格式反序列化类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxiangnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-03-02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * toString格式反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">toObject</span><span class="params">(Class&lt;T&gt; clazz, String toString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(clazz) || Objects.isNull(toString) || StringUtils.isEmpty(toString)) &#123;</span><br><span class="line">            return clazz == String.class ? (T) toString : null;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TypeValueUtils.isBasicType(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) TypeValueUtils.basicTypeValue(clazz, toString.trim());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toString = TokenUtils.cleanClassPrefix(clazz, toString.trim());</span><br><span class="line">        toString = StringUtils.removeStart(toString, <span class="string">"("</span>).trim();</span><br><span class="line">        toString = StringUtils.removeEnd(toString, <span class="string">")"</span>).trim();</span><br><span class="line"></span><br><span class="line">        String token = <span class="keyword">null</span>;</span><br><span class="line">        T result = clazz.newInstance();</span><br><span class="line">        <span class="keyword">while</span> (StringUtils.isNotEmpty(toString) &amp;&amp; StringUtils.isNotEmpty(token = TokenUtils.splitToken(toString))) &#123;</span><br><span class="line">            toString = StringUtils.removeStart(StringUtils.removeStart(toString, token).trim(), <span class="string">","</span>).trim();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析k/v格式的属性名/值</span></span><br><span class="line">            Pair&lt;String, String&gt; keyValue = TokenUtils.parseToken(token);</span><br><span class="line">            Field field = FieldUtils.getField(clazz, keyValue.getKey(), <span class="keyword">true</span>);</span><br><span class="line">            Object value = TypeValueUtils.buildTypeValue(field, keyValue.getValue());</span><br><span class="line">            FieldUtils.writeField(field, result, value, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串解析类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 清除类名前缀字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> String <span class="title">cleanClassPrefix</span><span class="params">(Class clazz, String toString)</span> </span>&#123;</span><br><span class="line">            String simpleName = clazz.getSimpleName();</span><br><span class="line">            <span class="keyword">if</span> (clazz.getName().contains(<span class="string">"$"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 内部类需要按照内部类名字格式</span></span><br><span class="line">                String rowSimpleName = StringUtils.substringAfterLast(clazz.getName(), <span class="string">"."</span>);</span><br><span class="line">                simpleName = StringUtils.replace(rowSimpleName, <span class="string">"$"</span>, <span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> toString.startsWith(simpleName) ?</span><br><span class="line">                    StringUtils.removeStart(toString, simpleName).trim() : toString;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取第一个token，注意: toString不再包括最外层的()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Character, Character&gt; tokenMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            tokenMap.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">            tokenMap.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">            tokenMap.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> String <span class="title">splitToken</span><span class="params">(String toString)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(toString)) &#123;</span><br><span class="line">                <span class="keyword">return</span> toString;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> bracketNum = <span class="number">0</span>;</span><br><span class="line">            Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toString.length(); i++) &#123;</span><br><span class="line">                Character c = toString.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (tokenMap.containsValue(c)) &#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokenMap.containsKey(c) &amp;&amp; Objects.equals(stack.peek(), tokenMap.get(c))) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">','</span>) &amp;&amp; stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> toString.substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> toString;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"splitFirstToken error, bracketNum="</span> + bracketNum + <span class="string">", toString="</span> + toString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从token解析出字段名，及对应值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">parseToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> Objects.nonNull(token) &amp;&amp; token.contains(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = token.indexOf(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> javafx.util.Pair&lt;&gt;(token.substring(<span class="number">0</span>, pos), token.substring(pos + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象构建类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeValueUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> Set&lt;Class&gt; BASIC_TYPE = Stream.of(</span><br><span class="line">                <span class="keyword">char</span><span class="class">.<span class="keyword">class</span>, <span class="title">Character</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">boolean</span>.<span class="title">class</span>, <span class="title">Boolean</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">short</span>.<span class="title">class</span>, <span class="title">Short</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">int</span>.<span class="title">class</span>, <span class="title">Integer</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">float</span>.<span class="title">class</span>, <span class="title">Float</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">double</span>.<span class="title">class</span>, <span class="title">Double</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">long</span>.<span class="title">class</span>, <span class="title">Long</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">String</span>.<span class="title">class</span>).<span class="title">collect</span>(<span class="title">Collectors</span>.<span class="title">toSet</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Filed类型是否为基础类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBasicType</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> BASIC_TYPE.contains(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Object <span class="title">buildTypeValue</span><span class="params">(Field field, String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(value) || <span class="string">"null"</span>.equalsIgnoreCase(value)) &#123;</span><br><span class="line">                return field.getType() == String.class ? value : null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class clazz = field.getType();</span><br><span class="line">            <span class="keyword">if</span> (isBasicType(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> basicTypeValue(field.getGenericType(), value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.getGenericType() == Date<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"EEE MMM dd HH:mm:ss Z yyyy"</span>, <span class="keyword">new</span> Locale(<span class="string">"us"</span>)).parse(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isArray() || clazz.isAssignableFrom(Array<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> arrayTypeValue(field.getType().getComponentType(), value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAssignableFrom(List<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> listTypeValue(field, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAssignableFrom(Map<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mapTypeValue(field, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> toObject(clazz, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Object <span class="title">basicTypeValue</span><span class="params">(Type type, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (type == Character<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">char</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Boolean<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">short</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Short.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">float</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Float.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">double</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Double.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== <span class="keyword">long</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Long.valueOf(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"basicTypeValue error, type="</span> + type + <span class="string">", value="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Object <span class="title">listTypeValue</span><span class="params">(Field field, String fieldValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            fieldValue = StringUtils.removeStart(fieldValue, <span class="string">"["</span>).trim();</span><br><span class="line">            fieldValue = StringUtils.removeEnd(fieldValue, <span class="string">"]"</span>).trim();</span><br><span class="line"></span><br><span class="line">            String token;</span><br><span class="line">            List&lt;Object&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (StringUtils.isNotEmpty(fieldValue) &amp;&amp; StringUtils.isNotEmpty(token = TokenUtils.splitToken(fieldValue))) &#123;</span><br><span class="line">                fieldValue = StringUtils.removeStart(StringUtils.removeStart(fieldValue, token).trim(), <span class="string">","</span>).trim();</span><br><span class="line">                result.add(toObject((Class) ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[<span class="number">0</span>], token));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; T[] arrayTypeValue(Class&lt;?&gt; componentType, String fieldValue) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            fieldValue = StringUtils.removeStart(fieldValue, <span class="string">"["</span>).trim();</span><br><span class="line">            fieldValue = StringUtils.removeEnd(fieldValue, <span class="string">"]"</span>).trim();</span><br><span class="line"></span><br><span class="line">            String token;</span><br><span class="line">            T[] result = newArray(componentType, fieldValue);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; StringUtils.isNotEmpty(fieldValue) &amp;&amp; StringUtils.isNotEmpty(token = TokenUtils.splitToken(fieldValue)); i++) &#123;</span><br><span class="line">                fieldValue = StringUtils.removeStart(StringUtils.removeStart(fieldValue, token).trim(), <span class="string">","</span>).trim();</span><br><span class="line">                result[i] = (T) toObject(componentType, token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] newArray(Class&lt;?&gt; componentType, String fieldValue) &#123;</span><br><span class="line">            String token;</span><br><span class="line">            <span class="keyword">int</span> lengh = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (StringUtils.isNotEmpty(fieldValue) &amp;&amp; StringUtils.isNotEmpty(token = TokenUtils.splitToken(fieldValue))) &#123;</span><br><span class="line">                fieldValue = StringUtils.removeStart(StringUtils.removeStart(fieldValue, token).trim(), <span class="string">","</span>).trim();</span><br><span class="line">                lengh++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (T[]) Array.newInstance(componentType, lengh);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Map <span class="title">mapTypeValue</span><span class="params">(Field field, String toString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            toString = StringUtils.removeStart(toString, <span class="string">"&#123;"</span>).trim();</span><br><span class="line">            toString = StringUtils.removeEnd(toString, <span class="string">"&#125;"</span>).trim();</span><br><span class="line"></span><br><span class="line">            String token;</span><br><span class="line">            Map result = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">while</span> (StringUtils.isNotEmpty(token = TokenUtils.splitToken(toString))) &#123;</span><br><span class="line">                toString = StringUtils.removeStart(StringUtils.removeStart(toString, token).trim(), <span class="string">","</span>).trim();</span><br><span class="line">                <span class="keyword">assert</span> token.contains(<span class="string">"="</span>);</span><br><span class="line">                String fieldName = StringUtils.substringBefore(token, <span class="string">"="</span>).trim();</span><br><span class="line">                String fieldValue = StringUtils.substringAfter(token, <span class="string">"="</span>).trim();</span><br><span class="line"></span><br><span class="line">                result.put(basicTypeValue(((ParameterizedType) field.getGenericType()).getActualTypeArguments()[<span class="number">0</span>], fieldName),</span><br><span class="line">                        toObject((Class) ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[<span class="number">1</span>], fieldValue));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringUtilsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DemoBean demoBean = DemoBean.builder()</span><br><span class="line">                .c1(<span class="string">'c'</span>).c2(<span class="string">'d'</span>).s1((<span class="keyword">short</span>) <span class="number">1</span>).s2((<span class="keyword">short</span>) <span class="number">2</span>)</span><br><span class="line">                .i1(<span class="number">1</span>).i2(<span class="number">2</span>).l1(<span class="number">1L</span>).l2(<span class="number">2L</span>)</span><br><span class="line">                .f1(<span class="number">1.0F</span>).f2(<span class="number">2.0F</span>).d1(<span class="number">1.0</span>D).d2(<span class="number">2.0</span>D)</span><br><span class="line">                .ss1(<span class="string">""</span>).ss2(<span class="string">"null"</span>).date(<span class="keyword">new</span> Date())</span><br><span class="line">                .a(<span class="keyword">new</span> A()).aList(Arrays.asList(<span class="keyword">new</span> A(), <span class="keyword">new</span> A()))</span><br><span class="line">                .aArray((A[]) Arrays.asList(<span class="keyword">new</span> A(), <span class="keyword">new</span> A()).toArray())</span><br><span class="line">                .build();</span><br><span class="line">        &#123;</span><br><span class="line">            Map&lt;String, A&gt; aMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            aMap.put(<span class="string">"1"</span>, <span class="keyword">new</span> A());</span><br><span class="line">            aMap.put(<span class="string">"2"</span>, <span class="keyword">new</span> A());</span><br><span class="line">            aMap.put(<span class="string">"3"</span>, <span class="keyword">new</span> A());</span><br><span class="line">            demoBean.setAMap(aMap);</span><br><span class="line">        &#125;</span><br><span class="line">        String toString = demoBean.toString();</span><br><span class="line"></span><br><span class="line">        DemoBean demoBean2 = ToStringUtils.toObject(DemoBean<span class="class">.<span class="keyword">class</span>, <span class="title">toString</span>)</span>;</span><br><span class="line">        System.out.println(demoBean2);</span><br><span class="line">        Assert.assertEquals(toString, demoBean2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> c1;</span><br><span class="line">        <span class="keyword">private</span> Character c2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">short</span> s1;</span><br><span class="line">        <span class="keyword">private</span> Short s2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i1;</span><br><span class="line">        <span class="keyword">private</span> Integer i2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> l1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> l2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> f1;</span><br><span class="line">        <span class="keyword">private</span> Float f2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> d1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> d2;</span><br><span class="line">        <span class="keyword">private</span> String ss1;</span><br><span class="line">        <span class="keyword">private</span> String ss2;</span><br><span class="line">        <span class="keyword">private</span> String ss3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line">        <span class="keyword">private</span> List&lt;A&gt; aList;</span><br><span class="line">        <span class="keyword">private</span> A[] aArray;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, A&gt; aMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span> + num++;</span><br><span class="line">        <span class="keyword">private</span> Long l = <span class="number">22L</span> + num++;</span><br><span class="line">        <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + num++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToStringUtilsTest.DemoBean(c1=c, c2=d, s1=<span class="number">1</span>, s2=<span class="number">2</span>, i1=<span class="number">1</span>, i2=<span class="number">2</span>, l1=<span class="number">1</span>, l2=<span class="number">2</span>, f1=<span class="number">1.0</span>, f2=<span class="number">2.0</span>, d1=<span class="number">1.0</span>, d2=<span class="number">2.0</span>, ss1=, ss2=<span class="keyword">null</span>, ss3=<span class="keyword">null</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>, a=ToStringUtilsTest.A(i=<span class="number">12</span>, l=<span class="number">24</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>), aList=[ToStringUtilsTest.A(i=<span class="number">15</span>, l=<span class="number">27</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>), ToStringUtilsTest.A(i=<span class="number">18</span>, l=<span class="number">30</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>)], aArray=[ToStringUtilsTest.A(i=<span class="number">21</span>, l=<span class="number">33</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>), ToStringUtilsTest.A(i=<span class="number">24</span>, l=<span class="number">36</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>)], aMap=&#123;<span class="number">1</span>=ToStringUtilsTest.A(i=<span class="number">27</span>, l=<span class="number">39</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>), <span class="number">2</span>=ToStringUtilsTest.A(i=<span class="number">30</span>, l=<span class="number">42</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>), <span class="number">3</span>=ToStringUtilsTest.A(i=<span class="number">33</span>, l=<span class="number">45</span>, date=Sun Mar <span class="number">08</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">52</span> CST <span class="number">2020</span>)&#125;)</span><br></pre></td></tr></table></figure><p><code>ToStringUtils</code> 针对大部分场景的toString反序列化是OK的，但是针对map中key是对象类型这种场景还未支持，感兴趣的小伙伴可以自行按照上述代码进行扩展，源码地址为：<a href="https://github.com/luoxn28/code-toolbox/blob/master/java/src/main/java/com/github/nan/util/ToStringUtils.java。" target="_blank" rel="noopener">https://github.com/luoxn28/code-toolbox/blob/master/java/src/main/java/com/github/nan/util/ToStringUtils.java。</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发工具类</title>
      <link href="/2020/02/29/java-bing-fa-gong-ju-lei/"/>
      <url>/2020/02/29/java-bing-fa-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<p>Java并发工具类主要有CyclicBarrier、CountDownLatch、Semaphore和Exchanger，日常开发中经常使用的是CountDownLatch和Semaphore。下面就简单分析下这几个并发工具类：</p><h3 id="CyclicBarrier-内存屏障"><a href="#CyclicBarrier-内存屏障" class="headerlink" title="CyclicBarrier 内存屏障"></a>CyclicBarrier 内存屏障</h3><p>CyclicBarrier底层借助于一个count计数器和Lock/Condition实现内存内存屏障功能，在对count–时必须先获取到lock，如果count不为0，则调用condition.wait进行阻塞操作；直到当count为0时，执行barrierCommand(如果配置的话，执行barrierCommand的线程是刚好将count减到0的那个线程)，然后调用condition.signalAll唤醒所有等待的线程。</p><blockquote><p>CyclicBarrier可用于多线程同步、多线程计算最后合并计算结果的场景，比如分片计算最后使用CyclicBarrier统计最后的结果等。</p></blockquote><p>CyclicBarrier使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, </span><br><span class="line">            () -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": all is ok"</span>));</span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": start wait"</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": start ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(task, <span class="string">"thread1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(task, <span class="string">"thread2"</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch-计数器"><a href="#CountDownLatch-计数器" class="headerlink" title="CountDownLatch 计数器"></a>CountDownLatch 计数器</h3><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。CountDownLatch底层借助于AQS来实现功能，初始化一个CountDownLatch(n)时，相当于创建了一个state为n的AQS，当调用countDown()时会对AQS进行减一操作，如果state为0，则会对阻塞队列中所有线程进行唤醒操作。</p><p>CountDownLatch计数器必须大于等于0，等于0的时候调用await方法时不会阻塞当前线程，注意CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数的值。一个线程调用coundDown方法happen-before，另一个线程调用await方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": start countDown"</span>);</span><br><span class="line">            downLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": start ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(task, <span class="string">"thread1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(task, <span class="string">"thread2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    downLatch.await();</span><br><span class="line">    System.out.println(<span class="string">"main wait ok"</span>);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p>Semaphore用来控制同时访问特定资源的线程数量，它通过协调各个线程，保证合理的使用公共资源。Semaphore可用作流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p><p>Semaphore底层也是基于AQS，初始化Semaphore(n)相当于初始化一个state为n的AQS，调用acquire()时会对进行state - 1操作，如果结果大于0则CAS设置state为state-1，相当于获取到了信号量，否则进行阻塞操作（调用tryAcquire则不会阻塞线程）。调用release会对state进行++操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" acquire before"</span>);</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" acquire ok"</span>);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    executor.execute(task);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exchanger-线程间交换数据"><a href="#Exchanger-线程间交换数据" class="headerlink" title="Exchanger 线程间交换数据"></a>Exchanger 线程间交换数据</h3><p>Exchanger是一个用户线程间交换数据的工具类，它提供了一个同步点，在这个同步点上，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，他会一直等待第二个线程也执行exchange方法，当两个线程都达到同步点时，这两个线程交换数据，将本线程产生的数据传递给对方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = exchanger.exchange(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exchanger实现分析"><a href="#Exchanger实现分析" class="headerlink" title="Exchanger实现分析"></a>Exchanger实现分析</h4><p>Exchanger算法的核心是通过一个可交换数据的slot，以及一个可以带有数据item的参与者，slot是Node类型，Node定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">// Arena index</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">// Last recorded value of Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">// Number of CAS failures at current bound</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">// Pseudo-random for spins</span></span><br><span class="line">    Object item;            <span class="comment">// This thread's current item</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">// Item provided by releasing thread</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">// Set to this thread when parked, else null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个参与者都带有一个Participant，当调用exchange时，如果slot为空，则将自己携带的数据CAS设置到slot上，然后park自己；如果slot不为空，则表示已经有线程在slot里设置了数据，则读取Node.item字段，并将自己携带的数据设置到Node.match字段，然后唤醒之前设置数据的线程（之前阻塞的线程在唤醒后读取Node.match字段返回），然后返回数据即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起聊聊3个线程依次打印1、2、3的故事</title>
      <link href="/2020/02/19/yi-qi-liao-liao-3-ge-xian-cheng-yi-ci-da-yin-1-2-3-de-gu-shi/"/>
      <url>/2020/02/19/yi-qi-liao-liao-3-ge-xian-cheng-yi-ci-da-yin-1-2-3-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>3个线程依次打印1、2、3…这个问题，常常被作为面试题，题目如下：</p><blockquote><p>三个线程，一个线程负责打印1，4，7，……；第二个负责打印2，5，8，……，第三个负责打印3，6，9，……，要求在控制台中按顺序输出1，2，3，4，5，6……。</p></blockquote><p>这个题目肯定是要启动3个线程的，那怎么让这3个线程“协作”按顺序打印1、2、3呢？从大的方面来讲，这种“协作”可分为以下两种：</p><ul><li><strong>竞争型</strong>：每个线程都抢着去打印，如果发现不该自己打印，则准备下一轮抢。由于大家都是竞争的，因此需要用锁机制来保护。</li><li><strong>协同型</strong>：当前线程线程打印之后通知下一个线程去打印，这种需要确认好第一个线程打印时机。由于是协同型的因此可以不用锁机制来保护，但是需要一个通知机制。</li></ul><h3 id="竞争型打印"><a href="#竞争型打印" class="headerlink" title="竞争型打印"></a>竞争型打印</h3><p>多个线程竞争型打印，优势是代码简单易懂，劣势是线程争抢是CPU调度进行的，可能该某个线程打印时结果该线程迟迟未被CPU调度，结果其他线程被CPU调度到但是由于不能执行打印操作而继续争抢，造成CPU性能浪费。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将lock对象换成 Lock(ReentrantLock) 进行lock/unlock也是可以的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoTask</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (current &lt;= MAX) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((current &lt;= MAX) &amp;&amp; (current % <span class="number">3</span> == index)) &#123;</span><br><span class="line">                    System.out.println(current++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threadList = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoTask(<span class="number">0</span>)),</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoTask(<span class="number">1</span>)),</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> DemoTask(<span class="number">2</span>))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        threadList.forEach(Thread::start);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协同型打印"><a href="#协同型打印" class="headerlink" title="协同型打印"></a>协同型打印</h3><p>多个线程协同型打印，优势是各个线程使用“通知”机制进行协同分工，理论上执行效率较高，不过要使用对应的“通知”机制。关于如何“通知”，第一种是可使用Java对象的 <code>wait/notify</code> 或者Conditon对象的 <code>await/signal</code> ，第二种是以事件或者提交任务的方式（比如通过提交“待打印数字”这个任务给下一个线程）。</p><p>下面以第二种方式进行代码分析，比如当前线程通过submit给下一个线程一个“待打印数字”的任务，这样很容易想到使用只包含1个线程的线程池来实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程要等待线程打印完毕，使用CountDownLatch通知机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ExecutorService&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(current++);</span><br><span class="line">            threadList.get(current % threadList.size()).submit(<span class="keyword">new</span> DemoTask());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            threadList.add(Executors.newFixedThreadPool(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadList.get(<span class="number">0</span>).submit(<span class="keyword">new</span> DemoTask());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadList.forEach(ExecutorService::shutdown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之Pod那些事</title>
      <link href="/2020/02/08/kubernetes-zhi-pod-na-xie-shi/"/>
      <url>/2020/02/08/kubernetes-zhi-pod-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<p>Pod是kubernetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。kubernetes中其他大多数组件都是围绕着Pod来进行支撑和扩展Pod功能的，例如，用于管理Pod运行的StatefulSet和Deployment等控制器对象，用于暴露Pod应用的Service和Ingress对象，为Pod提供存储的PersistentVolume存储资源对象等。</p><h3 id="Pod资源基础"><a href="#Pod资源基础" class="headerlink" title="Pod资源基础"></a>Pod资源基础</h3><p>Pod对象是一组容器的集合，这些容器共享Network、UTS及IPC名称空间，因此具有相同的域名、主机名和网络接口，并可通过IPC直接通信。注意，一个Pod下的容器必须运行于同一节点上。现代容器技术建议一个容器只运行一个进程，该进程在容器中PID名称空间中的进程号为1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。若想在容器内运行多个进程，需要有一个类似Linux操作系统init进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这是由于容器间的隔离机制导致，k8s中的Pod资源抽象正式解决此类问题，Pod对象是一组容器的集合，这些容器共享Network、UTS及IPC名称空间，因此具有相同的域名、主机名和网络接口，并可通过IPC直接通信。</p><p>Pod资源中针对各容器提供网络名称空间等共享机制的是底层基础容器pause，基础容器（也可称为父容器）pause就是为了管理Pod容器间的共享操作，这个父容器需要能够准确地知道如何去创建共享运行环境的容器，还能管理这些容器的生命周期。为了实现这个父容器的构想，kubernetes中，用pause容器来作为一个pod中所有容器的父容器。这个pause容器有两个核心的功能，一是它提供整个pod的Linux命名空间的基础。二来启用PID命名空间，它在每个pod中都作为PID为1进程，并回收僵尸进程。如下图：</p><p><img src="/2020/02/08/kubernetes-zhi-pod-na-xie-shi/./kubernetes之Pod那些事/image-20200208225429794.png" alt="image-20200208225429794"></p><blockquote><p>虽然Pod可以包含多个容器，但是一般都是单个容器或者具有强关联互补的多个容器组成一个Pod，比如后端服务+sideCar这种组合组成Pod对象。</p></blockquote><h3 id="Pod管理"><a href="#Pod管理" class="headerlink" title="Pod管理"></a>Pod管理</h3><p>Pod的核心是运行容器，必须指定容器引擎，比如Docker，启动容器时，需要获取镜像，k8s的镜像获取策略可以由用户指定，比如，Always：镜像标签为“latest”或镜像不存在时总是从指定的仓库中获取镜像；IfNotPresent：仅当本地缺失时才从仓库中获取；Never：仅使用本地镜像。注意：对于标签为“latest”的镜像文件，其默认的镜像获取策略即为“Always”，而对于其他标签的镜像，其默认策略则为“IfNotPresent”。</p><p>标签选择器用于表达标签的查询条件或选择标准，k8s目前支持两种选择器：等值选择和基于集合关系。例如，env=production和env!=qa是基于等值关系的选择器，而tier in (frontend, backend)则是基于集合关系的选择器。标签赋予了Kubernetes灵活操作资源对象的能力，它也是Service和Deployment等核心资源类型得以实现的基本前提。</p><blockquote><p>除了标签（label）之外，Pod与其他各种资源还能使用资源注解（annotation）。与标签类似，注解也是“键值”类型的数据，不过它不能用于标签选择Kubernetes对象，仅可用于为资源提供“元数据”信息。另外，注解中的元数据不受字符数量的限制，它可大可小，可以为结构化或非结构化形式，也支持使用在标签中禁止使用的其他字符。资源注解可由用户手动添加，也可由工具程序自动附加并使用它们，比如容器应用程序使用的启动参数或者配置。</p></blockquote><h3 id="节点选择器nodeSelector"><a href="#节点选择器nodeSelector" class="headerlink" title="节点选择器nodeSelector"></a>节点选择器nodeSelector</h3><p>节点选择器是标签及标签选择器的一种应用，它能够让Pod对象基于集群中工作节点的标签来挑选倾向运行的目标节点。Kubernetes的kube-scheduler守护进程负责在各工作节点中基于系统资源的可用性等标签挑选一个来运行待创建的Pod对象，默认的调度器是default-scheduler。</p><blockquote><p>Kubernetes可将所有工作节点上的各系统资源抽象成资源池统一分配使用，因此用户无须关心Pod对象的具体运行位置也能良好工作。不过，事情总有例外，比如仅有部分节点拥有被Pod对象依赖到的特殊硬件设备的情况，如GPU和SSD等。即便如此，用户也不应该静态指定Pod对象的运行位置，而是让scheduler基于标签和标签选择器及对应的Pod资源调度策略来为Pod挑选匹配的工作节点。</p></blockquote><h3 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h3><p>Pod是Kubernetes的基础单元，Pod启动典型创建过程如下：</p><p><img src="/2020/02/08/kubernetes-zhi-pod-na-xie-shi/./kubernetes之Pod那些事/image-20200208225749387.png" alt="image-20200208225749387"></p><ul><li>1）用户通过kubectl或其他API客户端提交Pod Spec给API Server。</li><li>2）API Server尝试着将Pod对象的相关信息存入etcd中，待写入操作执行完成，API Server即会返回确认信息至客户端。</li><li>3）API Server开始反映etcd中的状态变化。</li><li>4）所有的Kubernetes组件均使用“watch”机制来跟踪检查API Server上的相关的变动。</li><li>5）kube-scheduler（调度器）通过其“watcher”觉察到API Server创建了新的Pod对象但尚未绑定至任何工作节点。</li><li>6）kube-scheduler为Pod对象挑选一个工作节点并将结果信息更新至API Server。</li><li>7）调度结果信息由API Server更新至etcd存储系统，而且API Server也开始反映此Pod对象的调度结果。</li><li>8）Pod被调度到的目标工作节点上的kubelet尝试在当前节点上调用Docker启动容器，并将容器的结果状态回送至API Server。</li><li>9）API Server将Pod状态信息存入etcd系统中。</li><li>10）在etcd确认写入操作成功完成后，API Server将确认信息发送至相关的kubelet，事件将通过它被接受。</li></ul><blockquote><p>注意：scheduler、kubelet等同时通过使用api server接口来与etcd进行交互的。</p></blockquote><p>Pod生命周期中的重要行为除了创建之外，还包括：</p><ul><li><p><strong>初始化容器</strong>：启动容器之前的初始化操作，比如等待其他关联组件可用、从配置中心获取配置；</p></li><li><p><strong>生命周期钩子函数</strong>：钩子函数是常见的启动或者停止回调方法，Kubernetes为容器提供了两种生命周期钩子，postStart（容器创建完成之后立即运行的钩子处理器）和preStop（容器终止操作之前立即同步运行的钩子处理器）；</p></li><li><p><strong>容器探测</strong>：kubelet对容器周期性执行的健康状态诊断，诊断操作由容器的处理器（handler）进行定义，Kubernetes支持三种处理器用于Pod探测（每一种探测结果都存在3种结果，成功、失败、未知，只有成功才认为OK）：</p></li><li><ul><li><strong>ExecAction</strong>：在容器中执行一个命令，并根据其返回的状态码进行诊断的操作称为Exec探测，状态码为0表示成功，否则即为不健康状态；</li><li><strong>TCPSocketAction</strong>：通过与容器的某TCP端口尝试建立连接进行诊断，端口能够成功打开即为正常，否则为不健康状态；</li><li><strong>HTTPGetAction</strong>：通过向容器IP地址的某指定端口的指定path发起HTTP GET请求进行诊断，响应码为2xx或3xx时即为成功，否则为失败。</li><li>kubelet可在活动容器上执行两种类型的检测：<strong>存活性检测</strong>（livenessProbe）和<strong>就绪性检测</strong>（readinessProbe），如果存活性检测不通过，kubelet将杀死容器并根据其restartPolicy决定是否将其重启。就绪型校验用于判断容器是否准备就绪并开始对外提供服务，未校验通过表示尚未准备就绪此时不会让该容器对外提供服务。</li></ul></li><li><p><strong>容器重启</strong>：当程序崩溃或者资源不足导致Pod对象终止时，会根据重启策略restartPolicy进行重启操作，restartPolicy操作类型有，Always：默认的，Pod终止立即重启；OnFailure：仅在Pod出现错误时才将其重启；Never：从不重启。注意：一但Pod对象分配给某个节点后，那么该Pod对象就不会再被绑定到其他节点上，它要么被重启，要么终止，直到节点发生故障或被删除。触发重启的Pod对象，首次会理解重启，后续重启操作有时间间隔限制，延迟时长依次为10秒、20秒、40秒、80秒、160秒和300秒，300秒是最大延迟时长。</p></li><li><p><strong>容器终止</strong>：当用户提交Pod终止请求时，系统就会进行强制删除操作的宽限期倒计时（默认30s可自定义），并将TERM信息发送给Pod对象的每个容器中的主进程。宽限期倒计时结束后，这些进程将收到强制终止的KILL信号，Pod对象随即也将由API Server删除。如果这一期间发生容器重启，那么系统会重新设定一个满额的宽限期倒计时。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>influxdb入门</title>
      <link href="/2020/01/28/influxdb-ru-men/"/>
      <url>/2020/01/28/influxdb-ru-men/</url>
      
        <content type="html"><![CDATA[<blockquote><p>InfluxDB是一个开源的时序数据库，使用GO语言开发，特别适合用于处理和分析资源监控数据这种时序相关数据。而InfluxDB自带的各种特殊函数如求标准差，随机取样数据，统计数据变化比等，使数据统计和实时分析变得十分方便。</p></blockquote><p>influxdb的单机版是开源的，而集群版是商业版，influxdb被设计运行在SSD上，如果使用机器或者网络磁盘作为存储介质，会导致性能下降至少一个数量级。influxdb支持restful api，同时也支持https，为了保证安全性，非局域网建议使用https与Influxdb进行通信。</p><h3 id="influxdb基础"><a href="#influxdb基础" class="headerlink" title="influxdb基础"></a>influxdb基础</h3><p>infludb中存储的是时间序列数据，比如说某个时间点系统负载、服务耗时等信息，时间序列数据可以包含多个值。关于什么是时间序列数据，简单来来说就是数据是和一个时间点关联的，结合mysql中的记录与id关系来看就是时间序列数据的主键就是时间点（<code>timestrap</code>）。</p><p>infludb中的一条数据至少包括<code>measurement</code>（对应mysql中表概念）、<code>timestamp</code>、至少<code>一个k-v结构的field</code>，再加上0个或者多个k-v结构的tag。对比mysql来看，measurement就是一张表，其主键是timestamp时间戳，tag和field对应就是表中列，tag和field都是k-v接口，k对应列的名字，v对应该列存储的值，tag和field不同的是，tag是有索引的而field没有（如果查询条件为tag则会扫描所有查询到的数据），对于mysql表的有索引列和无索引列。注意mysql中的表需要提前定义结构，而influxdb中的measurement无需提前定义，其null值也不会被存储。</p><p>influxdb中measurement无需定义，即无模式设计，开发者可以在任意添加measurement，tags和fields，不过针对同一个field，第二次和第一次写入的数据类型不匹配，influxdb会报错（由于默认tag的v都是字符串类型，所有不存在这个问题，不管输入是什么数据都当做字符串来处理）。</p><h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><p>influxdb数据写入需满足如下格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> &lt;measurement&gt;[,&lt;tag-<span class="keyword">key</span>&gt;=&lt;tag-<span class="keyword">value</span>&gt;...] &lt;<span class="keyword">field</span>-<span class="keyword">key</span>&gt;=&lt;<span class="keyword">field</span>-<span class="keyword">value</span>&gt;[,&lt;field2-<span class="keyword">key</span>&gt;=&lt;field2-<span class="keyword">value</span>&gt;...] [unix-nano-<span class="built_in">timestamp</span>]</span><br></pre></td></tr></table></figure><blockquote><p>注意：measurement和至少一个fileld的k-v是必须的，tag和timestrap时间戳是可选的。</p></blockquote><p>说实话，这个写入格式还是有点小严格的，因为它要求measurement和可能的0个或多个tag之间必须是紧挨着的，中间不能有空格；同时多个filed之间也是不能有空格，tag和field的k，tag的v都是字符串类型；时间戳不是必须的，如果为空则使用服务端的本地时间作为时间戳。相同时间戳的数据第二次写入会覆盖第一次写入的数据，相当于更新操作。</p><blockquote><p>为什么至少有一个filed是必须的，而tag是可选的呢？</p></blockquote><p>这是influxdb的存储模型决定的，<code>measurement+tag set+field key</code>作为key，field value作为value，如果没有field则没有了对应的value了。</p><blockquote><p>插入数据的tag key和field key能一样么？</p></blockquote><p>数据插入没问题，这是由于infludb底层存储tag和field是在不同地方的，只不过为了区分会加上<code>_序号</code>而已，如下图：</p><p><img src="/2020/01/28/influxdb-ru-men/./influxdb入门/image-20200128085046609.png" alt></p><p>当在use某个db之后，就可以执行数据读写操作，比如下面往名字为cpu的<code>MEASUREMENT（对应mysql中的表概念）</code>中写入如下数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> cpu,host=s01,region=hangzhou <span class="keyword">value</span>=<span class="number">0.64</span> <span class="number">1520052020000000000</span></span><br><span class="line">命令说明：</span><br><span class="line">- 插入数据对应的MEASUREMENT名字为cpu；</span><br><span class="line">- 数据tag分别是host和region，<span class="keyword">field</span>是<span class="keyword">value</span>；</span><br><span class="line">- 数据的最后一项是时间戳（<span class="number">1520052020000000000</span>），时间戳不是必须的，如果不传则使用influxdb服务端本地时间戳，注意时间戳都是UTC时间</span><br></pre></td></tr></table></figure><h3 id="数据保留策略"><a href="#数据保留策略" class="headerlink" title="数据保留策略"></a>数据保留策略</h3><p>Influxdb可支持每秒十万级别的数据量，如果长时间保存会对存储造成很大压力，因此和一般数据存储系统一样有一个数据保留策略，同时针对大流量量数据可采样保存，小流量数据可全量保存。influxdb通过保留策略（RP，Retention Policy）来管理过期数据，使用连续查询（<code>CR，Continuous Queries</code>）来进行数据采样。</p><ul><li>RP：数据保留策略，过期数据会被清除，每个数据库可拥有多种RP策略；</li><li>CQ：数据连续查询，定时跑的一个查询语句，比如周期性统计某个数据指标，查询语句需要在select语句中使用并且包含group by time子句（这里有点类似Flink中流数据处理的按时间窗口统计功能）。</li></ul><p>默认写数据不指定保留策略（RP，Retention Policy）时，默认使用influxdb默认的RP，名字叫做autogen的RP会永久保留数据。如果使用命令 <code>create retention policy &quot;default2&quot; on &quot;db2&quot; duration 2h replication 1 default</code>，执行该命令后default2会取代默认的autugen作为db2数据库的默认RP，默认influxdb会间隔半个小时执行一次RP操作。</p><blockquote><p>比如有一个服务请求日志measurement的名字为log（RP策略是2小时，数据库是db2），其中数据有服务耗时（字段对应名字time），我们想统计每分钟平均服务耗时，然后将平均耗时数据写入到名字为log2的measurement（RP策略是2天），该如何做呢？</p></blockquote><p>首先创建2小时和2天的RP策略：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">retention</span> <span class="keyword">policy</span> <span class="string">"tow_hour"</span> <span class="keyword">on</span> db2 <span class="keyword">duration</span> <span class="number">2</span>h <span class="keyword">replication</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 对数据库db2创建一个名字叫"tow_hour"的RP策略，数据保存2小时，由于最后没有加default，所以数据读写如果没有执行RP仍然使用的是influxdb默认的RP</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">retention</span> <span class="keyword">policy</span> <span class="string">"tow_day"</span> <span class="keyword">on</span> db2 <span class="keyword">duration</span> <span class="number">2</span>d <span class="keyword">replication</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 对数据库db2创建一个名字叫"tow_day"的RP策略，注意对于单机版influxdb来说replication无意义</span></span><br></pre></td></tr></table></figure><p>然后使用create continuous query创建CQ策略：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> continuous <span class="keyword">query</span> <span class="string">"cq_avg_time"</span> <span class="keyword">on</span> db2 </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">select</span> mean(<span class="string">"time"</span>) <span class="keyword">as</span> <span class="string">"mean_time"</span> <span class="keyword">into</span> <span class="string">"tow_day"</span>.<span class="string">"log2"</span> <span class="keyword">from</span> <span class="keyword">log</span> </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">time</span>(<span class="number">1</span>m) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样就创建了一个名字叫cq_avg_time的CQ作用于db2数据库，每1分钟一次计算measurement为log的time字段的平均值，然后写入到另一个measurement为log2中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> influxdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>influxdb原理那些事</title>
      <link href="/2020/01/28/influxdb-yuan-li-na-xie-shi/"/>
      <url>/2020/01/28/influxdb-yuan-li-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<p>InfluxDB是一个开源的时序数据库，使用GO语言开发，特别适合用于处理和分析资源监控数据这种时序相关数据。而InfluxDB自带的各种特殊函数如求标准差，随机取样数据，统计数据变化比等，使数据统计和实时分析变得十分方便。</p><p>在目前的APM和后续的IoT场景中，InfluxDB会发挥越来越重要的作用，那么InfluxDB是如何保存数据并且高性能对外提供存取服务的呢？下面就一起来看下InfluxDB原理的那些事 ~</p><p>centos下influxdb默认配置路径为<code>/etc/influxdb/influxdb.conf</code>，influxdb数据存储主要有3个目录，分别是<code>meta、wal和data</code>。meta主要存放元数据，该目录下有一个meta.db文件；wal目录存放预写日志，以.wal结尾；data目录存放TSM文件，以.tsm文件结尾。</p><p><img src="/2020/01/28/influxdb-yuan-li-na-xie-shi/./influxdb原理那些事/image-20200128095555081.png" alt></p><p>在同一个database中，retention policy、measurement、tag sets 完全相同的数据同属于一个 <strong>series</strong>，从Index数据排列来看，同一个 series 的数据在物理上会按照时间顺序排列存储在一起，series 的 key 为 measurement + tags set 序列化字符串，series代码中结构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Series struct &#123;</span><br><span class="line">    mu          sync.RWMutex</span><br><span class="line">    Key         string              // series key</span><br><span class="line">    Tags        map[string]string   // tags</span><br><span class="line">    id          uint64              // id</span><br><span class="line">    measurement *Measurement        // measurement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WAL就是一种写优化且固定格式的预写文件，允许写入持久化但是不易查询，对WAL的写入就是append操作。influxdb的WAL就是一系列格式为 _00xxx.wal 的文件，文件号单调递增，默认当超过10M时就会新写一个WAL文件，每个WAL文件都会存储经过压缩的数据。当一个新的Point数据被写入时，首先经过压缩写入到WAL中，在返回之前会写入到内存的索引中，这意味着数据写入后立马可通过索引可见，同时批量写入意味着更高效率。当WAL日志对应的数据被写入到TSM中后，WAL日志就可以删除了。WAL具体数据格式如下：</p><p><img src="/2020/01/28/influxdb-yuan-li-na-xie-shi/./influxdb原理那些事/image-20200128095907419.png" alt></p><p>Cache就是WAL的内存表示，它在运行时可被查询并且与TSM中保存的文件进行合并。当缓存大小超过 cache-snapshot-memory-size 时会触发缓存数据写入到TSM文件，并删除对应的WAL段文件；当缓存大小超过 cache-max-memory-size 时会导致cache拒绝新的写入，避免数据流量过大影响服务稳定性。除了内存的阈值限制之外，缓存还会在 cache-snapshot-write-cold-duration 配置的时间间隔定期将缓存数据写入到TSM文件。通过重读所有WAL文件，Influxdb可以在启动时重建缓存。</p><p>我们知道Cache就是WAL的内存表示，相当于LSM中的memtable，在内存中它就是一个map结构，其key就是 series key+fieldName，当然key也包含有分隔符（目前是#!~#），entry就是一个按照时间戳排序的数据容器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    commit  sync.Mutex</span><br><span class="line">    mu      sync.RWMutex</span><br><span class="line">    store   <span class="keyword">map</span>[<span class="keyword">string</span>]*entry</span><br><span class="line">    size    <span class="keyword">uint64</span>              <span class="comment">// 当前使用内存的大小</span></span><br><span class="line">    maxSize <span class="keyword">uint64</span>              <span class="comment">// 缓存最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// snapshots are the cache objects that are currently being written to tsm files</span></span><br><span class="line">    <span class="comment">// they're kept in memory while flushing so they can be queried along with the cache.</span></span><br><span class="line">    <span class="comment">// they are read only and should never be modified</span></span><br><span class="line">    <span class="comment">// memtable 快照，用于写入 tsm 文件，只读</span></span><br><span class="line">    snapshot     *Cache</span><br><span class="line">    snapshotSize <span class="keyword">uint64</span></span><br><span class="line">    snapshotting <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This number is the number of pending or failed WriteSnaphot attempts since the last successful one.</span></span><br><span class="line">    snapshotAttempts <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    stats        *CacheStatistics</span><br><span class="line">    lastSnapshot time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入数据就是往WAL和Cache写数据，当influxdb启动时，会遍历所有WAL文件构建Cache，这样保证系统出现故障也不会造成数据丢失。</p><p>TSM文件是influxdb数据存储的一系列只读文件集合，这些文件结构类似于leveldb中的SSTable，一个TSM文件格式如下：</p><p><img src="/2020/01/28/influxdb-yuan-li-na-xie-shi/./influxdb原理那些事/image-20200128100005621.png" alt></p><ul><li><strong>Header</strong>：头部信息，4位magic字段+1位version字段；</li><li><strong>Blocks</strong>：CRC+数据存储字段，数据的长度在index字段存储；</li><li><strong>Index</strong>：索引顺序按照先key后时间戳来，如果key相同则按照时间戳排序，key包括measurement+tag set+一个filed，如果一个point包含多个field，则包含多个索引条目；每个索引条目以key len和key开始，标准的TLV格式，然后是block类型（float，int，bool，string）以及该block的条目数，之后是block的最小、最大时间戳，最后是block所在的文件偏移量以及block大小 — 也就是说，包含该key的TSM文件中每个block都有一个索引block条目；</li><li><strong>footer</strong>：存储了索引开头的offset。</li></ul><p>从TSM文件结构来看，解析TSM需要读取footer来确定Index和Blocks分界点，然后读取Index信息来提取对应的Block，才能组成一个完整的TSM索引+数据信息。Block对应的数据也是经过压缩的，以便减少存储空间，block包含时间戳、series和field值，每个block都有1个字节的header，之后是压缩过的时间戳和值：</p><p><img src="/2020/01/28/influxdb-yuan-li-na-xie-shi/./influxdb原理那些事/image-20200128100032489.png" alt></p><p>针对不同类型数据采用不同压缩编码，比如时间戳、整形、浮点数和字符串等，字符串使用Snappy压缩进行编码，每个字符串连续打包然后压缩成一个较大的块。</p><blockquote><p>数据删除通过向WAL写入删除条目然后更新Cache来完成删除操作，同时Influxdb会为包含相关数据的TSM文件写入一个tombstone文件，这些tombstone文件被用于在启动时忽略相应的block，以及在compaction时期移除已删除的数据，换句话说，数据删除在influxdb中是一个低效率操作，特别是针对大数据量删除来说，并且只有等待数据合并时才会真正删除数据。</p></blockquote><p>如果直接读取TSM中的Index进行索引查询无疑是低效的，因此会在内存中构建方便二分查询，结构如下：</p><p><img src="/2020/01/28/influxdb-yuan-li-na-xie-shi/./influxdb原理那些事/image-20200128100114755.png" alt></p><p>由于Index中各个key长度不定，因此使用offsets字段进行二分搜索，offsets数组中储存的是对应Index中key数据偏移量。TSM中的Index字段也是定长的，也是可以执行二分查找，找到要查询的数据的 BlockIndex 的内容，然后根据偏移量以及 block 长度就可以从 tsm 文件中快速读取出一个 block 数据。</p><p>通过上面的Index+offsets数据和TSM文件的Index数据，可以通过某个key（measurement+tag set+一个filed）来进行数据查询，但是我们一般的查询都是通过某个tag的值来查找的，比如以下查询代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">FROM</span> cpu <span class="keyword">WHERE</span> host=<span class="string">'s01'</span> <span class="keyword">AND</span> <span class="built_in">time</span> &gt; <span class="keyword">now</span>() - <span class="number">10</span>h</span><br></pre></td></tr></table></figure><p>那么该如何使用上面所说的索引查找流程呢？是不是存在一个单个tag value和key的映射关系呢，对，确实存在这样的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Measurement <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">    fieldNames <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;      <span class="comment">// 此 measurement 中的所有 filedNames</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中的索引信息</span></span><br><span class="line">    <span class="comment">// id 以及其对应的 series 信息，主要是为了在 seriesByTagKeyValue 中存储Id节约内存</span></span><br><span class="line">    seriesByID          <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Series              <span class="comment">// lookup table for series by their id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 tagk 和 tagv 的双重索引，保存排好序的 SeriesID 数组</span></span><br><span class="line">    <span class="comment">// 这个 map 用于在查询操作时，可以根据 tags 来快速过滤出要查询的所有 SeriesID，之后根据 SeriesKey 以及时间范围从文件中读取相应内容</span></span><br><span class="line">    seriesByTagKeyValue <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]SeriesIDs <span class="comment">// map from tag key to value to sorted set of series ids</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此 measurement 中所有 series 的 id，按照 id 排序</span></span><br><span class="line">    seriesIDs           SeriesIDs                       <span class="comment">// sorted list of series IDs in this measurement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以命令 select * FROM cpu WHERE host=’s01’ AND time &gt; now() - 10h 为例，通过 seriesByTagKeyValue[‘host’][‘s01’] 获取到所有匹配的 series 的 ID值，然后再通过map结构seriesByID根据series id获取到series对象，注意匹配到的某个tag value的可能不止一个series。这样，我们就可以在O(1)时间复杂度内找到tag value对应的 series key，然后根据查询请求的时间范围，从不同shard中获取每一个series在指定时间段内的数据，后续的查询则和 tsm file 中的 Index 的在内存中的缓存相关了。</p><p>参考资料：</p><p>1、<a href="https://www.linuxdaxue.com/influxdb-principle.html" target="_blank" rel="noopener">https://www.linuxdaxue.com/influxdb-principle.html</a></p><p>2、<a href="https://jasper-zhang1.gitbooks.io/influxdb/content/Concepts/storage_engine.html" target="_blank" rel="noopener">https://jasper-zhang1.gitbooks.io/influxdb/content/Concepts/storage_engine.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> influxdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>influxdb的命令们</title>
      <link href="/2020/01/28/influxdb-de-ming-ling-men/"/>
      <url>/2020/01/28/influxdb-de-ming-ling-men/</url>
      
        <content type="html"><![CDATA[<blockquote><p>InfluxDB是一个开源的时序数据库，使用GO语言开发，特别适合用于处理和分析资源监控数据这种时序相关数据。而InfluxDB自带的各种特殊函数如求标准差，随机取样数据，统计数据变化比等，使数据统计和实时分析变得十分方便。</p></blockquote><p>influxdb的单机版是开源的，而集群版是商业版，influxdb被设计运行在SSD上，如果使用机器或者网络磁盘作为存储介质，会导致性能下降至少一个数量级。influxdb支持restful api，同时也支持https，为了保证安全性，非局域网建议使用https与Influxdb进行通信。</p><blockquote><p>学习influxdb，如同学习MySQL先要了解SQL一样，让我们一起来看看influxdb的那些命令们 ~</p></blockquote><p>centos下使用命令 yum install influxdb 安装influxdb之后，就可以使用命令 service influxdb start 启动influxdb，通过命令 influx 启动cli客户端。influxdb的命令基本都符合标准的sql格式，基础操作命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">influx 启动influxdb客户端，如同mysql -u xxx功能</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1  创建数据库db1</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>  查看数据库列表</span><br><span class="line"><span class="keyword">use</span> db1  使用数据库db1，是不是和mysql中功能类似</span><br><span class="line"><span class="keyword">show</span> measurements  查看measurement列表</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db1  删除数据库db1</span><br><span class="line"><span class="keyword">drop</span> measurement mt1  删除表mt1</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> measurement [<span class="keyword">WHERE</span> &lt;tag_key&gt; &lt;<span class="keyword">operator</span>&gt;]</span><br><span class="line"><span class="keyword">drop</span> shard &lt;shard_id_num&gt; 删除分片</span><br></pre></td></tr></table></figure><h3 id="influxdb的概念们"><a href="#influxdb的概念们" class="headerlink" title="influxdb的概念们"></a>influxdb的概念们</h3><ul><li><strong>database</strong>：数据库；</li><li><strong>measurement</strong>：数据表；</li><li><strong>point</strong>：数据行，由时间戳、tag、field组成（<code>一条数据至少包括measurement（对应mysql中表概念）、timestamp、至少一个k-v结构的field，再加上0个或者多个k-v结构的tag</code>）；</li><li><strong>series</strong>：一些数据结合，同一个database下，<code>retention policy、measurement、tag sets</code>完全相同的数据同属于一个 series，同一个series的数据物理上会存放在一起；</li><li><strong>分片</strong>：默认按时间段创建的数据分片，它和存储策略相关，每一个存储策略下会存在许多 shard，每一个 shard 存储一个指定时间段内的数据，并且不重复。每一个分片都映射到底层存储引擎数据库，每一个数据库都有自己的WAL和TSM文件，使用命令 show shards 查看分片。</li></ul><p>influxdb数据写入需满足如下格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> &lt;measurement&gt;[,&lt;tag-<span class="keyword">key</span>&gt;=&lt;tag-<span class="keyword">value</span>&gt;...] &lt;<span class="keyword">field</span>-<span class="keyword">key</span>&gt;=&lt;<span class="keyword">field</span>-<span class="keyword">value</span>&gt;[,&lt;field2-<span class="keyword">key</span>&gt;=&lt;field2-<span class="keyword">value</span>&gt;...] [unix-nano-<span class="built_in">timestamp</span>]</span><br></pre></td></tr></table></figure><blockquote><p>注意：measurement和至少一个fileld的k-v是必须的，tag和timestrap时间戳是可选的。</p></blockquote><p>说实话，这个写入格式还是有点小严格的，因为它要求measurement和可能的0个或多个tag之间必须是紧挨着的，中间不能有空格；同时多个filed之间也是不能有空格，tag和field的k，tag的v都是字符串类型；时间戳不是必须的，如果为空则使用服务端的本地时间作为时间戳。相同时间戳的数据第二次写入会覆盖第一次写入的数据，相当于更新操作。</p><p>数据写入完成之后，就可以使用查看命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> measurement_name [<span class="keyword">WHERE</span> &lt;tag_key&gt; &lt;<span class="keyword">operator</span>&gt;] [<span class="keyword">limit</span> xx]  查看数据</span><br><span class="line"><span class="keyword">show</span> series [<span class="keyword">on</span> dbname] [<span class="keyword">from</span> measurement] [<span class="keyword">WHERE</span> &lt;tag_key&gt; &lt;<span class="keyword">operator</span>&gt;] [<span class="keyword">limit</span> xx]  查看series信息</span><br><span class="line"><span class="keyword">show</span> tag <span class="keyword">keys</span> [<span class="keyword">on</span> dbname] [<span class="keyword">from</span> measurement] [<span class="keyword">WHERE</span> &lt;tag_key&gt; &lt;<span class="keyword">operator</span>&gt;] [<span class="keyword">limit</span> xx]  查看tag <span class="keyword">keys</span>信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">field</span> <span class="keyword">keys</span> [<span class="keyword">on</span> dbname] [<span class="keyword">from</span> measurement]  查看<span class="keyword">field</span> <span class="keyword">keys</span></span><br></pre></td></tr></table></figure><p>Influxdb可支持每秒十万级别的数据量，如果长时间保存会对存储造成很大压力，因此和一般数据存储系统一样有一个数据保留策略，同时针对大流量量数据可采样保存，小流量数据可全量保存。influxdb通过保留策略（<code>RP，Retention Policy</code>）来管理过期数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建过期策略</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">retention</span> <span class="keyword">policy</span> &lt;retention_policy_name&gt; <span class="keyword">on</span> &lt;database_name&gt; <span class="keyword">duration</span> &lt;<span class="keyword">duration</span>&gt; replicationN &lt;n&gt; [SHARD <span class="keyword">DURATION</span> &lt;<span class="keyword">duration</span>&gt;] [<span class="keyword">DEFAULT</span>]</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">retention</span> policies [<span class="keyword">on</span> dbname]  查看过期策略</span><br></pre></td></tr></table></figure><p>在influxdb中，通过数据保留策略（RP），分片是挂在RP下管理的，数据过期的维度是分片，当检测到一个 shard 中的数据过期后，只需要将这个 shard 的资源释放，相关文件删除即可，这样的做法使得删除过期数据变得非常高效。</p><p>除了直接使用influxdb命令之外，还可使用函数，influxdb的函数大致分为<code>aggregate，select和predict</code>。<strong>aggregate类型命令大致如下</strong>：</p><ul><li><strong>count：</strong>返回非空字段数据数量，格式为<code>select count ( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) from measurement_name [WHERE &lt;tag_key&gt; &lt;operator&gt;] [limit xx]</code>。除了统计非空字段数量之外，还可统计distinct列的数量，比如命令 <code>select count(distintct(&quot;xxx&quot;)) from xxx</code>。大多数influxdb命令针对没有数据间隔返回null，count针对没有数据返回的间隔返回0，而类似的<code>fill(&lt;fill_option&gt;)</code>用fill_option替换0值。</li><li><strong>distinct</strong>：返回非null值的数据不相同数据计数。</li><li><strong>integral</strong>：返回曲线下面积（积分），格式为 <code>select integral ( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) from measurement_name [WHERE &lt;tag_key&gt; &lt;operator&gt;] [limit xx]</code> ，uint为时间单位，默认单位s。</li><li><strong>mean</strong>：返回字段平均值。</li><li><strong>median</strong>：返回字段中位数。</li><li><strong>mode</strong>：返回字段中出现频率最高的值。</li><li><strong>spread</strong>：返回字段中最大值、最小值的差值。</li><li><strong>stddev</strong>：返回字段的标准差。</li><li><strong>sum</strong>：字段和。</li></ul><p><strong>selectors类型命令大致如下</strong>：</p><ul><li><strong>bottom</strong>：返回最小的n个值，格式为<code>select bottom (&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; ) from xxx where xxx</code>；</li><li><strong>first</strong>：返回时间戳最早的值；</li><li><strong>last</strong>：返回时间戳最近的值；</li><li><strong>max、min</strong>：返回最大/最小返回值；</li><li><strong>percentile</strong>：返回较大的百分比，格式为<code>select percentile (&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;]</code>；</li><li><strong>top</strong>：返回最大的字段值。</li></ul><p>influxdb支持很多常见和高级的聚合查询函数，可满足大多数场景需要，具体可参考 <a href="https://jasper-zhang1.gitbooks.io/influxdb/content/Query_language/functions.html。" target="_blank" rel="noopener">https://jasper-zhang1.gitbooks.io/influxdb/content/Query_language/functions.html。</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>infludb中存储的是时间序列数据，比如说某个时间点系统负载、服务耗时等信息，时间序列数据可以包含多个值。关于什么是时间序列数据，简单来来说就是数据是和一个时间点关联的，结合mysql中的记录与id关系来看就是时间序列数据的主键就是时间点（<code>timestrap</code>）。</p><p>infludb中的一条数据至少包括<code>measurement</code>（对应mysql中表概念）、<code>timestamp</code>、至少<code>一个k-v结构的field</code>，再加上0个或者多个k-v结构的tag。对比mysql来看，measurement就是一张表，其主键是timestamp时间戳，tag和field对应就是表中列，tag和field都是k-v接口，k对应列的名字，v对应该列存储的值，tag和field不同的是，tag是有索引的而field没有（如果查询条件为tag则会扫描所有查询到的数据），对于mysql表的有索引列和无索引列。注意mysql中的表需要提前定义结构，而influxdb中的measurement无需提前定义，其null值也不会被存储。</p><p>influxdb中measurement无需定义，即无模式设计，开发者可以在任意添加measurement，tags和fields，不过针对同一个field，第二次和第一次写入的数据类型不匹配，influxdb会报错（由于默认tag的v都是字符串类型，所有不存在这个问题，不管输入是什么数据都当做字符串来处理）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> influxdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes基础概念</title>
      <link href="/2020/01/21/kubernetes-ji-chu-gai-nian/"/>
      <url>/2020/01/21/kubernetes-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>kubernetes（简称k8s）是一种用于在一组主机上运行和协同容器化应用程序的管理平台，皆在提供高可用、高扩展性和可预测性的方式来管理容器应用的生命周期。通过k8s，用户可以定义程序运行方式、部署升级策略、动态伸缩容，使得用户以一种更灵活可靠的方式来管理应用程序。</p><blockquote><p>关于k8s，是一种对应用服务的打包、部署、监控等一整套生命周期的自动化管理平台，目前各大公司已在生产环境部署使用，同时k8s社区比较活跃，在未来一段时间内会越来越流行，可以说是以后服务部署的事实标准，对于Java开发者来说，你可以不直接使用它，但是不能不了解它。</p></blockquote><p>总结来看，k8s特点如下：</p><ul><li><strong>自动装箱</strong>：基于容器，结合调度策略将多种应用部署到同一节点上，提高资源利用率；</li><li><strong>自我修复</strong>：支持故障转移/重启，具有健康检查机制；</li><li><strong>水平扩展</strong>：通过命令手动执行扩容，可基于CPU等资源负载率来动态实现伸缩容；</li><li><strong>服务发现/负载均衡</strong>：通过KubeDNS（或CoreDNS）为系统内置了服务发现功能，为每个service配置DNS名称，service通过iptables或ipvs内建了负载均衡机制；</li><li><strong>自动部署</strong>：自动发布和回滚，支持灰度、增量发布等；</li><li><strong>配置管理</strong>：ConfigMap实现了配置数据与Docker镜像解耦，为开发部署提供了良好的灵活性；</li><li><strong>批处理</strong>：除了管理服务型应用之外，Kubernetes还支持批处理作业及CI（持续集成）。</li></ul><blockquote><p>从k8s的角度看，它把各个待管理的资源进行了抽象，比如针对服务器（物理机或者虚拟机）抽象出Node；对于容器不直接管理而是抽象出Pod来管理容器；对于集群内的服务调用，抽象出service来表示同类型的多个Pod，同时提供负载均衡策略等。</p></blockquote><p>对于初学者来说，k8s的一些抽象资源和基本概念可能会造成一头雾水，本文就k8s的基础概念和组件进行简单分析，让初学者更快了解k8s概念，话不多说，let‘s go~</p><h3 id="k8s基础概念"><a href="#k8s基础概念" class="headerlink" title="k8s基础概念"></a>k8s基础概念</h3><p>k8s使用共享网络将多个物理机（或者虚拟机）汇集到一个集群中，该集群是配置k8s所有组件、功能和工作负载的物理平台。集群中一台服务器会作为master负责管理整个集群（为了master高可用一般会将master部署成多节点）。</p><p>Master是集群的网关和中枢，负责诸如为用户和客户端暴露API、跟踪其他服务器的健康状态、以最优方式调度工作负载，以及编排其他组件之间的通信等任务，它是用户/客户端与集群之间的核心联络点，并负责Kubernetes系统的大多数集中式管控逻辑。单个Master节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。Node是Kubernetes集群的工作节点，负责接收来自Master的工作指令并根据指令相应地创建或销毁Pod对象，以及调整网络规则以合理地路由和转发流量等。理论上讲，Node可以是任何形式的计算设备，不过Master会统一将其抽象为Node对象进行管理。</p><h3 id="几种资源抽象"><a href="#几种资源抽象" class="headerlink" title="几种资源抽象"></a>几种资源抽象</h3><ul><li><strong>Pod</strong>：k8s管理的最小调度单元，k8s不直接来管理容器，使用一个抽象的资源对象来封装一个或者多个容器，这个抽象即为Pod。同一Pod中的容器共享网络名称空间和存储资源，这些容器可经由本地回环接口lo直接通信，同时对于Mount、User及PID等资源也进行了隔离；</li><li><strong>标签资源和标签选择器</strong>：标签（Label）是将资源进行分类的标识符，k8s的Pod资源选择大都是基于标签来的，一个对象可以拥有多个标签，一个标签也可以附加于多个对象（通常是同一类对象）之上。标签选择器（Selector）全称为“Label Selector”，它是一种根据Label来过滤符合条件的资源对象的机制；</li><li><strong>Controller</strong>：Pod控制器，尽管Pod是k8s的最小调度单元，但用户通常并不会直接部署及管理Pod对象，而是要借助于另一类抽象——控制器（Controller）对其进行管理，k8s的控制器包括ReplicationController、ReplicaSet、Deployment、StatefulSet、Job等，每种controller都有对应的功能（比如Deployment是最常见的无状态应用的控制器，它支持应用的扩缩容、滚动更新等操作，为容器化应用赋予了极具弹性的功能）；</li><li><strong>Service</strong>：Service是建立在一组Pod对象之上的资源抽象，它通过标签选择器选定一组Pod对象，并为这组Pod对象定义一个统一的固定访问入口（通常是一个IP地址）；</li><li><strong>存储卷</strong>：一般是独立于容器文件系统之外的存储空间，常用于扩展容器的存储空间并为它提供持久存储能力，大体上可分为临时卷、本地卷和网络卷；</li><li><strong>Name和Namespace</strong>：名称是网络资源的唯一标识符，通常在一个命名空间内，名称标识是唯一的，名称空间通常用于实现租户或项目的资源隔离，从而形成逻辑分组；</li><li><strong>Ingress</strong>：k8s中将Pod进行了网络隔离，如果需要开放一些Pod供外部使用，则需要一个配置一个流量进入k8s集群内的通道，除了Service外，Ingress也是实现策略之一。</li></ul><h3 id="k8s组件"><a href="#k8s组件" class="headerlink" title="k8s组件"></a>k8s组件</h3><p>一个典型的k8s集群由master节点、多个工作节点和ETCD组成，其中ETCD作为集群状态存储。master节点负责整个集群的管理工作，为集群提供管理API，并负责编排和监控各工作节点，各工作节点已Pod形式管理运行容器。master主要由apiserver、controller-manager和scheduler三个组件组成，同时负责与ETCD教育存储集群状态数据，而每个工作节点主要包含kubelet、kube-proxy及容器引擎（最常见的是Docker）等组件。各个组件整体如下图：</p><p><img src="/2020/01/21/kubernetes-ji-chu-gai-nian/./kubernetes基础概念/image-20200120214102347.png" alt></p><h4 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h4><p>master包含组件如下：</p><ul><li><strong>API server</strong>：对外提供restful api，k8s集群的网关；</li><li><strong>Controller</strong>：Pod控制器，k8s通过控制器来管理Pod资源，控制器包括ReplicationController、ReplicaSet、Deployment、StatefulSet、Job等，每种controller都有对应的功能（比如Deployment是最常见的无状态应用的控制器，它支持应用的扩缩容、滚动更新等操作，为容器化应用赋予了极具弹性的功能）；</li><li><strong>Scheduler</strong>：K8s调度器，K8s管理成千上万容器资源，api server接收到请求之后就由Scheduler按照对应调度策略进行在不同Node间的请求调度操作；</li><li><strong>ETCD</strong>：k8s集群状态都是存储在etcd中（通过API Server共享给集群的各组件及客户端），通过etcd的watch机制来进行k8s各组件的协同操作，一般etcd通过集群部署方式保证高可用。</li></ul><h4 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h4><p>node节点接受master的管理，负责管理各个Pod资源：</p><ul><li><strong>kubelet</strong>：kubelet是node的守护进程，node接受master的管控，Kubelet会向api server注册当前node，定期向master会报node资源占用情况；</li><li><strong>容器运行环境</strong>：node会提供一个容器运行环境，负责下载并运行容器，k8s目前支持的容器运行环境包括Docker、RKT、cri-o和Fraki等；</li><li><strong>kube-proxy</strong>：每个node都需要一个kube-proxy进程，比如对service按需生成iptables或ipvs规则，控制流量访问。</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>k8s除了etcd、master、node这几个组件之外，还有一些核心组件，如下：</p><ul><li><strong>DNS服务</strong>：目前k8s使用的是coreDNS，之前使用的是KubeDNS；</li><li><strong>Kubernetes Dashboard</strong>：k8s的管理web UI；</li><li><strong>Heapster</strong>：容器和节点的性能监控与分析系统，它收集并解析多种指标数据，如资源利用率、生命周期事件等。新版本的Kubernetes中，其功能会逐渐由Prometheus结合其他组件所取代。</li><li><strong>Ingress Controller</strong>:Service是一种工作于传统层的负载均衡器，而Ingress是在应用层实现的HTTP（s）负载均衡机制。不过，Ingress资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则需要通过Ingress控制器（Ingress Controller）发挥作用。目前，此类的可用项目有Nginx、Traefik、Envoy及HAProxy等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker网络通信</title>
      <link href="/2020/01/21/docker-wang-luo-tong-xin/"/>
      <url>/2020/01/21/docker-wang-luo-tong-xin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker是基于go语言开发，Linux下的底层技术主要基于cgroups、namespace以及联合文件技术实现的一种进程级别的轻量级虚拟化解决方案。由于Docker进程隔离独立于宿主机上其他进程，因此也称为容器，Docker在容器的基础上，进行了更进一步的封装，从文件系统、网络到进程隔离等，极大简化了容器的创建管理维护工作，降低了开发者使用门槛，因此才在近几年流行开来（毕竟Docker的底层技术在Docker出现之前就已经存在了）。</p></blockquote><p>Docker作为一种容器技术，在目前的分布式和微服务系统中被广泛使用，因为要在多个容器或机器间进行通信，因此Docker网络通信是一个重要的技术点。<strong>从网络架构的角度来看，所有的容器实际上是通过本地主机的网桥接口（docker0）进行相互通信，就像物理机器通过物理交换机通信一样</strong>。</p><p>Docker服务启动时会首先在主机上自动创建一个docker0虚拟网桥，实际上是一个Linux网桥。网桥可以理解为一个软件交换机，负责挂载其上的接口之间进行包转发。同时，Docker随机分配一个本地未占用的私有网段（在<code>RFC1918</code>中定义）中的一个地址给docker0接口。比如典型的<code>172.17.0.0/16</code>网段，掩码为<code>255.255.0.0</code>，此后启动的容器内的网口也会自动分配一个该网段的地址。</p><p>当创建一个Docker容器的时候，同时会创建了一对<code>veth pair</code>互联接口。当向任一个接口发送包时，另外一个接口自动收到相同的包。互联接口的一端位于容器内，即eth0；另一端在本地并被挂载到docker0网桥，名称以veth开头。通过这种方式，主机可以与容器通信，容器之间也可以相互通信。如此一来，Docker就创建了在主机和所有容器之间一个虚拟共享网络：</p><p><img src="/2020/01/21/docker-wang-luo-tong-xin/./Docker网络通信/image-20200131180010830.png" alt></p><p>默认情况下，Docker容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器，可通过命令 <code>docker port container</code>查看对应容器的端口映射信息。Docker容器使用的是私有网络IP，那么容器访问外部流程是什么样的呢？</p><p>假设容器内部的网络地址为172.17.0.2，本地网络地址为10.0.2.2，容器要能访问外部网络，源地址不能为172.17.0.2，需要进行源地址映射（<code>Source NAT, SNAT</code>），修改为本地系统的IP地址10.0.2.2。映射是通过iptables的源地址伪装操作实现的。查看主机nat表上POSTROUTING链的规则。该链负责网包要离开主机前，改写其源地址。其中，上述规则将所有源地址在172.17.0.0/16网段，且不是从docker0接口发出的流量（即从容器中出来的流量），动态伪装为从系统网卡发出。MASQUERADE行动与传统SNAT行动相比，好处是能动态地从网卡获取地址。</p><p>知道了容器内部访问外部流程，如果外部想要访问内部该如何实现呢？容器允许外部访问，可以在docker [container] run时候通过-p或-P参数来启用容器内外端口的映射配置。不管用哪种办法，其实也是在本地的iptable的nat表中添加相应的规则，将访问外部IP地址的包进行目标地址DNAT，将目标地址修改为容器的IP地址。每次创建一个新容器的时候，Docker从可用的地址段中选择一个空闲的IP地址分配给容器的eth0端口，并且使用本地主机上docker0接口的IP作为容器的默认网关。目前docker不支持启动时配置ip地址。</p><p>上面所说的是docker容器的默认网络通信模式—bridge模式，容器拥有独立的网络命名空间和网络协议栈，如果容器启动过程中不添加<code>--net</code>参数配置，则默认采用这种网络通信默认。除了bridge模式之外，还可以配置host网络模式，直接使用容器宿主机的网络命名空间，该模式下容器不再拥有自己独立的网络环境，直接使用宿主机的IP和端口。当然用户也可自定义网络模式或者none模式等。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>namespace原理解析</title>
      <link href="/2020/01/12/namespace-yuan-li-jie-xi/"/>
      <url>/2020/01/12/namespace-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Namespace是将内核的全局资源做封装，使得每个Namespace都有一份独立的资源，因此不同的进程在各自的Namespace内对同一种资源的使用不会互相干扰。</p></blockquote><p>目前Linux内核总共支持以下6种Namespace：</p><ul><li>IPC：隔离System V IPC和POSIX消息队列。</li><li>Network：隔离网络资源。</li><li>Mount：隔离文件系统挂载点。</li><li>PID：隔离进程ID。</li><li>UTS：隔离主机名和域名。</li><li>User：隔离用户ID和组ID。</li></ul><p>Linux对Namespace的操作，主要是通过clone、setns和unshare这3个系统调用来完成的，clone创建新进程时，接收一个叫flags的参数，这些flag包括<code>CLONE_NEWNS、CLONE_NEWIPC、CLONE_NEWUTS、CLONE_NEWNET（Mount namespace）、CLONE_NEWPID</code>和<code>CLONE_NEWUSER</code>，用于创建新的namespace，这样clone创建出来新进程之后就属于新的namespace了，后续新进程创建的进程默认属于同一namespace。</p><p>如果想要给已存在进程设置新的namespace，可通过unshare函数（<code>long unshare(unsigned long flags)</code>）完成设置，其入参flags表示新的namespace。当想要给已存在进程设置已存在的namespace，可通过setns函数（<code>int setns(int fd, int nstype)</code>）来完成设置，每个进程在procfs目录下存储其相关的namespace信息，可找到已存在的namesapce，然后通过setns设置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# ls -l /proc/10401/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 1月  12 11:36 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure><blockquote><p>上述每个虚拟文件对应该进程所处的namespace，如果其他进程想进入该namespace，open该虚拟文件获取到fd，然后传给setns函数的fd入参即可，注意虚拟文件type和nstype要对应上。</p></blockquote><p><strong>目前Linux内核总共支持以下6种Namespace，分别是IPC、Network、Mount、PID、UTS、User</strong>：</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC也就是进程间通信，Linux下有多种进程间通信，比如socket、共享内存、Posix消息队列和SystemV IPC等，这里的IPC namespace针对的是SystemV IPC和Posix消息队列，其会用标识符表示不同的消息队列，进程间通过找到标识符对应的消息队列来完成通信，IPC namespace做的事情就是相同的标识符在不同namespace上对应不同的消息队列，这样不同namespace的进程无法完成进程间通信。</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Network Namespace隔离网络资源，每个Network Namespace都有自己的网络设备、IP地址、路由表、/proc/net目录、端口号等。每个Network Namespace会有一个loopback设备（除此之外不会有任何其他网络设备）。因此用户需要在这里面做自己的网络配置。IP工具已经支持Network Namespace，可以通过它来为新的Network Namespace配置网络功能。</p><h2 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h2><p>Mount namesapce用户隔离文件系统挂载点，每个进程能看到的文件系统都记录在<code>/proc/$$/mounts</code>里。在创建了一个新的Mount Namespace后，进程系统对文件系统挂载/卸载的动作就不会影响到其他Namespace。</p><h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>PID Namespace用于隔离进程PID号，这样一来，不同的Namespace里的进程PID号就可以是一样的了。当创建一个PID Namespace时，第一个进程的PID号是1，也就是init进程。init进程有一些特殊之处，例如init进程需要负责回收所有孤儿进程的资源。另外，发送给init进程的任何信号都会被屏蔽，即使发送的是SIGKILL信号，也就是说，在容器内无法“杀死”init进程。</p><blockquote><p>注意，但是当用ps命令查看系统的进程时，会发现竟然可以看到host的所有进程：</p></blockquote><p><img src="/2020/01/12/namespace-yuan-li-jie-xi/./namespace原理解析/image-20200112120533738.png" alt></p><blockquote><p>这是因为ps命令是从procfs读取信息的，而procfs并没有得到隔离。虽然能看到这些进程，但由于它们其实是在另一个PID Namespace中，因此无法向这些进程发送信号。</p></blockquote><h2 id="UTS"><a href="#UTS" class="headerlink" title="UTS"></a>UTS</h2><p>UTS Namespace用于对主机名和域名进行隔离，也就是uname系统调用使用的结构体structutsname里的nodename和domainname这两个字段，UTS这个名字也是由此而来的。为什么需要uts namespace呢，因为为主机名可以用来代替IP地址，比如局域网通过主机名访问机器。</p><h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><p>User Namespace用来隔离用户资源，比如一个进程在Namespace里的用户和组ID与它在host里的ID可以不一样，这样可以做到，一个host的普通用户可以在该容器（user namespace）下拥有root权限，但是它的特权被限定在容器内。（容器内的这类root用户，实际上还是有很多特权操作不能执行，基本上如果这个特权操作会影响到其他容器或者host，就不会被允许）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一般namespace都是和cgroup结合来使用的，但是直接操作Namespace和Cgroup并不是很容易，因此docker的出现就显得有必要了，Docker通过Libcontainer来处理这些底层的事情。这样一来，Docker只需要简单地调用Libcontainer的API，就能将完整的容器搭建起来。而作为Docker的用户，就更不用操心这些事情了，只需要通过一两条简单的Docker命令启动容器即可。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码到底需不需要注释</title>
      <link href="/2020/01/06/dai-ma-dao-di-xu-bu-xu-yao-zhu-shi/"/>
      <url>/2020/01/06/dai-ma-dao-di-xu-bu-xu-yao-zhu-shi/</url>
      
        <content type="html"><![CDATA[<p>好的代码需不需要注释，这个问题其实不能直接说需要或者不需要，因为要视情况而定。<strong>如果一段代码功能较为简单且独立，同时代码风格较好，是不需要注释的，因为代码本身已经足够说明其用意了（代码即注释）；如果功能较复杂或者较为抽象，是需要合理注释的，方便他人阅读和快速理解代码逻辑。</strong>那么问题来了，什么是好的注释呢？就是简洁的表述自己当时的思考，即为什么，话句话说：应该表达“我的代码为什么要这么做？”，而不是表达“我的代码做了什么？”。必要的时候可以增加图形化说明，更加具体：</p><p><img src="/2020/01/06/dai-ma-dao-di-xu-bu-xu-yao-zhu-shi/./代码到底需不需要注释/22f5b3423c404643855f8bf6213451b6.jpeg" alt></p><p>关于良好的编程风格，笔者这里推荐一本书：</p><p><img src="/2020/01/06/dai-ma-dao-di-xu-bu-xu-yao-zhu-shi/./代码到底需不需要注释/3cb5f6da97814b6d9b8ee26638090202.jpeg" alt></p><p>记住一句话：</p><blockquote><p>“程序员必须为了让人能阅读代码而书写代码，而机器执行只是顺便的。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cgroup原理解析</title>
      <link href="/2020/01/04/cgroup-yuan-li-jie-xi/"/>
      <url>/2020/01/04/cgroup-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cgroup从2.6.4引入linux内核主线，目前默认已启用该特性。在cgroup出现之前，只能对一个进程做资源限制，比如通过sched_setaffinity设置进程cpu亲和性，使用ulimit限制进程打开文件上限、栈大小等。</p></blockquote><p>cgroups是Linux下控制一个（或一组）进程的资源限制机制，全称是control groups，可以对cpu、内存等资源做精细化控制，比如目前很多的Docker在Linux下就是基于cgroups提供的资源限制机制来实现资源控制的；除此之外，开发者也可以指直接基于cgroups来进行进程资源控制，比如8核的机器上部署了一个web服务和一个计算服务，可以让web服务仅可使用其中6个核，把剩下的两个核留给计算服务。cgroups cpu限制除了可以限制使用多少/哪几个核心之外，还可以设置cpu占用比（注意占用比是各自都跑满情况下的使用比例，如果一个cgroup空闲而另一个繁忙，那么繁忙的cgroup是有可能占满整个cpu核心的）。</p><blockquote><p>本文主要讨论下cgroups概念及原理，然后分析下cgroups文件系统概念，最后对cgroups做个总结，关于cgroups的使用实践可以参考网上资料，这里不再赘述。</p></blockquote><h2 id="cgroups概念"><a href="#cgroups概念" class="headerlink" title="cgroups概念"></a>cgroups概念</h2><p>从实现角度来看，cgroups实现了一个通用的进程分组框架，不同资源的具体管理工作由各cgroup子系统来实现，当需要多个限制策略比如同时针对cpu和内存进行限制，则同时关联多个cgroup子系统即可。</p><h4 id="cgroups子系统"><a href="#cgroups子系统" class="headerlink" title="cgroups子系统"></a>cgroups子系统</h4><p>cgroups为每种资源定义了一个子系统，典型的子系统如下：</p><ul><li><strong>cpu 子系统</strong>，主要限制进程的 cpu 使用率。</li><li><strong>cpuacct 子系统</strong>，可以统计 cgroups 中的进程的 cpu 使用报告。</li><li><strong>cpuset 子系统</strong>，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li><li><strong>memory 子系统</strong>，可以限制进程的 memory 使用量。</li><li><strong>blkio 子系统</strong>，可以限制进程的块设备 io。</li><li><strong>devices 子系统</strong>，可以控制进程能够访问某些设备。</li><li><strong>net_cls 子系统</strong>，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li><li><strong>freezer 子系统</strong>，可以挂起或者恢复 cgroups 中的进程。</li><li><strong>ns 子系统</strong>，可以使不同 cgroups 下面的进程使用不同的 namespace。</li></ul><p>每个子系统都是定义了一套限制策略，它们需要与内核的其他模块配合来完成资源限制功能，比如对 cpu 资源的限制是通过进程调度模块根据 cpu 子系统的配置来完成的；对内存资源的限制则是内存模块根据 memory 子系统的配置来完成的，而对网络数据包的控制则需要 Traffic Control 子系统来配合完成。</p><h2 id="cgroups原理"><a href="#cgroups原理" class="headerlink" title="cgroups原理"></a>cgroups原理</h2><p>关于cgroups原理，可以从进程角度来剖析相关数据结构之间关系，Linux 下管理进程的数据结构是 task_struct，其中与cgrups相关属性如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task_struct代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS </span></span><br><span class="line"><span class="comment">/* Control Group info protected by css_set_lock */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> *<span class="title">cgroups</span>;</span> </span><br><span class="line"><span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>每个进程对应一个css_set结构，css_set存储了与进程相关的cgropus信息。cg_list是一个嵌入的 list_head 结构，用于将连到同一个 css_set 的进程组织成一个链表。进程和css_set的关系是多对一关系，tasks表示关联的多个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span> </span><br><span class="line"><span class="keyword">atomic_t</span> refcount;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_links</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>subsys 是一个指针数组，存储一组指向 cgroup_subsys_state 的指针，通过这个指针进程可以获取到对应的cgroups信息，一个 cgroup_subsys_state 就是进程与一个特定子系统相关的信息，cgroup_subsys_state结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgroup</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> refcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_id</span> *<span class="title">id</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cgroup 指针指向了一个 cgroup 结构，也就是进程属于的 cgroup，进程受到子系统控制就是加入到特定的cgroup来实现的，就是对应这里的cgroup，由此看出进程和cgroup的关系是多对多关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags; </span><br><span class="line"><span class="keyword">atomic_t</span> count; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">parent</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> *<span class="title">root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">top_cgroup</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">css_sets</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">release_list</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pidlists</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">pidlist_mutex</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span> </span><br><span class="line"><span class="keyword">spinlock_t</span> event_list_lock; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sibling、children 和 parent 三个嵌入的 list_head 负责将统一层级的 cgroup 连接成一棵 cgroup 树。subsys 是一个指针数组，存储一组指向 cgroup_subsys_state 的指针。这组指针指向了此 cgroup 跟各个子系统相关的信息，也就是说一个cgroup可以关联多个子系统，二者关系是多对多关系。</p><p>Linux下的cgroups的数据结构图示如下：</p><p><img src="/2020/01/04/cgroup-yuan-li-jie-xi/./cgroup原理解析/image-20200104135253154.png" alt></p><h4 id="cgroups-层级结构"><a href="#cgroups-层级结构" class="headerlink" title="cgroups 层级结构"></a>cgroups 层级结构</h4><p>在cgrups中一个task任务就是一个进程，一个进程可以加入到某个cgroup，也从一个进程组迁移到另一个cgroup。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。多个cgroup形成一个层级结构（树形结构），cgroup树上的子节点cgroup是父节点cgroup的孩子，继承父cgroup的特定的属性。注意：cgroups层级只会关联某个子系统之后才能进行对应的资源控制，一个子系统附加到某个层级以后，这个层级上的所有cgroup都受到这个子系统的控制。cgroup典型应用架构图如下：</p><p><img src="/2020/01/04/cgroup-yuan-li-jie-xi/./cgroup原理解析/img002.png" alt></p><h2 id="cgroups文件系统"><a href="#cgroups文件系统" class="headerlink" title="cgroups文件系统"></a>cgroups文件系统</h2><p>Linux 使用了多种数据结构在内核中实现了 cgroups 的配置，关联了进程和 cgroups 节点，那么 Linux 又是如何让用户态的进程使用到 cgroups 的功能呢？ Linux内核有一个很强大的模块叫 VFS (Virtual File System)。 VFS 能够把具体文件系统的细节隐藏起来，给用户态进程提供一个统一的文件系统 API 接口。 cgroups 也是通过 VFS 把功能暴露给用户态的，cgroups 与 VFS 之间的衔接部分称之为 cgroups 文件系统。通过cgroups适配VFS，用户可以使用VFS接口来操作cgroup功能。</p><blockquote><p>VFS 是一个内核抽象层（通用文件模型），能够隐藏具体文件系统的实现细节，从而给用户态进程提供一套统一的 API 接口。VFS 使用了一种通用文件系统的设计，具体的文件系统只要实现了 VFS 的设计接口，就能够注册到 VFS 中，从而使内核可以读写这种文件系统。 这很像面向对象设计中的抽象类与子类之间的关系，抽象类负责对外接口的设计，子类负责具体的实现。其实，VFS本身就是用 c 语言实现的一套面向对象的接口。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>cgroups是Linux下控制一个（或一组）进程的资源限制机制，cgroup通过关联单个/多个子系统定义了一套限制策略来限制CPU/内存等资源，子系统上限制策略相当于一套配置，需要内核中对应模块配合来完成资源限制功能，比如对 cpu 资源的限制是通过进程调度模块根据 cpu 子系统的配置来完成的等。</p><p>注意cgroups资源限制是针对cgroup为单位的，不管cgroup下是有一个进程还是多个进程。Docker下的容器内所有进程就是属于同一组cgroup管理之下的，比如限制CPU使用，限制内存大小等。</p><p>参考资料：</p><p>1、<a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html</a></p><p>2、<a href="https://tech.meituan.com/2015/03/31/cgroups.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/03/31/cgroups.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令</title>
      <link href="/2019/12/29/docker-ming-ling/"/>
      <url>/2019/12/29/docker-ming-ling/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习Docker，首先需要了解Docker基本概念，然后就开始“动手”了（也就是敲Docker命令）。Docker命令较多，这里笔者总结下常用的Docker命令，方便小伙伴们查阅。</p></blockquote><p>Docker是基于go语言开发，底层技术（Linux下）主要基于cgroups、namespace以及联合文件技术实现的一种进程级别的轻量级虚拟化解决方案。由于Docker进程隔离独立于宿主机上其他进程，因此也称为容器，Docker在容器的基础上，进行了更进一步的封装，从文件系统、网络到进程隔离等，极大简化了容器的创建管理维护工作，降低了开发者使用门槛，因此才在近几年流行开来（毕竟Docker的底层技术在Docker出现之前就已经存在了）。</p><p>Docker命令有2大类，分别是服务端命令和客户端命令，前者是操作docker服务端（dockerd），后者也就是开发者常用的docker命令，更多Docker命令可以使用 <code>docker help</code> 查看。</p><ul><li>客户端命令：基本命令格式为docker [OPTIONS] COMMAND [arg…]；</li><li>服务端命令：基本命令格式为dockerd [OPTIONS]。</li></ul><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p>centos下安装docker可使用命令<code>yum install docker</code>，mac下需要安装docker-for-mac，使用命令 <code>wget http://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/Docker.dmg</code>。安装完成之后可以使用如下命令使用Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service docker start  启动docker服务</span><br><span class="line">docker version/info   查看docker版本/信息</span><br><span class="line">docker inspect  查看容器详细信息</span><br><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; xxxx   查看容器对应的pid</span><br><span class="line">docker logs 查看对应容器日志</span><br></pre></td></tr></table></figure><p>Docker有两个基本概念：镜像和容器，前者是打包后可执行的容器文件，后者是运行中的Docker实例，二者关系类似 <code>可执行文件</code> 和 <code>进程</code> 的概念。</p><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p>镜像相关命令有搜索、查看、删除、存档和加载等，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker images  查看所有本地镜像，或者使用命令 docker image ls</span><br><span class="line">docker search xxx   搜索官方仓库中的镜像</span><br><span class="line">docker pull xxx:tag    下载镜像，也可以使用docker push 推送自己的镜像，docker run xxx命令会启动容器，当本地没有容器镜像是会从仓库中拉取</span><br><span class="line">docker rmi imageName   删除本地一个或多个镜像，注意不要和docker rm删除容器命令混淆</span><br><span class="line">docker rm xxx 删除一个或多个容器</span><br><span class="line">docker <span class="built_in">history</span> ubuntu:18.04  查看Ubuntu镜像的创建过程（各个层内容）</span><br><span class="line">docker save -o ubuntu_18.04.tar ubuntu:18.04   导出镜像到本地文件ubuntu_18.04.tar</span><br><span class="line">docker load -i ubuntu_18.04.tar  加载镜像，或者使用命令 docker &lt; ubuntu_18.04.tar</span><br></pre></td></tr></table></figure><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><p>围绕容器，Docker提供了十分丰富的操作命令，允许用户高效地管理容器的整个生命周期。可以使用<code>docker container help</code>命令查看Docker支持的容器操作子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker ps  列出所有运行中的容器</span><br><span class="line">docker ps -a  列出所有容器，包括停止状态的</span><br><span class="line">docker ps -a -q   列出所有镜像的id</span><br><span class="line">docker rm containerId   删除某一个镜像</span><br><span class="line">docker rm $(docker ps -a -q)  删除所有处于终止状态的容器，注意不能删除正在运行中的容器</span><br><span class="line">docker run -it --rm ubuntu:14:04  bash       -it 这是两个参数，-t是开一个终端（伪终端绑定到容器的标准输入上），-i是交互式命令让容器的标准输入保持打开。--rm是容器退出后删除，默认情况下容器退出不会自动删除，方便排查问题。ubuntu:14:04使用的启动镜像。bash放在镜像后面的命令。执行<span class="built_in">exit</span>命令从容器中退出时，容器会自动退出。有时候需要让容器已后台守护态运行，此时需要增加-d参数，比如docker urn -d ubuntu。</span><br><span class="line">docker run ubuntu  <span class="built_in">echo</span> <span class="string">"hello world"</span>   在docker容器中运行命令输出hello world</span><br><span class="line">docker start containerId   启动处于created状态的容器</span><br><span class="line">docker resetart containerId   重启处于运行状态的容器</span><br><span class="line">docker stop containerId   停止容器运行</span><br><span class="line">docker logs xxx 查看容器xxx输出信息</span><br><span class="line">docker pause  [container]  暂停容器，恢复使用命令docker unpause xxx</span><br><span class="line">docker inspect [container] 查看容器的详细信息，创建时间、路径、状态配置等详细信息。</span><br><span class="line">docker top  [container]   查看容器内进程信息。</span><br><span class="line">docker stats   [container]   查看容器的CPU、内存、网络等统计信息，支持选项有：-a:输出所有统计信息，默认只输出运行中信息；-no-stream:不持续输出，默认会自动更新统计结果。</span><br><span class="line">docker cp zzz.txt 26755872da4d:/tmp：将本地zzz.txt文件复制到容器26755872da4d的/tmp目录下，也可以使用命令将容器内文件复制到本地机器，docker cp 26755872da4d:/tmp/zzz.txt /tmp。</span><br><span class="line">docker container  diff 26755872da4d：container diff命令查看容器内文件系统的变更。</span><br><span class="line">docker container  port 26755872da4d：查看容器端口映射。</span><br><span class="line">docker update --cpus 4 26755872da4d：限定容器使用CPU个数为4</span><br></pre></td></tr></table></figure><p><strong>container update</strong>命令可以更新容器的一些运行时配置，主要是一些资源限制份额。命令格式为docker [container] update [OPTIONS] CONTAINER [CONTAINER…]，支持的操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❑ -blkio-weight uint16：更新块IO限制，10～1000，默认值为0，代表着无限制；</span><br><span class="line">❑ -cpu-period int：限制CPU调度器CFS（Completely Fair Scheduler）使用时间，单位为微秒，最小1000；</span><br><span class="line">❑ -cpu-quota int：限制CPU调度器CFS配额，单位为微秒，最小1000；</span><br><span class="line">❑ -cpu-rt-period int：限制CPU调度器的实时周期，单位为微秒；</span><br><span class="line">❑ -cpu-rt-runtime int：限制CPU调度器的实时运行时，单位为微秒；</span><br><span class="line">❑ -c, -cpu-shares int：限制CPU使用份额；</span><br><span class="line">❑ -cpus decimal：限制CPU个数；</span><br><span class="line">❑ -cpuset-cpus string：允许使用的CPU核，如0-3,0,1；</span><br><span class="line">❑ -cpuset-mems string：允许使用的内存块，如0-3,0,1；</span><br><span class="line">❑ -kernel-memory bytes：限制使用的内核内存；</span><br><span class="line">❑ -m, -memory bytes：限制使用的内存；</span><br><span class="line">❑ -memory-reservation bytes：内存软限制；</span><br><span class="line">❑ -memory-swap bytes：内存加上缓存区的限制，-1表示为对缓冲区无限制；</span><br><span class="line">❑ -restart string：容器退出后的重启策略。</span><br></pre></td></tr></table></figure><h4 id="docker-run参数"><a href="#docker-run参数" class="headerlink" title="docker run参数"></a>docker run参数</h4><p>docker run 启动容器，可以指定参数设置容器启动策略，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d  容器会在后台运行并不会把输出（STDOUT）打印到宿主机上</span><br><span class="line">-t  让docker分配一个伪终端并绑定到容器的标准输入上</span><br><span class="line">-i  让容器的标准输入保持打开</span><br><span class="line">-p 映射本地端口和容器端口，格式为-p ip:hostPort:containerPort或者-p hostPort:containerPort。</span><br><span class="line">-P 大写的P，使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</span><br><span class="line">--rm   在容器执行完毕后将其删除，默认只能删除已停止的容器，如果想要删除正在运行中容器，可增加-f参数。</span><br><span class="line">--name   xxx   执行容器的name</span><br></pre></td></tr></table></figure><p><em>注意，容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</em>。</p><h4 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h4><p><strong>进入容器</strong></p><p>容器运行过程中，常常需要进入容器中执行操作场景，可使用如下命令进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attach：使用命令docker attach containerId/names进入容器，但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。注意，进入容器后，如果使用<span class="built_in">exit</span>退出容器，那么容器也会停止运行，可以使用命令Ctrl+P+Q来退出但不关闭容器。</span><br><span class="line">nsenter：nsenter 启动一个新的shell进程(默认是/bin/bash)，同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限</span><br><span class="line"><span class="built_in">exec</span>：使用<span class="built_in">exec</span>命令更加便捷，docker <span class="built_in">exec</span> -it 775c7c9ee1e1 /bin/bash  ，很方便的进入容器</span><br></pre></td></tr></table></figure><p><strong>导入/导出容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> -o test.tar [container]   将某个容器导出到本地</span><br><span class="line">docker import test.tar  导入某个容器导出文件（容器导出为镜像文件，这里相当于加载镜像文件）。实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker[container] import命令来导入一个容器快照到本地镜像库。这两者的区别在于：容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure><p><strong>端口映射</strong></p><p>在启动容器的时候，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-P或-p参数来指定端口映射。当使用-P（大写的）标记时，Docker会随机映射一个49000～49900的端口到内部容器开放的网络端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">500</span>:<span class="number">5000</span> xxxwebapp python app.py：启动容器并运行python app.py程序，映射本地<span class="number">500</span>端口到容器<span class="number">5000</span>端口。或者使用docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">500</span>:<span class="number">5000</span> xxxwebapp python app.py指定特定地址。</span><br><span class="line">docker run -it --name zzz ubuntu bash</span><br><span class="line">docker run -it --name zzz2 --link zzz:zzz ubuntu bash   zzz2容器和zzz容器建立互联关系。</span><br><span class="line">    --link参数的格式为--link name:alias，其中name是要链接的容器的名称，alias是别名。</span><br><span class="line">    Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射它们的端口到宿主主机上。</span><br><span class="line">    在启动db容器的时候并没有使用-p和-P标记，从而避免了暴露数据库服务端口到外部网络上。</span><br></pre></td></tr></table></figure><p><strong>数据管理</strong></p><p>Docker的数据管理主要分为2种：</p><ul><li>数据卷：容器内数据直接映射到本地；</li><li>数据卷容器：特定容器维护数据卷。</li></ul><p>数据卷（Data Volumes）是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount行为。如果直接挂载一个文件到容器，使用文件编辑工具，包括vi或者sed –in-place的时候，可能会造成文件inode的改变。从Docker 1.1.0起，这会导致报错误信息。所以推荐的方式是直接挂载文件所在的目录到容器内。</p><h3 id="服务端命令"><a href="#服务端命令" class="headerlink" title="服务端命令"></a>服务端命令</h3><p>dockerd命令负责启动服务端主进程，支持的命令选项如下表所示：</p><p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123704525.png" alt></p><p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123752366.png" alt></p><p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123800615.png" alt></p><h3 id="Docker命令图谱"><a href="#Docker命令图谱" class="headerlink" title="Docker命令图谱"></a>Docker命令图谱</h3><p>最后来一张Docker图谱作为结尾吧：</p><p><img src="/2019/12/29/docker-ming-ling/./Docker命令/image-20191229123859256.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地执行dubbo&quot;单测&quot;</title>
      <link href="/2019/12/21/ru-he-you-ya-di-zhi-xing-dubbo-dan-ce/"/>
      <url>/2019/12/21/ru-he-you-ya-di-zhi-xing-dubbo-dan-ce/</url>
      
        <content type="html"><![CDATA[<p>很多小伙伴所在的公司是基于Dubbo来构建技术栈的，日常开发中必不可少要写dubbo单测（单元测试），如果单测数据依赖已有的外部dubbo服务，一般是mock数据，如果数据比较复杂，其实mock数据也是一个不小的工作量。那有没有更好的单测方式来代替我们完成”mock“数据功能呢，这时可以借助dubbo telnet功能，获取真实数据用在单测中使用。</p><blockquote><p>本文会先讨论如何使用基于dubbo telnet的代理工具类（DubboTelnetProxy），然后再讨论下mockito+DubboTelnetProxy如何进行多层次的单测，最后分析下如何让单测变得更加智能（比如自动注入等）。（<em>ps：关于dubbo和mockito这里就不展开讨论了，具体可以参考对应资料~</em>）</p></blockquote><h2 id="1-Dubbo单测现状"><a href="#1-Dubbo单测现状" class="headerlink" title="1 Dubbo单测现状"></a>1 Dubbo单测现状</h2><p>dubbo单测其实和非dubbo单测的流程是一样的，初始化待测试类和单测上下文，打桩然后调用，最后检查返回结果。比如我们常用mockito来跑单测，其简单的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAppContextFilterTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DubboAppContextFilter filter = <span class="keyword">new</span> DubboAppContextFilter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanUpAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanUpAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInvokeApplicationKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Invoker invoker = mock(Invoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Invocation invocation = mock(Invocation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        URL url = URL.valueOf(<span class="string">"test://test:111/test?application=serviceA"</span>);</span><br><span class="line">        when(invoker.getUrl()).thenReturn(url);</span><br><span class="line"></span><br><span class="line">        filter.invoke(invoker, invocation);</span><br><span class="line">        verify(invoker).invoke(invocation);</span><br><span class="line"></span><br><span class="line">        String application = RpcContext.getContext().getAttachment(DubboUtils.SENTINEL_DUBBO_APPLICATION_KEY);</span><br><span class="line">        assertEquals(<span class="string">"serviceA"</span>, application);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码copy于sentinel的单元测试代码。</p></blockquote><h2 id="2-DubboTelnetProxy"><a href="#2-DubboTelnetProxy" class="headerlink" title="2 DubboTelnetProxy"></a>2 DubboTelnetProxy</h2><p>在dubbo服务机器上，我们可以使用telnet连接dubbo服务，然后执行invoke命令来手动调用dubbo接口并获取结果，DubboTelnetProxy就是将这一系列的手动操作按照dubbo telnet格式固化到代码中。在具体讨论DubboTelnetProxy之前，先看下其有哪些功能，DubboTelnetProxy特点：</p><ul><li>基于telnet的dubbo代理工具类，可用于本地单测中；</li><li>直接使用telnet指定ip+port进行连接，无需更多的dubbo相关配置，使用便捷；</li><li>可动态配置ip+port信息。</li></ul><p>话不多说，先看下<code>DubboTelnetProxy</code>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTelnetProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] params, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TelnetClient telnetClient = <span class="keyword">new</span> TelnetClient();</span><br><span class="line">        telnetClient.setConnectTimeout((<span class="keyword">int</span>) TimeUnit.SECONDS.toMillis(<span class="number">5</span>));</span><br><span class="line">        telnetClient.connect(ip, port);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = telnetClient.getInputStream();</span><br><span class="line">            PrintStream out = <span class="keyword">new</span> PrintStream(telnetClient.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 发送dubbo telnet请求</span></span><br><span class="line">            StringBuffer request = <span class="keyword">new</span> StringBuffer(<span class="string">"invoke "</span>);</span><br><span class="line">            request.append(method.getDeclaringClass().getTypeName()).append(<span class="string">"."</span>);</span><br><span class="line">            request.append(method.getName()).append(<span class="string">"("</span>);</span><br><span class="line">            request.append(StringUtils.join(Arrays.stream(params).map(JSON::toJSONString).collect(Collectors.toList()), <span class="string">","</span>)).append(<span class="string">")"</span>);</span><br><span class="line">            out.println(request.toString());</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 结果处理</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">            String result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> (!result.contains(StringUtils.LF) &amp;&amp; (len = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result += <span class="keyword">new</span> String(ArrayUtils.subarray(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">            result = StringUtils.substringBefore(result, StringUtils.LF);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(result) || !result.startsWith(<span class="string">"&#123;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 反序列化</span></span><br><span class="line">            <span class="keyword">return</span> JSON.parseObject(result, method.getGenericReturnType());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            telnetClient.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mockDubboIpPortFormat：配置格式为  -Dmock.dubbo.%s=127.0.0.1:8080，%s为当前dubbo接口的名字，class.getSimpleName()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String mockDubboIpPortPrefix = <span class="string">"mock.dubbo."</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String mockDubboIpPortFormat = mockDubboIpPortPrefix + <span class="string">"%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo telnet建造者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> Integer DEFAULT_PORT = <span class="number">20880</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建dubbo telnet代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enhance(clazz, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhance</span><span class="params">(Class&lt;T&gt; clazz, String ip)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enhance(clazz, ip, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhance</span><span class="params">(Class&lt;T&gt; clazz, Integer port)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enhance(clazz, <span class="keyword">null</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhance</span><span class="params">(Class&lt;T&gt; object, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 优先尝试从properties解析ip:port配置</span></span><br><span class="line">            String ipPort = System.getProperties().getProperty(String.format(mockDubboIpPortFormat, object.getSimpleName()));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(ipPort)) &#123;</span><br><span class="line">                String[] array = StringUtils.split(ipPort, <span class="string">","</span>);</span><br><span class="line">                ip = array[<span class="number">0</span>];</span><br><span class="line">                port = Integer.valueOf(array[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(object);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> DubboTelnetProxy(ObjectUtils.defaultIfNull(ip, DEFAULT_IP), ObjectUtils.defaultIfNull(port, DEFAULT_PORT)));</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboTelnetProxy的实现原理是使用cglib生成dubbo facade接口代理类，然后在代理类按照dubbo telnet格式拼接请求参数，最后获取返回结果并反序列化返回给应用程序。上述代码不足点是：目前每次dubbo调用都会新建telnet连接，对于单测来说是OK的，后续如果用于本地压测或者调用频繁测试场景，考虑复用连接或者使用netty client bootstrap方式避免每次都新建连接。</p><h3 id="2-1-使用示例"><a href="#2-1-使用示例" class="headerlink" title="2.1 使用示例"></a>2.1 使用示例</h3><p>手动/自动指定dubbo服务IP地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// OrderQueryService为dubbo服务的一个API接口</span></span><br><span class="line">  System.setProperty(<span class="string">"mock.dubbo.OrderQueryService"</span>, <span class="string">"127.0.0.1:20880"</span>);</span><br><span class="line"></span><br><span class="line">  OrderQueryService orderQueryService1 = DubboTelnetProxy.Builder.enhance(OrderQueryService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  OrderQueryService orderQueryService2 = DubboTelnetProxy.Builder.enhance(OrderQueryService.class, "127.0.0.1");</span><br><span class="line">  OrderQueryService orderQueryService3 = DubboTelnetProxy.Builder.enhance(OrderQueryService.class, "127.0.0.1", 20880);</span><br><span class="line"></span><br><span class="line">  OrderDTO result = orderQueryService1.query(<span class="string">"订单号"</span>);</span><br><span class="line">  System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-DubboTelnetProxy-mockito自动注入"><a href="#3-DubboTelnetProxy-mockito自动注入" class="headerlink" title="3 DubboTelnetProxy + mockito自动注入"></a>3 DubboTelnetProxy + mockito自动注入</h2><p>日常开发中，可以使用mockito进行单测，保证代码质量。在mockito中，如果想让某个DubboTelnetProxy代理类注入到待测试中，可使用FieldUtils工具类进行属性注入。</p><p>使用DubboTelnetProxy + mockito示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DemoServiceClientTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    DemoServiceClient demoServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        FieldUtils.writeField(demoServiceClient, <span class="string">"demoServiceFacade"</span>,</span><br><span class="line">                DubboTelnetProxy.Builder.enhance(DemoServiceFacade<span class="class">.<span class="keyword">class</span>), <span class="title">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用远程服务，DubboTelnetProxy方式</span></span><br><span class="line">        demoServiceClient.hello(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要打桩，则使用Mock类</span></span><br><span class="line">        DemoServiceFacade demoServiceFacade = Mockito.mock(DemoServiceFacade<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Mockito.when(demoServiceFacade.hello(<span class="string">"world"</span>)).thenReturn(<span class="string">"zzz"</span>);</span><br><span class="line">        FieldUtils.writeField(demoServiceClient, <span class="string">"demoServiceFacade"</span>, demoServiceFacade, <span class="keyword">true</span>);</span><br><span class="line">        Assert.assertEquals(demoServiceClient.hello(<span class="string">"world"</span>), <span class="string">"zzz"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DemoServiceFacade demoServiceFacade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String world)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoServiceFacade.hello(world);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dubbo api</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoServiceFacade</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String world)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-如何自动注入"><a href="#3-1-如何自动注入" class="headerlink" title="3.1 如何自动注入"></a>3.1 如何自动注入</h3><p>要实现DubboTelnetProxy的自动注入，首先判断出来待测试类中的哪些属性需要构造DubboTelnetProxy或者对应实例，一般情况下如果属性是非本工程内的接口类型，就可以认为是dubbo api接口，进行构造DubboTelnetProxy并注入；如果属性是本工程内的接口类型，则在本工程内查找对应的实现类进行反射方式的属性注入（可使用org.reflections包中的Reflections工具类来获取接口下所有实现类）；如果属性是普通类，则直接反射构建对象注入即可，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的dubbo属性构造器，如果是非本工程内属性类型并且是接口类型，直接进行DubboTelnetProxy构建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Function&lt;Field, Object&gt; DEFAULT_DUBBO_FC = field -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> Objects.nonNull(targetContext.get());</span><br><span class="line">        Class fieldClass = field.getType();</span><br><span class="line">        <span class="keyword">if</span> (fieldClass.isInterface()) &#123;</span><br><span class="line">            <span class="comment">// 本工程内的加载其实现类，非本工程内的按照DubboTelnetProxy构建</span></span><br><span class="line">            <span class="keyword">if</span> (!isSameProjectPath(targetContext.get().getClass(), fieldClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> DubboTelnetProxy.Builder.enhance(fieldClass);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldClass.getSimpleName().endsWith(<span class="string">"Dao"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mockito.mock(fieldClass);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String packagePath = fieldClass.getPackage().getName() + <span class="string">".impl."</span>;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(packagePath + fieldClass.getSimpleName() + <span class="string">"Impl"</span>).newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameProjectPath(targetContext.get().getClass(), fieldClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> fieldClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非工程内的类直接mock掉</span></span><br><span class="line">            <span class="keyword">return</span> Mockito.mock(fieldClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">"DEFAULT_DUBBO_FC 发生异常 field="</span> + field);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对待注入类有多个层次，比如测试类A中属性b类型是B，B中属性c类型是C等，那么在自动注入类A的所有属性时，需要递归进行，直至所有子类型的属性都构建完毕，示例伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFieldsInternal</span><span class="params">(@NonNull Object target, @Nullable Function&lt;Field, Object&gt; fc, @Nullable Boolean recursive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !(target <span class="keyword">instanceof</span> Class);</span><br><span class="line">    <span class="comment">// 默认fc回调直接调用默认无参构造方法</span></span><br><span class="line">    fc = ObjectUtils.defaultIfNull(fc, DEFAULT_FC);</span><br><span class="line">    recursive = ObjectUtils.defaultIfNull(recursive, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Object finalTarget = target;</span><br><span class="line">        Function&lt;Field, Object&gt; finalFc = fc;</span><br><span class="line">        ReflectionUtils.doWithFields(finalTarget.getClass(), field -&gt; &#123;</span><br><span class="line">            Object value = finalFc.apply(field));</span><br><span class="line">            DubboReflectionUtils.setField(finalTarget, field, value);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(value) &amp;&amp; DEFAULT_FF.matches(field)) &#123;</span><br><span class="line">                fieldList.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, filterField -&gt; &#123;</span><br><span class="line">            <span class="comment">// 默认只注入非基本类型并且为null的属性</span></span><br><span class="line">            <span class="keyword">return</span> DEFAULT_FF.matches(filterField) &amp;&amp; DubboReflectionUtils.isNullFieldValue(finalTarget, filterField);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">while</span> (recursive &amp;&amp; !fieldList.isEmpty() &amp;&amp; Objects.nonNull(target = fieldList.remove(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-如何让自动注入更易用"><a href="#3-2-如何让自动注入更易用" class="headerlink" title="3.2 如何让自动注入更易用"></a>3.2 如何让自动注入更易用</h3><p>上述示例中的自动注入是程序会递归注入待测试类中的所有属性，但还是需要在代码中先调用要”自动注入”的代码，为了更易用，可以使用注解方式来自动注入被注解修饰的所有类或者属性，类似于在Spring中对类属性配置了<code>@Resource</code>之后，Spring在容器启动过程中会自动对该属性注入对应示例，开发者无需关注。</p><blockquote><p>关于如何实现mockito+DubboTelnetProxy的注解方式自动注入，笔者就不在赘述，感兴趣的小伙伴可以参考3.1中的实现思路自行实现。</p></blockquote><p>说道注解，其实想实现针对某些注解执行一些特定逻辑（比如执行自动注入），可以在两种阶段对其处理，如下所示：</p><ul><li>编译处理阶段：比如设置Java的注解处理器，一般是继承<code>AbstractProcessor</code>来实现特定业务逻辑，其主要的处理逻辑就是扫描、评估和处理注解的代码，以及生产 Java 文件。比如lombok中的<code>@Setter</code>注解就是要产生对应属性的setter方法；</li><li>容器启动阶段：这里的容器是业务程序自己定义的容器，比如Spring的IoC容器，在容器启动过程中针对注解进行处理，首先获取注解对应的属性，然后从容器中获取属性对应的实例通过反射将其注入即可。</li></ul><p>以上两种自动注入方式在实现都是OK的，前者在编译阶段后者在运行时，不过后者由于在运行时起作用，因此灵活性更大。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty ByteBuf机制</title>
      <link href="/2019/11/30/netty-bytebuf-ji-zhi/"/>
      <url>/2019/11/30/netty-bytebuf-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>缓冲区在计算机世界中随处可见，内存中的多级缓冲区，io设备的缓冲区等等，还有我们经常用的内存队列，分布式队列等等。缓冲区，平衡了数据产生方和数据消费方的处理效率差异，提高了数据处理性能。</p></blockquote><p>JDK为了解决网络通信中的数据缓冲问题，提供了ByteBuffer（heap或者直接内存缓存）来解决缓存问题，通过缓冲区来平衡网络io和CPU之间的速度差异，等待缓冲区积累到一定量的数据再统一交给CPU去处理，从而提升了CPU的资源利用率。</p><p>Netty 使用 reference-counting(引用计数)来判断何时可以释放 ByteBuf 或 ByteBufHolder 和其他相关资源，从而可以利用池和其他技巧来提高性能和降低内存消耗。这一点上不需要开发人员做任何事情，但是在开发 Netty 应用程序时，尤其是使用 ByteBuf 和 ByteBufHolder时，你应该尽可能早地释放池资源。 Netty 缓冲 API 有以下几个优势：</p><ul><li>可以自定义缓冲类型</li><li>通过一个内置的复合缓冲类型实现零拷贝</li><li>扩展性好，比如 StringBuilder</li><li>不需要调用 flip() 来切换读/写模式</li><li>读取和写入索引分开</li><li>方法链</li><li>引用计数</li><li>Pooling(池)</li></ul><h2 id="ByteBuf-字节数据容器"><a href="#ByteBuf-字节数据容器" class="headerlink" title="ByteBuf 字节数据容器"></a>ByteBuf 字节数据容器</h2><p>写入数据到 ByteBuf 后，<code>writerIndex</code>（写入索引） 增加写入的字节数。读取字节后，<code>readerIndex</code>（读取索引） 也增加读取出的字节数。你可以读取字节，直到写入索引和读取索引处在相同的位置，此时ByteBuf不可读，所以下一次读操作将会抛出<code>IndexOutOfBoundsException</code>，就像读取数组时越位一样。</p><p>调用 ByteBuf 的以 “read” 或 “write” 开头的任何方法都将自动增加相应的索引（默认capaticy增加为原来的2倍）。另一方面，”set” 、 “get”操作字节将不会移动索引位置，它们只会在指定的相对位置上操作字节。可以给ByteBuf指定一个最大容量值，这个值限制着ByteBuf的容量。任何尝试将写入超过这个值的数据的行为都将导致抛出异常。ByteBuf 的默认最大容量限制是Integer.MAX_VALUE。</p><p>ByteBuf 类似于一个字节数组，最大的区别是读和写的索引可以用来控制对缓冲区数据的访问。下图显示了一个容量为16的空的 ByteBuf 的布局和状态，writerIndex 和 readerIndex 都在索引位置 0 ：</p><p><img src="/2019/11/30/netty-bytebuf-ji-zhi/./Netty ByteBuf机制/image-20191130145824734.png" alt><br>ByteBuf可以基于heap buffer，也可以基于direct buffer。使用direct buffer，通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。DirectBuffer 在<code>-XX:MaxDirectMemorySize=xxM</code> 大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”，也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响。关于堆外内存详细讨论可参考：<a href="https://www.cnkirito.moe/nio-buffer-recycle。" target="_blank" rel="noopener">https://www.cnkirito.moe/nio-buffer-recycle。</a></p><blockquote><p>注意：使用完ByteBuf之后，一定要release，否则会造成内存泄漏。区分ByteBuf底层是heap buffer还是direct buffer，可以根据ByteBuf.hasArray()来判断，因为heap buffer返回true（heap上的ByteBuffy底层实现就是byte[] 数组），direct buffer返回false。</p></blockquote><h2 id="复合缓冲区-COMPOSITE-BUFFER"><a href="#复合缓冲区-COMPOSITE-BUFFER" class="headerlink" title="复合缓冲区 COMPOSITE BUFFER"></a>复合缓冲区 COMPOSITE BUFFER</h2><p>复合缓冲区是多个ByteBuf组合的视图，复合缓冲区就像一个列表，我们可以动态的添加和删除其中的 ByteBuf，JDK的 ByteBuffer 没有这样的功能。Netty 提供了 ByteBuf 的子类 CompositeByteBuf 类来处理复合缓冲区。</p><blockquote><p>注意：CompositeByteBuf只是一个视图，CompositeByteBuf.hasArray() 总是返回 false，因为它可能既包含堆缓冲区，也包含直接缓冲区。</p></blockquote><p>例如，一条消息由 header 和 body 两部分组成，将 header 和 body 组装成一条消息发送出去，可能 body 相同，只是 header 不同，使用CompositeByteBuf 就不用每次都重新分配一个新的缓冲区。下图显示CompositeByteBuf 组成 header 和 body：</p><p><img src="/2019/11/30/netty-bytebuf-ji-zhi/./Netty ByteBuf机制/image-20191130152256854.png" alt><br>CompositeByteBuf使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf1 = UnpooledByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">ByteBuf byteBuf2 = UnpooledByteBufAllocator.DEFAULT.heapBuffer();</span><br><span class="line"> </span><br><span class="line">byteBuf1.writeByte(<span class="number">1</span>);</span><br><span class="line">byteBuf2.writeByte(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class="line">compositeByteBuf.addComponent(byteBuf1);</span><br><span class="line">compositeByteBuf.addComponent(byteBuf2);</span><br><span class="line">System.out.println(compositeByteBuf.getByte(<span class="number">0</span>));</span><br><span class="line">System.out.println(compositeByteBuf.getByte(<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">ByteBuf allByteBuf = Unpooled.wrappedBuffer(byteBuf1, byteBuf2);</span><br><span class="line">System.out.println(allByteBuf.getByte(<span class="number">0</span>));</span><br><span class="line">System.out.println(allByteBuf.getByte(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="Netty-Buffer"><a href="#Netty-Buffer" class="headerlink" title="Netty Buffer"></a>Netty Buffer</h2><p>ByteBuf 是Netty中主要用来数据byte[]的封装类，主要分为<code>Heap ByteBuf</code>和<code>Direct ByteBuf</code>。为了减少内存的分配回收以及产生的内存碎片，Netty提供了<code>PooledByteBufAllocator</code>用来分配可回收的ByteBuf，可以把<code>PooledByteBufAllocator</code>看做一个池子，需要的时候从里面获取ByteBuf，用完了放回去，以此提高性能。当然与之对应的还有 <code>UnpooledByteBufAllocator</code>，顾名思义Unpooled就是不会放到池子里，所以根据该分配器分配的ByteBuf，不需要放回池子由JVM自己GC回收。</p><p>在netty中，根据ChannelHandlerContext 和 Channel获取的Allocator默认都是Pooled，所以需要在合适的时机对其进行释放，避免造成内存泄漏。Netty默认会在ChannelPipline的最后添加一个tail handler帮你完成ByteBuf的release。</p><p>在传递过程中自己通过Channel或ChannelHandlerContext创建的但是没有传递下去的ByteBuf也要手动释放。为了帮助你诊断潜在的泄漏问题，netty提供了<code>ResourceLeakDetector</code>，该类会采样应用程序中%1的buffer分配，并进行跟踪，不过不用担心这个开销很小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line"> </span><br><span class="line">    System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    <span class="comment">// 调用ctx.write(msg)不必手动释放了，Netty会自行作释放操作，但是如果调用</span></span><br><span class="line">    <span class="comment">// ctx.write()两次或者调用ctx.write后又将该msg传递到了TailContext了，则就会报异常</span></span><br><span class="line">    ctx.write(msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    </span><br><span class="line">    ByteBuf result = ctx.channel().alloc().buffer();</span><br><span class="line">    result.writeBytes(in.toString(CharsetUtil.UTF_8).getBytes(CharsetUtil.UTF_8));</span><br><span class="line">    ctx.write(result);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// msg对应的ByteBuf释放工作交给TailChannel来做</span></span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    </span><br><span class="line">    ByteBuf result = ctx.channel().alloc().buffer();</span><br><span class="line">    result.writeBytes(in.toString(CharsetUtil.UTF_8).getBytes(CharsetUtil.UTF_8));</span><br><span class="line">    ctx.write(result);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 手工释放ByteBuf</span></span><br><span class="line">    in.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p>1、<a href="https://www.cnkirito.moe/nio-buffer-recycle/" target="_blank" rel="noopener">https://www.cnkirito.moe/nio-buffer-recycle/</a></p><p>2、<a href="https://www.zhihu.com/question/57374068/answer/152691891" target="_blank" rel="noopener">https://www.zhihu.com/question/57374068/answer/152691891</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 入门</title>
      <link href="/2019/11/30/netty-ru-men/"/>
      <url>/2019/11/30/netty-ru-men/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Netty是Java领域有名的开源网络库，特点是高性能和高扩展性，因此很多流行的框架都是基于它来构建的，比如我们熟知的Dubbo、Rocketmq、Hadoop等，针对高性能RPC，一般都是基于Netty来构建，比如sock-bolt。总之一句话，Java小伙伴们需要且有必要学会使用Netty并理解其实现原理。</p></blockquote><p>netty旨在为可维护的高性能、高可扩展性协议服务器和客户端的快速开发提供异步事件驱动的网络应用程序框架和工具。换句话说，Netty是一个NIO客户端服务器框架，可以快速轻松地开发协议服务器和客户端等网络应用程序。它极大地简化并简化了TCP和UDP套接字服务器开发等网络编程。</p><blockquote><p>学习netty原理细节，看netty源码是必不可少的，那首先来看下如何编译源码：</p><ol><li>从github下载netty 4.x源码 </li><li>如果缺少XxxObjectHashMap类，这些类是在编译时自动生成的，可以执行mvn clean install或者cd common &amp;&amp; mvn clean install命令即可。</li><li>打开idea，开启源码阅读之旅 :)</li></ol></blockquote><p>除了看源码，可以结合一些书籍来看，学习效果更好。关于Netty的书籍，笔者这里推荐一本 李林锋 写的《Netty权威指南》，这本书对于Netty的基础概念和NIO部分讲解的还是不错的，不过有点地方感觉有点贴代码凑字数嫌疑，整体来说还算不错。</p><p><img src="/2019/11/30/netty-ru-men/./Netty 入门/s27294185.jpg" alt></p><h2 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty"></a>什么是Netty</h2><p>Netty是一个事件驱动的高性能Java网络库，是一个隐藏了背后复杂性而提供一个易于使用的API的客户端/服务端框架。Netty以其高性能和可扩展性，使开发者专注于真正感兴趣的地方。它的一个主要目标就是促进“关注点分离”：<strong>使业务逻辑从网络基础设施应用程序中分离</strong>。</p><blockquote><p> 不仅仅是Netty框架，其他框架的设计目的也大都是为了使业务程序和底层技术解耦，使程序员更加专注于业务逻辑实现，提高开发质量和效率。Netty为什么性能如此之高，主要是其内部的Reactor模型机制。</p></blockquote><h3 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h3><ul><li><strong>Bootstrap和ServerBootstrap</strong>：Netty应用程序通过设置bootstrap引导类来完成，该类提供了一个用于应用程序网络层配置的容器。Bootstrap服务端的是ServerBootstrap，客户端的是Bootstrap。</li><li><strong>Channel</strong>：Netty 中的接口 Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。</li><li><strong>ChannelHandler</strong>：ChannelHandler 支持很多协议，并且提供用于数据处理的容器，ChannelHandler由特定事件触发， 常用的一个接口是ChannelInboundHandler，该类型处理入站读数据（socket读事件）。</li><li><strong>ChannelPipeline</strong>：ChannelPipeline 提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动。每个 Channel 都有自己的ChannelPipeline，当 Channel 创建时自动创建的。 下图说明了ChannelHandler和ChannelPipeline二者的关系：</li></ul><p><img src="/2019/11/30/netty-ru-men/./Netty 入门/image-20191104231123434.png" alt></p><ul><li><strong>EventLoop</strong>：EventLoop 用于处理 Channel 的 I/O 操作。一个单一的 EventLoop通常会处理多个 Channel 事件。一个 EventLoopGroup 可以含有多于一个的 EventLoop 和 提供了一种迭代用于检索清单中的下一个。</li><li><strong>ChannelFuture</strong>：Netty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后获取它的结果。出于这个目的，Netty 提供了接口 ChannelFuture,它的 addListener 方法</li></ul><p>Netty 是一个非阻塞、事件驱动的网络框架。Netty 实际上是使用 Threads（ 多线程） 处理 I/O事件的，对于熟悉多线程编程的读者可能会需要关注同步代码。这样的方式不好，因为同步会影响程序的性能，Netty 的设计保证程序处理事件不会有同步。因为某个Channel事件是被添加到一个EventLoop中的，以后该Channel事件都是由该EventLoop来处理的，而EventLoop是一个线程来处理的，也就是说Netty不需要同步IO操作，EventLoop与EventLoopGroup的关系可以理解为线程与线程池的关系一样。</p><h3 id="Buffer（缓冲）"><a href="#Buffer（缓冲）" class="headerlink" title="Buffer（缓冲）"></a>Buffer（缓冲）</h3><p>ByteBuf是字节数据的容器，所有的网络通信都是基于底层的字节流传输，ByteBuf 是一个很好的经过优化的数据容器，我们可以将字节数据有效的添加到 ByteBuf 中或从 ByteBuf 中获取数据。为了便于操作，ByteBuf 提供了两个索引：一个用于读，一个用于写。我们可以按顺序读取数据，也可以通过调整读取数据的索引或者直接将读取位置索引作为参数传递给get方法来重复读取数据。</p><p><strong>ByteBuf使用模式</strong></p><p><strong>堆缓冲区ByteBuf</strong>将数据存储在 JVM 的堆空间，这是通过将数据存储在数组的实现。堆缓冲区可以快速分配，当不使用时也可以快速释放。它还提供了直接访问数组的方法，通过 ByteBuf.array() 来获取 byte[]数据。 </p><p>堆缓冲区ByteBuf使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf heapBuf = ...;</span><br><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] array = heapBuf.array();</span><br><span class="line">    <span class="keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();</span><br><span class="line">    <span class="keyword">int</span> length = heapBuf.readableBytes();</span><br><span class="line">    handleArray(array, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接缓冲区ByteBuf，</strong>在 JDK1.4 中被引入 NIO 的ByteBuffer 类允许 JVM 通过本地方法调用分配内存，其目的是通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。DirectBuffer 在<code>-XX:MaxDirectMemorySize=xx</code>M大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”，也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响。</p><h3 id="Netty示例代码"><a href="#Netty示例代码" class="headerlink" title="Netty示例代码"></a>Netty示例代码</h3><p>了解了Netty基础概念之后，一起看下Netty的使用示例，下面以TCP server、TCP client、http server为例，由于示例代码不难，所以不再赘述，直接上代码。</p><h4 id="TCP-Server"><a href="#TCP-Server" class="headerlink" title="TCP Server"></a>TCP Server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        boot.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">localAddress</span>(8080)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> EchoHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// start</span></span><br><span class="line">        ChannelFuture future = boot.bind().sync();</span><br><span class="line">        future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP-client"><a href="#TCP-client" class="headerlink" title="TCP client"></a>TCP client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        b.group(group)</span><br><span class="line">        .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline p = ch.pipeline();</span><br><span class="line">                <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Start the client.</span></span><br><span class="line">        ChannelFuture f = b.connect(<span class="string">"localhost"</span>, <span class="number">8081</span>).sync();</span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf message;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message = Unpooled.buffer(<span class="number">256</span>);</span><br><span class="line">        message.writeBytes(<span class="string">"hello netty"</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(((ByteBuf) msg).toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty client端在什么时候将channel注册到selector上的呢？是在创建channel之后，就注册到selector的，相关代码在initAndRegister方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建(netty自定义)Channel实例，并初始化</span></span><br><span class="line">        <span class="comment">// channel为 NioServerSocketChannel 实例,NioServerSocketChannel的父类AbstractNioChannel保存有nio的ServerSocketChannel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向Selector注册channel</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are here and the promise is not failed, it's one of the following cases:</span></span><br><span class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">    <span class="comment">//    added to the event loop's task queue for later execution.</span></span><br><span class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now:</span></span><br><span class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initAndRegister之后会执行connect动作，注意，真正的channel.connect动作是由NioEventLoop线程来完成的，当连接三次握手完成之后，会触发该channel的ACCEPT事件，也就是NIOEventLoop中处理事件的流程。</p><h4 id="Http-server"><a href="#Http-server" class="headerlink" title="Http server"></a>Http server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        boot.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">localAddress</span>(8080)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline()</span><br><span class="line">                            .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">                            .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder())</span><br><span class="line">                            .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>))</span><br><span class="line">                            .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// start</span></span><br><span class="line">        ChannelFuture future = boot.bind().sync();</span><br><span class="line">        future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(<span class="string">"hello netty"</span>.getBytes()));</span><br><span class="line"> </span><br><span class="line">        HttpHeaders heads = response.headers();</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN + <span class="string">"; charset=UTF-8"</span>);</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes()); <span class="comment">// 3</span></span><br><span class="line">        heads.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line"> </span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 启动流程</title>
      <link href="/2019/11/30/netty-qi-dong-liu-cheng/"/>
      <url>/2019/11/30/netty-qi-dong-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>Netty的启动流程(<code>ServerBootstrap</code>)，就是创建<code>NioEventLoopGroup</code>（内部可能包含多个NioEventLoop，每个eventLoop是一个线程，内部包含一个FIFO的taskQueue和Selector）和ServerBootstrap实例，并进行bind的过程（bind流程涉及到channel的创建和注册），之后就可以对外提供服务了。</p><p>Netty的启动流程中，涉及到多个操作，比如register、bind、注册对应事件等，为了不影响main线程执行，这些工作以task的形式提交给NioEventLoop，由NioEventLoop来执行这些task，也就是register、bind、注册事件等操作。</p><p>NioEventLoop（准确来说是<code>SingleThreadEventExecutor</code>）中包含了<code>private volatile Thread thread</code>，该thread变量的初始化是在new的线程第一次执行run方式时才赋值的，这种形式挺新颖的。</p><p><img src="/2019/11/30/netty-qi-dong-liu-cheng/./Netty 启动流程/image-20191110185403893.png" alt><br>Netty启动流程图如下所示：</p><p><img src="/2019/11/30/netty-qi-dong-liu-cheng/./Netty 启动流程/image-20191110185750102.png" alt><br>大致了解了Netty启动流程之后，下面就按照Netty启动流程中涉及到的源码来进行分析。</p><blockquote><p> netty启动流程分为server端和client端，不同之处就是前者监听端口，对外提供服务（socket-&gt;bind-&gt;listen操作），对应类ServerBootstrap；后者主动去连接远端端口（socket-&gt;connect），对应类Bootstrap。</p></blockquote><h2 id="server端启动流程"><a href="#server端启动流程" class="headerlink" title="server端启动流程"></a>server端启动流程</h2><p>server端启动流程可以理解成创建ServerBootstrap实例的过程，就以下面代码为例进行分析（echo服务）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// bossGroup处理connect事件</span></span><br><span class="line">        <span class="comment">// workerGroup处理read/write事件</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">             .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">             .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">             .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="comment">// 当连接建立后（register到childWorkerGroup前）初始化channel.pipeline</span></span><br><span class="line">                     ch.pipeline().addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventLoopGroup创建"><a href="#EventLoopGroup创建" class="headerlink" title="EventLoopGroup创建"></a>EventLoopGroup创建</h3><p>EventLoopGroup中可能包含了多个EventLoop，EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理客户端请求和内部任务，内部任务如ServerSocketChannel注册和ServerSocket绑定操作等。关于NioEventLoop，后续专门写一篇文章分析，这里就不再展开，只需知道个大概即可，其架构图如下：</p><p><img src="/2019/11/30/netty-qi-dong-liu-cheng/./Netty 启动流程/image-20191110190059126.png" alt><br>EventLoopGroup创建本质就是创建多个NioEventLoop，这里创建NioEventLoop就是初始化一个Reactor，包括selector和taskQueue。主要逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建NioEventLoop实例</span></span><br><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"><span class="comment">// 初始化NioEventLoop,实际调用的是NioEventLoopGroup.newChild方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">children[i] = newChild(executor, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个NioEventLoop中选择策略</span></span><br><span class="line">chooser = chooserFactory.newChooser(children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line"><span class="comment">// 创建taskQueue</span></span><br><span class="line"><span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line"><span class="comment">// 是不是很熟悉，java nio selector操作</span></span><br><span class="line">provider = selectorProvider;</span><br><span class="line"><span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">selector = selectorTuple.selector;</span><br><span class="line">unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventLoopGroup创建OK后，启动的第一步就算完成了，接下来该进行bind、listen操作了。</p><h2 id="ServerBootstrap流程"><a href="#ServerBootstrap流程" class="headerlink" title="ServerBootstrap流程"></a>ServerBootstrap流程</h2><h3 id="bind操作"><a href="#bind操作" class="headerlink" title="bind操作"></a>bind操作</h3><p>bind操作是ServerBootstrap流程重要的一环，bind流程涉及到NioChannel的创建、初始化和注册(到Selector)，启动NioEventLoop，之后就可以对外提供服务了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">validate(); <span class="comment">// 参数校验</span></span><br><span class="line"><span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化注册操作</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2. doBind0操作</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// register已完成，这里直接调用doBind0</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// register还未完成，注册listener回调，在回调中调用doBind0</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * channel register完成（注册到Selector并且调用了invokeHandlerAddedIfNeeded）之后，</span></span><br><span class="line"><span class="comment">             * 会调用safeSetSuccess，触发各个ChannelFutureListener，最终会调用到这里的operationComplete方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到2个操作，一个是channel的创建、初始化、注册操作，另一个是bind操作，下面兵分两路，分别来讲。</p><blockquote><p>注意，这里如果main线程执行到regFuture.isDone()时，register还未完成，那么main线程是不会直接调用bind操作的，而是往regFuture上注册一个Listenner，这样channel register完成（注册到Selector并且调用了invokeHandlerAddedIfNeeded）之后，会调用safeSetSuccess，触发各个ChannelFutureListener，最终会调用到这里的operationComplete方法，进而在执行bind操作。</p></blockquote><h3 id="channel初始化、注册操作"><a href="#channel初始化、注册操作" class="headerlink" title="channel初始化、注册操作"></a>channel初始化、注册操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建(netty自定义)Channel实例，并初始化</span></span><br><span class="line">        <span class="comment">// channel为 NioServerSocketChannel 实例,NioServerSocketChannel的父类AbstractNioChannel保存有nio的ServerSocketChannel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line"><span class="comment">// 2.初始化channel（）</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3.向Selector注册channel</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点关注下初始化channel流程，主要操作是设置channel属性、设置channel.pipeline的ChannelInitializer，注意，ChannelInitializer是在channel注册到selector之后被回调的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始channel属性，也就是ChannelOption对应socket的各种属性。</span></span><br><span class="line"><span class="comment"> * 比如 SO_KEEPALIVE SO_RCVBUF ... 可以与Linux中的setsockopt函数对应起来。</span></span><br><span class="line"><span class="comment"> * 最后将ServerBootstrapAcceptor添加到对应channel的ChannelPipeline中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">// 获取childGroup和childHandler，传递给ServerBootstrapAcceptor</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在register0中，将channel注册到Selector之后，会调用invokeHandlerAddedIfNeeded，</span></span><br><span class="line"><span class="comment">         * 进而调用到这里的initChannel方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这里注册一个添加ServerBootstrapAcceptor的任务</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 添加ServerBootstrapAcceptor</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel初始化之后就该将其注册到selector，即下面的register流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next()挑选一个EventLoop，默认轮询选择某个NioEventLoop</span></span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line"><span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 直接执行register0或者以任务方式提交执行</span></span><br><span class="line">    <span class="comment">// 启动时，首先执行到这里的是main线程，所以是以任务的方式来提交执行的。</span></span><br><span class="line">    <span class="comment">// 也就是说，该任务是NioEventLoop第一次执行的任务，即调用register0</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 往NioEventLoop中(任务队列)添加任务时，如果NioEventLoop线程还未启动，则启动该线程</span></span><br><span class="line">        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="register操作"><a href="#register操作" class="headerlink" title="register操作"></a>register操作</h3><p>register操作之后伴随着多个回调及listener的触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel$AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">    <span class="comment">// 这里调用的是AbstractNioChannel.doRegister</span></span><br><span class="line">    <span class="comment">// 这里将channel注册上去，并没有关注对应的事件（read/write事件）</span></span><br><span class="line">    doRegister();</span><br><span class="line">    neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">    registered = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用handlerAdd事件，这里就会调用initChannel方法，设置channel.pipeline，也就是添加 ServerBootstrapAcceptor</span></span><br><span class="line">    pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用operationComplete回调</span></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line"><span class="comment">// 回调fireChannelRegistered</span></span><br><span class="line">    pipeline.fireChannelRegistered();</span><br><span class="line">    <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">    <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">    <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line"><span class="comment">// 回调fireChannelActive</span></span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">            beginRead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的initChannel回调也就是设置对外监听channel的channelHanlder为ServerBootstrapAcceptor；operationComplete回调也就是触发<code>ChannelFutureListener.operationComplete</code>，这里会进行后续的doBind操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// doBind0向EventLoop任务队列中添加一个bind任务来完成后续操作。</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// bind操作</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind操作-1"><a href="#bind操作-1" class="headerlink" title="bind操作"></a>bind操作</h3><p>在回顾上面的bind操作代码，bind操作是在register之后进行的，因为register0是由NioEventLoop执行的，所以main线程需要先判断下future是否完成，如果完成直接进行doBind即可，否则添加listener回调进行doBind。</p><p><img src="/2019/11/30/netty-qi-dong-liu-cheng/./Netty 启动流程/image-20191110190832653.png" alt><br>bind操作及后续初始化操作（channelActive回调、设置监听事件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用底层bind操作</span></span><br><span class="line">doBind(localAddress);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">safeSetFailure(promise, t);</span><br><span class="line">closeIfClosed();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pipeline.fireChannelActive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后底层bind逻辑bind入参包括了backlog，也就是底层会进行listen操作</span></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.headContext -&gt; NioMessageUnsafe -&gt; NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 回调fireChannelActive</span></span><br><span class="line">ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置selectKey监听事件，对于监听端口就是SelectionKey.OP_ACCEPT，对于新建连接就是SelectionKey.OP_READ</span></span><br><span class="line">readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止整个netty启动流程就基本接近尾声，可以对外提供服务了。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 处理粘包拆包机制</title>
      <link href="/2019/11/30/netty-chu-li-nian-bao-chai-bao-ji-zhi/"/>
      <url>/2019/11/30/netty-chu-li-nian-bao-chai-bao-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习netty处理黏包和拆包，首先要知道什么是黏包和拆包问题？</p></blockquote><p>黏包和拆包的产生是由于TCP拥塞控制算法（比如<a href="https://baike.baidu.com/item/Nagle算法/5645172" target="_blank" rel="noopener">angle算法</a>）和TCP缓冲区机制导致的，angle算法简单来说就是通过一些规则来尽可能利用网络带宽，尽可能的发送足够大的数据。TCP（发送/接收）缓冲区会暂缓数据，并且是有最大容量的。</p><p>黏包的产生是由于一次TCP通信数据量较少，导致多个TCP数据合并在一起（这里的合并可能发生在发送缓冲区合并后发送，也可能发生在接收缓冲区合并后应用程序一次性读取）。拆包的产生是由于一次TCP通信数据量较大（比如超过了MTU），导致发送时分片发送，这样接收时是多次接收后才是一个完整的数据。</p><p><strong>netty处理黏包和拆包问题，思路就是以定长方式读取接收到的数据来处理（比如读取固定长度数据量、以TLV方式读取数据、以固定分隔符读取数据等）</strong>。</p><p>下面以一个定长方式读取数据的示例来分析下Netty的处理机制，server端处理TCP黏包和拆包示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    boot.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">localAddress</span>(60000)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline()</span><br><span class="line">                            <span class="comment">// 定长接收消息，用于处理黏包分包问题</span></span><br><span class="line">                            .addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">1</span>))</span><br><span class="line">                            .addLast(<span class="keyword">new</span> EchoHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// start</span></span><br><span class="line">    ChannelFuture future = boot.bind().sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// shutdown</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedLengthFrameDecoder类继承关系如下，下面就以该类为例讲解下netty 处理粘包分包机制。</p><p><img src="/2019/11/30/netty-chu-li-nian-bao-chai-bao-ji-zhi/./Netty 处理粘包拆包机制/image-20191128213301667.png" alt></p><blockquote><p> 这里思考一下，如果接收到的数据未达到FixedLengthFrameDecoder要求的长度，这个时候Netty该如何处理呢？</p></blockquote><p>首先可以肯定的一点是，接收到数据长度不够，是不会进行后续channelHandler处理的。Netty的处理机制是会将接收到的数据存储到<code>ByteToMessageDecoder.cumulation</code>中，暂存一下，等待下次接收到数据时继续处理直到达到要求长度之后才交给后续的ChannelHandler来处理，ByteToMessageDecoder代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByteToMessageDecoder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteBuf data = (ByteBuf) msg;</span><br><span class="line">first = cumulation == <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line">cumulation = data;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// cumulation保存有上次未处理(不完整)的数据</span></span><br><span class="line">cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">&#125;</span><br><span class="line">callDecode(ctx, cumulation, out);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">numReads = <span class="number">0</span>;</span><br><span class="line">cumulation.release();</span><br><span class="line">cumulation = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">numReads = <span class="number">0</span>;</span><br><span class="line">discardSomeReadBytes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = out.size();</span><br><span class="line">decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line"><span class="comment">// 继续回调channelHandler.channelRead</span></span><br><span class="line">fireChannelRead(ctx, out, size);</span><br><span class="line">out.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decodeRemovalReentryProtection</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">decodeState = STATE_CALLING_CHILD_DECODE;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">decode(ctx, in, out);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;</span><br><span class="line">decodeState = STATE_INIT;</span><br><span class="line"><span class="keyword">if</span> (removePending) &#123;</span><br><span class="line">handlerRemoved(ctx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line"><span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">out.add(decoded);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已接收数据未达到要求的长度时，继续等待接收</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">@SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> ChannelHandlerContext ctx, ByteBuf in) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理粘包拆包，其实思路都是一致的，就是“分分合合”，粘包由于数据过多，那就按照固定策略分割下交给程序来处理；拆包由于一次传输数据较少，那就等待数据传输长度够了再交给程序来处理。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 总结篇</title>
      <link href="/2019/11/30/netty-zong-jie-pian/"/>
      <url>/2019/11/30/netty-zong-jie-pian/</url>
      
        <content type="html"><![CDATA[<p>Netty一个主要的目标就是促进“关注点分离”：<strong>使业务逻辑从网络基础设施应用程序中分离</strong>。不仅仅是Netty框架，其他框架的设计目的也大都是为了使业务程序和底层技术解耦，使程序员更加专注于业务逻辑实现，提高开发质量和效率。Netty为什么性能如此之高，主要是其内部的Reactor模型机制。</p><p>Netty Reactor流程图如下：</p><p><img src="/2019/11/30/netty-zong-jie-pian/./Netty连接处理/image-20191110192334923.png" alt></p><h3 id="Netty优缺点"><a href="#Netty优缺点" class="headerlink" title="Netty优缺点"></a>Netty优缺点</h3><p>netty优点就不多了，下面谈谈netty有哪些可以优化的地方或者可以改善的地方。</p><p><strong>1、更多的EventLoopGroup负载均衡策略</strong></p><p>目前提交给EventLoopGroup中的某个EventLoop使用的负载均衡策略只有轮询方式，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line">    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增取余方式轮询</span></span><br><span class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可考虑增加其他方式的负载均衡策略，比如最少连接等，不过要考虑在netty使用场景中该类负载均衡是否必要，实现难度和增加的效率如何，简单的说就是是否划算，如果划算，就可以考虑增加。</p><p><strong>2、EventLoop中IO事件和定时事件解耦</strong></p><p>目前EventLoop中的IO事件和定时事件是在同一个NIOEventLoop线程执行的，如果延时任务逻辑逻辑复杂，会导致IO事件响应的及时性和效率，因此考虑二者解耦，可使用独立的线程或线程池来执行定时事件。（目前Netty处理中可以通过ioRatio来调节IO事件和任务事件执行事件百分比，一定程度上可以减小二者的相互影响延时）</p><h3 id="为什么使用netty而不是直接用NIO或者其他NIO框架"><a href="#为什么使用netty而不是直接用NIO或者其他NIO框架" class="headerlink" title="为什么使用netty而不是直接用NIO或者其他NIO框架"></a>为什么使用netty而不是直接用NIO或者其他NIO框架</h3><ol><li>使用 JDK 自带的 NIO 需要了解太多的概念，编程复杂。</li><li>Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动。</li><li>Netty自带的拆包解包，异常检测等机制让我们从 NIO 的繁重细节中脱离出来，只需关心业务逻辑即可。</li><li>Netty解决了JDK 的很多包括空轮询在内的 Bug。</li><li>Netty底层对线程，Selector 做了很多细小的优化，精心设计的 Reactor 线程做到非常高效的并发处理。</li><li>自带各种协议栈，让我们处理任何一种通用协议都几乎不用亲自动手。</li><li>Netty社区活跃，遇到问题随时邮件列表或者 issue。</li><li>Netty已经历各大RPC框架（Dubbo），消息中间件（RocketMQ），大数据通信（Hadoop）框架的广泛的线上验证，健壮性无比强大。</li></ol><h3 id="JVM如何优雅退出"><a href="#JVM如何优雅退出" class="headerlink" title="JVM如何优雅退出"></a>JVM如何优雅退出</h3><p>对于通过注册ShutdownHook实现的优雅退出，需要注意如下几点，防止踩坑。</p><ol><li><p>ShutdownHook在某些情况下并不会被执行，例如JVM崩溃、无法接收信号量和kill-9 pid等。</p></li><li><p>当存在多个ShutdownHook时，JVM无法保证它们的执行先后顺序。</p></li><li>在JVM关闭期间不能动态添加或者去除ShutdownHook。</li><li>不能在ShutdownHook中调用System.exit（），它会卡住JVM，导致进程无法退出。</li></ol><p>对于采用注册 SignalHandler 实现优雅退出的程序，在 handle 接口中一定要避免阻塞操作，否则它会导致已经注册的 ShutdownHook无法执行，系统也无法退出。</p><h3 id="网关类产品的优化建议"><a href="#网关类产品的优化建议" class="headerlink" title="网关类产品的优化建议"></a>网关类产品的优化建议</h3><p>网关类产品的主要功能就是消息的预处理和转发，请求和响应对象都是“朝生夕灭”类型的，在高并发场景下，一定要防止不合理的内存申请，具体措施如下。</p><p>（1）内存按需分配。不要一次性申请较大的内存来保存较小的消息，造成内存空间浪费，引发频繁GC问题。</p><p>（2）不要频繁地创建和释放对象。这会增加GC的负担，降低系统的吞吐量，可以采用内存池等机制优化内存的申请和释放。</p><p>（3）减少对象拷贝。对于透传类的消息，尽量把涉及业务逻辑处理的字段放入Header，不要对 Body 做解码，直接透传到后端服务即可。这样可以大幅减少内存的申请和对象拷贝，降低内存占用，提升性能。</p><p>（4）流控机制必不可少。除了客户端并发连接数流控、QPS流控，还需要针对内存占用等指标做流控，防止业务高峰期的OOM。</p><h3 id="Netty的动态缓冲区分配器"><a href="#Netty的动态缓冲区分配器" class="headerlink" title="Netty的动态缓冲区分配器"></a>Netty的动态缓冲区分配器</h3><p>（1）Netty作为一个通用的 NIO框架，不能对用户的应用场景进行假设，可以使用它做流式计算，也可以用它做 RCP 框架，不同的应用场景，传输的码流大小千差万别，无论初始化时分配的是 32KB 还是 1MB，都会随着应用场景的变化而变得不合适。因此，Netty根据上次实际读取的码流大小对下次的接收 Buffer 缓冲区进行预测和调整，能够最大限度地满足不同行业的应用场景的需要。</p><p>（2）综合性能更高。分配容量过大会导致内存占用开销增加，后续的Buffer处理性能下降；容量过小需要频繁地内存扩张来接收大的请求消息，同样会导致性能下降。</p><p>（3）更节约内存。假如通常情况请求消息大小平均值为1MB左右，接收缓冲区大小为1.2MB，突然某个客户发送了一个10MB的附件，接收缓冲区扩张为10MB以读取该附件，如果缓冲区不能收缩，每次缓冲区创建都会分配 10MB 的内存，但是后续所有的消息都是 1MB左右的，这样会导致内存的浪费，如果并发客户端过多，可能会导致内存溢出并宕机。</p><h3 id="共享的ChannelHandler"><a href="#共享的ChannelHandler" class="headerlink" title="共享的ChannelHandler"></a>共享的ChannelHandler</h3><p>如果 ChannelHandler 不是共享的，重复向 ChannelPipeline 添加时就会抛出ChannelPipelineException异常，添加失败。所以非共享的同一个ChannelHandler实例不能被重复加入多个ChannelPipeline或者被多次加入某一个ChannelPipeline。如果某个 ChannelHandler 需要全局共享，则通过 Sharable 注解就可以被添加到多个ChannelPipeline，示例代码如下：</p><p><img src="/2019/11/30/netty-zong-jie-pian/./Netty 总结篇/image-20191130155118317.png" alt><br>用户自定义的ChannelHandler有两种场景需要考虑并发安全。</p><p>（1）通过 Sharable注解，多个 ChannelPipeline共享的 ChannelHandler，它将被多个NioEventLoop线程（通常用户创建的 NioEventLoopGroup线程数＞1）并发访问。 在这种场景下，用户需要保证ChannelHandler共享的合理性，同时需要自己保证它的并发安全性，尽量通过原子类等方式降低锁的开销，防止阻塞NioEventLoop线程。</p><p>（2）ChannelHandler没有共享，但是在用户的ChannelPipeline中的一些ChannelHandler绑定了新的线程池，这样ChannelPipeline的ChannelHandler就会被异步执行在多线程异步执行过程中，如果某ChannelHandler的成员变量共享给其他ChannelHandler，那么被多个线程并发访问和修改就存在并发安全问题。</p><h3 id="连接可靠性问题"><a href="#连接可靠性问题" class="headerlink" title="连接可靠性问题"></a>连接可靠性问题</h3><p>从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和通用的做法就是心跳检测。<br>心跳检测机制分为三个层面。<br>（1）TCP层面的心跳检测，即TCP的Keep-Alive机制，它的作用域是整个TCP协议栈。<br>（2）协议层的心跳检测，主要存在于长连接协议中，例如MQTT。<br>（3）应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现。心跳检测的目的就是确认当前链路是否可用，对方是否活着并且能够正常接收和发送消息。</p><blockquote><p>作为高可靠的NIO框架，Netty也提供了心跳检测机制，利用IdleStateHandler可以方便地实现业务层的心跳检测。</p></blockquote><blockquote><p>参考资料：</p><p>1、Netty进阶之路：跟着案例学Netty</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty连接处理</title>
      <link href="/2019/11/30/netty-lian-jie-chu-li/"/>
      <url>/2019/11/30/netty-lian-jie-chu-li/</url>
      
        <content type="html"><![CDATA[<p>Netty的连接处理就是IO事件的处理，IO事件包括读事件、ACCEPT事件、写事件和OP_CONNECT事件。</p><blockquote><p> IO事件的处理是结合ChanelPipeline来做的，一个IO事件到来，首先进行数据的读写操作，然后交给ChannelPipeline进行后续处理，ChannelPipeline中包含了channelHandler链（head + 自定义channelHandler + tail）。<br>使用channelPipeline和channelHandler机制，起到了解耦和可扩展的作用。一个IO事件的处理，包含了多个处理流程，这些处理流程正好对应channelPipeline中的channelHandler。如果对数据处理有新的需求，那么就新增channelHandler添加到channelPipeline中，这样实现很6，以后自己写代码可以参考。</p></blockquote><p>说到这里，一般为了满足扩展性要求，常用2种模式：</p><ul><li><p><strong>方法模板模式</strong>：模板中定义了各个主流程，并且留下对应hook方法，便于扩展。</p></li><li><p><strong>责任链模式</strong>：串行模式，可以动态添加链数量和对应回调方法。</p></li></ul><p>netty的<code>channelHandler</code>的<code>channelPipeline</code>可以理解成就是责任链模式，通过动态增加channelHandler可达到复用和高扩展性目的。</p><p>了解netty连接处理机制之前需要了解下NioEventLoop模型，其中处理连接事件的架构图如下：</p><p><img src="/2019/11/30/netty-lian-jie-chu-li/./Netty连接处理/image-20191110192334923.png" alt><br>对应的处理逻辑源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理各种IO事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// OP_CONNECT事件，client连接上客户端时触发的事件</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意，这里读事件和ACCEPT事件对应的unsafe实例是不一样的</span></span><br><span class="line">            <span class="comment">// 读事件 -&gt; NioByteUnsafe,  ACCEPT事件 -&gt; NioMessageUnsafe</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码来看，事件主要分为3种，分别是OP_CONNECT事件、写事件和读事件（也包括ACCEPT事件）。下面分为3部分展开：</p><h3 id="ACCEPT事件"><a href="#ACCEPT事件" class="headerlink" title="ACCEPT事件"></a>ACCEPT事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioMessageUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 调用java socket的accept方法，接收请求</span></span><br><span class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">            <span class="comment">// 增加统计计数</span></span><br><span class="line">            allocHandle.incMessagesRead(localRead);</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        exception = t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// readBuf中存的是NioChannel</span></span><br><span class="line">    <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">        readPending = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 触发fireChannelRead</span></span><br><span class="line">        pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    readBuf.clear();</span><br><span class="line">    allocHandle.readComplete();</span><br><span class="line">    pipeline.fireChannelReadComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接建立好之后就该连接的channel注册到workGroup中某个NIOEventLoop的selector中，注册操作是在fireChannelRead中完成的，这一块逻辑就在ServerBootstrapAcceptor.channelRead中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootstrapAcceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置channel的pipeline handler，及channel属性</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将channel注册到childGroup中的Selector上</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="READ事件"><a href="#READ事件" class="headerlink" title="READ事件"></a>READ事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioByteUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"> </span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 从channel中读取数据，存放到byteBuf中</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line"> </span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 触发fireChannelRead</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发fireChannelReadComplete，如果在fireChannelReadComplete中执行了ChannelHandlerContext.flush，则响应结果返回给客户端</span></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line"><span class="comment">// 触发fireChannelReadComplete</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写事件"><a href="#写事件" class="headerlink" title="写事件"></a>写事件</h3><p>正常情况下一般是不会注册写事件的，如果Socket发送缓冲区中没有空闲内存时，再写入会导致阻塞，此时可以注册写事件，当有空闲内存（或者可用字节数大于等于其低水位标记）时，再响应写事件，并触发对应回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 写事件，从flush操作来看，虽然之前没有向socket缓冲区写数据，但是已经写入到</span></span><br><span class="line">    <span class="comment">// 了chnanel的outboundBuffer中，flush操作是将数据从outboundBuffer写入到</span></span><br><span class="line">    <span class="comment">// socket缓冲区</span></span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CONNECT事件"><a href="#CONNECT事件" class="headerlink" title="CONNECT事件"></a>CONNECT事件</h3><p>该事件是client触发的，由主动建立连接这一侧触发的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// OP_CONNECT事件，client连接上客户端时触发的事件</span></span><br><span class="line">    <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发finishConnect事件，其中就包括fireChannelActive事件，如果有自定义的handler有channelActive方法，则会触发</span></span><br><span class="line">    unsafe.finishConnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pipeline和ChannelHandler机制</title>
      <link href="/2019/11/30/pipeline-he-channelhandler-ji-zhi/"/>
      <url>/2019/11/30/pipeline-he-channelhandler-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Pipeline和ChannelHandler是Netty处理流程的重要组成部分，ChannelHandler对应一个个业务处理器，Pipeline则是负责将各个ChannelHandler串起来的“容器”，二者结合起来一起完成Netty的处理流程。</p></blockquote><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>每个channel内部都会持有一个ChannelPipeline对象pipeline，pipeline默认实现DefaultChannelPipeline内部维护了一个DefaultChannelHandlerContext链表。</p><p><img src="/2019/11/30/pipeline-he-channelhandler-ji-zhi/./Pipeline和ChannelHandler机制/image-20191127010534231.png" alt><br>channel的读写操作都会走到DefaultChannelPipeline中，当channel完成register、active、read、readComplete等操作时，会触发pipeline的相应方法。</p><ol><li>当channel注册到selector后，触发pipeline的fireChannelRegistered方法；</li><li>当channel是可用时，触发pipeline的fireChannelActive方法。（fireChannelActive触发一般是在fireChannelRegistered之后触发的）；</li><li>当客户端发送数据时，触发pipeline的fireChannelRead方法；</li><li>触发pipeline的fireChannelRead方法之后会触发pipeline的fireChannelReadComplete方法。</li></ol><p><code>DefaultChannelPipeline</code>是Netty默认pipeline实现，对应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="comment">// head和tail是handler的处理链/上下文</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext head;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">        voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TailContext实现了ChannelOutboundHandler接口，HeadContext实现了ChannelInboundHandler和ChannelOutboundHandler接口，head和tail构成了一个链表。</p><blockquote><p> 对于Inbound操作，从head开始进行处理，向后遍历；对于OutBound操作，从tail开始处理，向前遍历。那么哪些操作是Inbound哪些是OutBound操作呢？</p></blockquote><ul><li><strong>InBound</strong>：channelRegistered、channelActive、channelRead、channelReadComplete；</li><li><strong>OutBound</strong>：bind、connect、close、flush等。</li></ul><p>注意，HeadContext实现了<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>接口，对于OutBound操作，最后也是会走到HeadContext来处理的，其实TailContext只是一个浅封装，实际逻辑并不多。HeadContext 中包含了一个netty底层的socket操作类，对于<code>bind/connect/disconnect/close/deregister/beginRead/read/wirte/flush</code>操作都是由unsafe对象来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// netty的底层socket操作类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"> </span><br><span class="line">    HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        unsafe = pipeline.channel().unsafe();</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channelPipeline的channelHandlerContext链表是“责任链”模式的体现，一个请求的处理可能会涉及到多个channelHandler，比如decodeHandler、自定义的业务channelHandler和encodeHandler。业务channelHandler示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在channelReadComplete方法中调用flush，其实会走到head.flush方法，最后调用unsafe.flush将数据发送出去。netty pipeline就是责任链（或者说是流水线）模式的体现，通过pipeline机制，使netty处理数据机制具有强大的扩展性和灵活性。</p></blockquote><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>netty的channelHandler是channel处理器，基于netty的业务处理，不管多么复杂，都是由channelHandler来做的，可能涉及到多个channelHandler，channelHandler分为多种类型：encoder、decoder、业务处理等。</p><h4 id="decoderHandler"><a href="#decoderHandler" class="headerlink" title="decoderHandler"></a>decoderHandler</h4><p>decoderHandler大都是接收到数据之后进行转换或者处理的，基本都是ByteToMessageDecoder的子类，其类图如下：</p><p><img src="/2019/11/30/pipeline-he-channelhandler-ji-zhi/./Pipeline和ChannelHandler机制/image-20191128200013932.png" alt><br>ByteToMessageDecoder中会有一个数据暂存缓冲区，如果接收到数据不完整，可以先暂存下等到下次接收到数据时再处理。</p><h4 id="encoderHandler"><a href="#encoderHandler" class="headerlink" title="encoderHandler"></a>encoderHandler</h4><p>encoderHandler大都是将message转换成bytebuf数据，基本都是MessageToByteEncoder的子类，其类图如下：</p><p><img src="/2019/11/30/pipeline-he-channelhandler-ji-zhi/./Pipeline和ChannelHandler机制/image-20191128200059445.png" alt></p><h4 id="业务channelHandler"><a href="#业务channelHandler" class="headerlink" title="业务channelHandler"></a>业务channelHandler</h4><p>业务处理channelHanler就是用户自定义的业务逻辑了，一般是在最后才addLast到channel.pipeline的，比如http处理逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">boot.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">localAddress</span>(8080)</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline()</span><br><span class="line">                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder())</span><br><span class="line">                    .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>))</span><br><span class="line">                    .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>DefaultChannelPipeline中的headContext（实现了ChannelOutboundHandler和ChannelInboundHandler）、tailContext（实现了ChannelOutboundHandler）和自定义的channelHandler（decoderHandler、ecoderHandler、channelHandler等，一般实现ChannelInboundHandler），通过ChannelHandlerContext的链接，组成了一个请求处理链。</p></blockquote><p>注意，ChannelOutboundHandler和ChannelInboundHandler的顺序如何添加的，其实只要记住一条：ChannelOutboundHandler之间要保证顺序，ChannelInboundHandler之间要保证顺序，二者之间无需保证顺序。</p><p>channelHandler的运行流程图：</p><p><img src="/2019/11/30/pipeline-he-channelhandler-ji-zhi/./Pipeline和ChannelHandler机制/image-20191128205424722.png" alt><br><code>TailContesxt</code>本身代码不多并且挺多方法都是”空实现”，不过它的channelRead方法内部会执行<code>ReferenceCountUtil.release(msg)</code>释放msg占用的内存空间，也就是说在<code>未定义用户ChannelHandler</code>或者<code>用户ChannelHandler的channelRead继续传递后续ChannelHandler的channelRead</code>时，到TailContext的channelRead时会自动释放msg所占用内存。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty 线程模型</title>
      <link href="/2019/11/30/netty-xian-cheng-mo-xing/"/>
      <url>/2019/11/30/netty-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>要学习netty线程模型，先了解下NIO和AIO、reactor和proactor模型，这样理解netty线程模型和IO模型更轻松。</p><p><strong>IO模型</strong></p><ul><li>BIO：同步阻塞IO模型；</li><li>NIO：基于IO多路复用技术的“非阻塞同步”IO模型。简单来说，内核将可读可写事件通知应用，由应用主动发起读写操作；</li><li>AIO：非阻塞异步IO模型。简单来说，内核将读完成事件通知应用，读操作由内核完成，应用只需操作数据即可；应用做异步写操作时立即返回，内核会进行写操作排队并执行写操作。</li></ul><p>NIO和AIO不同之处在于应用是否进行真正的读写操作。</p><p><strong>reactor和proactor模型</strong></p><ul><li>reactor：基于NIO技术，可读可写时通知应用；</li><li>proactor：基于AIO技术，读完成时通知应用，写操作应用通知内核。</li></ul><h2 id="netty线程模型"><a href="#netty线程模型" class="headerlink" title="netty线程模型"></a>netty线程模型</h2><blockquote><p> netty的线程模型是基于Reactor模型的。</p></blockquote><h3 id="netty单线程模型"><a href="#netty单线程模型" class="headerlink" title="netty单线程模型"></a>netty单线程模型</h3><p>Reactor 单线程模型，是指所有的 I/O 操作都在同一个 NIO 线程上面完成的，此时NIO线程职责包括：接收新建连接请求、读写操作等。</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075348844.png" alt><br>在一些小容量应用场景下，可以使用单线程模型（<code>注意，Redis的请求处理也是单线程模型，为什么Redis的性能会如此之高呢？因为Redis的读写操作基本都是内存操作，并且Redis协议比较简洁，序列化/反序列化耗费性能更低</code>）。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p><ul><li>一个NIO线程同时处理成百上千的连接，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送。</li><li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul><h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h3><p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程来处理连接读写操作，一个NIO线程处理Accept。一个NIO线程可以处理多个连接事件，一个连接的事件只能属于一个NIO线程。</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075510891.png" alt><br>在绝大多数场景下，Reactor 多线程模型可以满足性能需求。但是，在个别特殊场景中，一个 NIO 线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个 Acceptor 线程可能会存在性能不足的问题，为了解决性能问题，产生了第三种 Reactor 线程模型——主从Reactor 多线程模型。</p><h3 id="Reactor主从多线程模型"><a href="#Reactor主从多线程模型" class="headerlink" title="Reactor主从多线程模型"></a>Reactor主从多线程模型</h3><p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是一个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP连接请求并处理完成后（可能包含接入认证等），将新创建的 SocketChannel注 册 到 I/O 线 程 池（sub reactor 线 程 池）的某个I/O线程上， 由它负责SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅用于客户端的登录、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 I/O 线程上，由 I/O 线程负责后续的 I/O 操作。</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075602148.png" alt></p><h2 id="netty线程模型思考"><a href="#netty线程模型思考" class="headerlink" title="netty线程模型思考"></a>netty线程模型思考</h2><p>netty 的线程模型并不是一成不变的，它实际取决于用户的启动参数配置。通过设置不同的启动参数，Netty 可以同时支持 Reactor 单线程模型、多线程模型。</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075639698.png" alt><br>为了尽可能地提升性能，Netty 在很多地方进行了无锁化的设计，例如在 I/O 线程内部进行串行操作，避免多线程竞争导致的性能下降问题。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程的模型性能更优。（<code>小伙伴们后续多线程并发流程可参考该类实现方案</code>）</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075715267.png" alt><br>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的<code>fireChannelRead (Object msg)</code>。 只要用户不主动切换线程， 一直都是由NioEventLoop 调用用户的 ChannelHandler，期间不进行线程切换。这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p><p>Netty拥有两个NIO线程池，分别是<code>bossGroup</code>和<code>workerGroup</code>，前者处理新建连接请求，然后将新建立的连接轮询交给workerGroup中的其中一个NioEventLoop来处理，后续该连接上的读写操作都是由同一个NioEventLoop来处理。注意，虽然bossGroup也能指定多个NioEventLoop（一个NioEventLoop对应一个线程），但是默认情况下只会有一个线程，因为一般情况下应用程序只会使用一个对外监听端口。</p><blockquote><p>这里试想一下，难道不能使用多线程来监听同一个对外端口么，即多线程epoll_wait到同一个epoll实例上？</p></blockquote><p>epoll相关的主要两个方法是epoll_wait和epoll_ctl，多线程同时操作同一个epoll实例，那么首先需要确认epoll相关方法是否线程安全：<strong>简单来说，epoll是通过锁来保证线程安全的, epoll中粒度最小的自旋锁ep-&gt;lock(spinlock)用来保护就绪的队列, 互斥锁ep-&gt;mtx用来保护epoll的重要数据结构红黑树</strong>。</p><p>看到这里，可能有的小伙伴想到了Nginx多进程针对监听端口的处理策略，Nginx是通过accept_mutex机制来保证的。accept_mutex是nginx的(新建连接)负载均衡锁，让多个worker进程轮流处理与client的新连接。当某个worker进程的连接数达到worker_connections配置（单个worker进程的最大处理连接数）的最大连接数的7/8时，会大大减小获取该worker获取accept锁的概率，以此实现各worker进程间的连接数的负载均衡。accept锁默认打开，关闭它时nginx处理新建连接耗时会更短，但是worker进程之间可能连接不均衡，并且存在“惊群”问题。只有在使能accept_mutex并且当前系统不支持原子锁时，才会用文件实现accept锁。注意，accept_mutex加锁失败时不会阻塞当前线程，类似tryLock。</p><blockquote><p> 现代linux中，多个socker同时监听同一个端口也是可行的，nginx 1.9.1也支持这一行为。linux 3.9以上内核支持SO_REUSEPORT选项，允许多个socker bind/listen在同一端口上。这样，多个进程可以各自申请socker监听同一端口，当连接事件来临时，内核做负载均衡，唤醒监听的其中一个进程来处理，reuseport机制有效的解决了epoll惊群问题。</p></blockquote><p>再回到刚才提出的问题，java中多线程来监听同一个对外端口，epoll方法是线程安全的，这样就可以使用使用多线程监听epoll_wait了么，当然是不建议这样干的，除了epoll的惊群问题之外，还有一个就是，一般开发中我们使用epoll设置的是LT模式（<code>水平触发方式，与之相对的是ET默认，前者只要连接事件未被处理就会在epoll_wait时始终触发，后者只会在真正有事件来时在epoll_wait触发一次</code>），这样的话，多线程epoll_wait时就会导致第一个线程epoll_wait之后还未处理完毕已发生的事件时，第二个线程也会epoll_wait返回，显然这不是我们想要的，关于java nio的测试demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// non-block io</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多线程执行</span></span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (selector.select(<span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"selector.select loop... "</span> + Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (flag.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" over"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// accept event</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            handlerAccept(selector, key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// socket event</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            handlerRead(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * Selector不会自己从已选择键集中移除SelectionKey实例，必须在处理完通道时手动移除。</span></span><br><span class="line"><span class="comment">                         * 下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">            threadList.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlerAccept</span><span class="params">(Selector selector, SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"coming a new client... "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        SocketChannel channel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlerRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = channel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// error or fin</span></span><br><span class="line">            System.out.println(<span class="string">"close "</span> + channel.getRemoteAddress());</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String recv = Charset.forName(<span class="string">"UTF-8"</span>).newDecoder().decode(buffer).toString();</span><br><span class="line">            System.out.println(<span class="string">"recv: "</span> + recv);</span><br><span class="line"></span><br><span class="line">            buffer = ByteBuffer.wrap((<span class="string">"server: "</span> + recv).getBytes());</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="netty线程模型实践"><a href="#netty线程模型实践" class="headerlink" title="netty线程模型实践"></a>netty线程模型实践</h2><p><strong>(1) 时间可控的简单业务直接在 I/O 线程上处理</strong></p><p>时间可控的简单业务直接在 I/O 线程上处理，如果业务非常简单，执行时间非常短，不需要与外部网络交互、访问数据库和磁盘，不需要等待其它资源，则建议直接在业务 ChannelHandler 中执行，不需要再启业务的线程或者线程池。避免线程上下文切换，也不存在线程并发问题。</p><p><strong>(2) 复杂和时间不可控业务建议投递到后端业务线程池统一处理</strong></p><p>复杂度较高或者时间不可控业务建议投递到后端业务线程池统一处理，对于此类业务，不建议直接在业务 ChannelHandler 中启动线程或者线程池处理，建议将不同的业务统一封装成 Task，统一投递到后端的业务线程池中进行处理。过多的业务ChannelHandler 会带来开发效率和可维护性问题，不要把 Netty 当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和Netty 的架构分层。</p><p><strong>(3) 业务线程避免直接操作 ChannelHandler</strong></p><p>业务线程避免直接操作 ChannelHandler，对于 ChannelHandler，IO 线程和业务线程都可能会操作，因为业务通常是多线程模型，这样就会存在多线程操作ChannelHandler。为了尽量避免多线程并发问题，建议按照 Netty 自身的做法，通过将操作封装成独立的 Task 由 NioEventLoop 统一执行，而不是业务线程直接操作，相关代码如下所示：</p><p><img src="/2019/11/30/netty-xian-cheng-mo-xing/./netty 线程模型/image-20191117075947254.png" alt><br>如果你确认并发访问的数据或者并发操作是安全的，则无需多此一举，这个需要根据具体的业务场景进行判断，灵活处理。</p><p>参考资料：</p><p>1、<a href="https://blog.csdn.net/yangguosb/article/details/80053731" target="_blank" rel="noopener">https://blog.csdn.net/yangguosb/article/details/80053731</a></p><p>2、<a href="https://segmentfault.com/a/1190000007403873" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007403873</a></p><p>3、《深入浅出Netty》</p><p>4、<a href="https://zhuanlan.zhihu.com/p/30937065" target="_blank" rel="noopener">为什么epoll是线程安全？</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nio epoll bug到底是什么</title>
      <link href="/2019/11/30/nio-epoll-bug-dao-di-shi-shi-me/"/>
      <url>/2019/11/30/nio-epoll-bug-dao-di-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<p>epoll机制是Linux下一种高效的IO复用方式，相较于select和poll机制来说。其高效的原因是将基于事件的fd放到内核中来完成，在内核中基于红黑树+链表数据结构来实现，链表存放有事件发生的fd集合，然后在调用epoll_wait时返回给应用程序，由应用程序来处理这些fd事件。</p><p>使用IO复用，Linux下一般默认就是epoll，Java NIO在Linux下默认也是epoll机制，但是JDK中epoll的实现却是有漏洞的，其中最有名的java nio epoll bug就是即使是关注的select轮询事件返回数量为0，NIO照样不断的从select本应该阻塞的<code>Selector.select()/Selector.select(timeout)</code>中wake up出来，导致CPU 100%问题。如下图所示：</p><p><img src="/2019/11/30/nio-epoll-bug-dao-di-shi-shi-me/./nio epoll bug到底是什么/epollbug.jpeg" alt><br>那么产生这个问题的原因是什么的？其实在 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302</a> 上已经说明的很清楚了，比如下面是bug复现的一个场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A DESCRIPTION OF THE PROBLEM :</span><br><span class="line">The NIO selector wakes up infinitely in this situation..</span><br><span class="line">0. server waits for connection</span><br><span class="line">1. client connects and write message</span><br><span class="line">2. server accepts and register OP_READ</span><br><span class="line">3. server reads message and remove OP_READ from interest op set</span><br><span class="line">4. client close the connection</span><br><span class="line">5. server write message (without any reading.. surely OP_READ is not set)</span><br><span class="line">6. server&apos;s select wakes up infinitely with return value 0</span><br></pre></td></tr></table></figure><p>上面的场景描述的问题就是连接出现了RST，因为poll和epoll对于突然中断的连接socket会对返回的eventSet事件集合置为POLLHUP或者POLLERR，eventSet事件集合发生了变化，这就导致Selector会被唤醒，进而导致CPU 100%问题。根本原因就是JDK没有处理好这种情况，比如SelectionKey中就没定义有异常事件的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然nio epoll bug存在，那么能不能规避呢？答案是有的，比如netty就很巧妙的规避了这个问题，它的处理机制就是如果发生了这种情况，并且发生次数超过了SELECTOR_AUTO_REBUILD_THRESHOLD（默认512），则调用rebuildSelector()进行Selecttor重建，这样就不用管之前发生了异常情况的那个连接了。因为重建也是根据SelectionKey事件对应的连接来重新注册的。</p><blockquote><p>该问题最早在 Java 6 发现，随后很多版本声称解决了该问题，但实际上只是降低了该 bug 的出现频率，目前从网上搜索到的资料显示，Java 8 还是存在该问题（<a href="https://juejin.im/entry/5995084ef265da247779d23c" target="_blank" rel="noopener">当 Thrift 遇到 JDK Epoll Bug</a>）。</p></blockquote><p>最后一起来分析下，nio epoll bug不是linux epoll的问题，而是JDK自己实现epoll时没有考虑这种情况，或者说因为其他系统不存在这个问题，Java为了封装（比如SelectionKey 中的4个事件类型）的统一而没去处理？</p><blockquote><p>这里思考下，如果想要从java nio层面上来解决这个问题，该如何做呢？</p></blockquote><p>一种是nio事件类型SelectionKey新加一种”错误”类型，比如针对linux epoll中的epollhup和epollerr，如果出现这种事件，建议程序直接close socket，但这种方式相对来说对于目前的nio SelectionKey改动有点大，因为SelectionKey的定义目前是针对所有jdk平台的；还有一种是针对jdk nio 对epoll的封装中，对于epoll的epollhup和epollerr事件，epoll封装内部直接处理，比如close socket，但是这种方案也有一点尴尬的是，可能上层应用代码还保留有出现问题的socket引用，这时最好是应用程序能够感知这种情况来处理比较好。</p><blockquote><p>Java nio空转问题由来已久，一般程序中是通过新建Selector的方式来屏蔽掉了JDK5/6的这个问题，因此，对于开发者来讲，还是尽量将JDK的版本更新到最新，或者使用NIO框架如Netty，Grizzly等进行研发，以免出更多的问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Netty NioEventLoop实现中可以学到什么</title>
      <link href="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/"/>
      <url>/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讨论Netty NioEventLoop原理及实践，关于Netty NioEventLoop，首先要知道NioEventLoop是什么，为什么它会是Netty核心Reactor处理器，实现原理是什么，进而再讨论Netty对其的实现及使用上我们可以学到哪些。</p></blockquote><p>EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理客户端请求和内部任务，内部任务如ServerSocketChannel注册、ServerSocket绑定和延时任务处理等操作。</p><p>EventLoop是由事件驱动的，比如IO事件和任务等，IO事件即selectionKey中ready的事件，如<code>accept、connect、read、write</code>等，由processSelectedKeys方法触发。处理完请求时间之后，会处理内部添加到taskQueue中的任务，如<code>register0、bind0</code>等任务，由runAllTasks方法触发。注意NioEventLoop在Linux中默认底层是基于epoll机制。</p><p><img src="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/./从Netty NioEventLoop实现中可以学到什么/image-20191130084720466.png" alt><br>上图是EventLoop的核心流程图，如果从Netty整体视角看EventLoop的事件流转，下图来的更直观：</p><p><img src="/2019/11/30/cong-netty-nioeventloop-shi-xian-zhong-ke-yi-xue-dao-shi-me/./从Netty NioEventLoop实现中可以学到什么/image-20191130084938960.png" alt></p><blockquote><p>注意：bossGroup和WorkerGroup中的NioEventLoop流程是一致的，只不过前者处理Accept事件之后将连接注册到后者，由后者处理该连接上后续的读写事件。</p></blockquote><p>大致了解了NioEventLoop之后，不知道有没有小伙伴有这样的疑问，为什么Netty要这样实现呢，这种实现方案对于我们后续开发如何借鉴呢？关于这些疑问，本文最后讨论哈 :)</p><h2 id="EventLoop实现原理"><a href="#EventLoop实现原理" class="headerlink" title="EventLoop实现原理"></a>EventLoop实现原理</h2><p>EventLoop是一个<strong>Reactor模型</strong>的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理IO事件和内部任务。IO事件和内部任务执行时间百分比通过ioRatio来调节，ioRatio表示执行IO时间所占百分比。任务包括普通任务和已经到时的延迟任务，延迟任务存放到一个优先级队列PriorityQueue中，执行任务前从PriorityQueue读取所有到时的task，然后添加到taskQueue中，最后统一执行task。</p><h3 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h3><p>EventLoop是由事件驱动的，比如IO事件即selectionKey中ready的事件，如<code>accept、connect、read、write</code>等，处理的核心逻辑主要是在<code>NioEventLoop.run</code>方法中，流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* 如果hasTasks，则调用selector.selectNow()，非阻塞方式获取channel事件，没有channel事件时可能返回为0。这里用非阻塞方式是为了尽快获取连接事件，然后处理连接事件和内部任务。*/</span></span><br><span class="line">      <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">          select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">          <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cancelledKeys = <span class="number">0</span>;</span><br><span class="line">      needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">/* ioRatio调节连接事件和内部任务执行事件百分比</span></span><br><span class="line"><span class="comment">       * ioRatio越大，连接事件处理占用百分比越大 */</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">      <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          runAllTasks();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">          runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上，在执行<code>select()</code>前有一个<code>hasTasks()</code>的操作，这个<code>hasTasks()</code>方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行<code>selector.selectNow()</code>，该方法会立即返回，保证了EventLoop在有任务执行时不会因为IO事件迟迟不来造成延后处理，这里优先处理IO事件，然后再处理任务。</p><p>如果当前taskQueue没有任务时，就会执行<code>select(wakenUp.getAndSet(false))</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个方法解决了Nio中臭名昭著的bug：selector的select方法导致空轮询 cpu100% */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* delayNanos(currentTimeNanos)：计算延迟任务队列中第一个任务的到期执行时间（即最晚还能延迟多长时间执行），默认返回1s。每个SingleThreadEventExecutor都持有一个延迟执行任务的优先队列PriorityQueue，启动线程时，往队列中加入一个任务。*/</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/* 如果延迟任务队列中第一个任务的最晚还能延迟执行的时间小于500000纳秒，且selectCnt == 0（selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()），则执行selector.selectNow()方法并立即返回。*/</span></span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 超时阻塞select</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line">            System.out.println(selectCnt);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 有事件到来 | 被唤醒 | 有内部任务 | 有定时任务时，会返回</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// 阻塞超时后没有事件到来，重置selectCnt</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// Selector重建</span></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当java NIO bug触发时，进行Selector重建，rebuildSelector过程如下：</p><ol><li>通过方法openSelector创建一个新的selector。</li><li>将old selector的selectionKey执行cancel。</li><li>将old selector的channel重新注册到新的selector中。</li></ol><p>Netty的连接处理就是IO事件的处理，IO事件包括读事件、ACCEPT事件、写事件和OP_CONNECT事件：</p><ul><li>ACCEPT事件：连接建立好之后将该连接的channel注册到workGroup中某个NIOEventLoop的selector中；</li><li>READ事件：从channel中读取数据，存放到byteBuf中，触发后续的ChannelHandler来处理数据；</li><li>WRITE事件：正常情况下一般是不会注册写事件的，如果Socket发送缓冲区中没有空闲内存时，在写入会导致阻塞，此时可以注册写事件，当有空闲内存（或者可用字节数大于等于其低水位标记）时，再响应写事件，并触发对应回调。</li><li>CONNECT事件：该事件是client触发的，由主动建立连接这一侧触发的。</li></ul><h3 id="任务处理机制"><a href="#任务处理机制" class="headerlink" title="任务处理机制"></a>任务处理机制</h3><p>任务处理也就是处理内部任务，这里也包括延时任务，延时任务到时后会移动到taskQueue然后被执行。任务处理是在IO事件处理之后进行的，IO事件和内部任务执行时间百分比可以通过ioRatio来调节，ioRatio表示执行IO时间所占百分比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* timeoutNanos：任务执行花费最长耗时/</span></span><br><span class="line"><span class="comment">protected boolean runAllTasks(long timeoutNanos) &#123;</span></span><br><span class="line"><span class="comment">    // 把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行。</span></span><br><span class="line"><span class="comment">    fetchFromScheduledTaskQueue();</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    // 非阻塞方式pollTask</span></span><br><span class="line"><span class="comment">    Runnable task = pollTask();</span></span><br><span class="line"><span class="comment">    if (task == null) &#123;</span></span><br><span class="line"><span class="comment">        afterRunningAllTasks();</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span></span><br><span class="line"><span class="comment">    long runTasks = 0;</span></span><br><span class="line"><span class="comment">    long lastExecutionTime;</span></span><br><span class="line"><span class="comment">    for (;;) &#123;</span></span><br><span class="line"><span class="comment">        // 执行task</span></span><br><span class="line"><span class="comment">        safeExecute(task);</span></span><br><span class="line"><span class="comment">        runTasks ++;</span></span><br><span class="line"><span class="comment">        // 依次从taskQueue任务task执行，每执行64个任务，进行耗时检查。</span></span><br><span class="line"><span class="comment">        // 如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</span></span><br><span class="line"><span class="comment">        if ((runTasks &amp; 0x3F) == 0) &#123;</span></span><br><span class="line"><span class="comment">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span></span><br><span class="line"><span class="comment">            if (lastExecutionTime &gt;= deadline) &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        task = pollTask();</span></span><br><span class="line"><span class="comment">        if (task == null) &#123;</span></span><br><span class="line"><span class="comment">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    afterRunningAllTasks();</span></span><br><span class="line"><span class="comment">    this.lastExecutionTime = lastExecutionTime;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，任务的处理过程中有个执行一定量任务后的执行时间耗时检查动作，这里是为了避免任务的处理时间过长，影响Netty网络IO的处理效率，毕竟Netty是要处理大量网络IO的。</p></blockquote><h2 id="对于NioEventLoop实现的思考"><a href="#对于NioEventLoop实现的思考" class="headerlink" title="对于NioEventLoop实现的思考"></a>对于NioEventLoop实现的思考</h2><p>EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理网络IO请求和内部任务，这里的selector和taskQueue是线程内部的。</p><p>Netty的BossGroup和WorkerGroup可能包含多个EventLoop，BossGroup接收到请求之后轮询交给WorkerGroup中的其中一个线程（对应一个NioEventLoop）来处理，也就是连接之间的处理是线程独立的，这也就是NioEventLoop流程的无锁化设计。</p><p>从EventLoop“无锁化”设计和常见的锁机制对比来看，要实现线程并发安全，有两种实现策略：</p><ul><li>数据隔离：数据隔离就是数据产生后就提交给不同的线程来处理，线程内部一般有一个数据容器来保存待处理的数据，这里的提交动作需要保证是安全的，比如Netty的BossGroup将建立好的连接注册到WorkerGroup时，是由内核来保证线程安全的（比如Linux就是通过epoll_ctl方法，该方法是线程安全的）；</li><li>数据分配：数据产生后统一放在数据容器中，由数据消费线程自己来获取数据进行处理，这里的获取动作需要保证是安全的，一般通过锁机制来保护，比如Java线程池中线程从阻塞队列中获取任务进行执行，就是由阻塞队列保证线程安全。</li></ul><p>对于数据隔离和数据分配来说，二者都有优缺点及适用场景。对于数据隔离来说，一般“锁”交互少成本较低，并且其隔离性较好，线程内部如果有新数据产生还继续由该线程来处理，但是可能造成数据负载不均衡；对于数据分配来说，“锁”交互较多，但是由于数据处理线程都是从同一数据容器消费数据，所以不会出现数据处理负载不均衡问题。</p><blockquote><p>如果想实现类似EventLoop中单个线程对应一个处理队列的方案，可以使用只配置一个线程的Java线程池，达到类似的实现效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见限流方案设计与实现</title>
      <link href="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/"/>
      <url>/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>高并发系统设计的3个利器：缓存、限流、降级，本文就限流相关算法，分析其设计与实现。</p><p>从分布式角度来看，限流可分为<strong>分布式限流</strong>（比如基于Sentinel或者Redis的集群限流）和<strong>单机限流</strong>。从算法实现角度来看，限流算法可分为<strong>漏桶算法</strong>、<strong>令牌桶算法</strong>和<strong>滑动时间窗口算法</strong>。下面主要分析这3种限流算法和分布式限流实现方案。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>把请求比作是水，水来了都先放进桶里，并以恒定速度出水（处理请求），当水流量过大会导致桶溢出，即拒绝服务。请求的最大处理速度也就是水从漏桶流出的速度。</p><p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/clipboard-1561974899704.png" alt="img"></p><p>基于漏桶（桶+恒定处理速率），可以起到对请求整流效果。漏桶算法可基于线程池来实现，线程池使用固定容量的阻塞队列+固定个数的处理线程来实现；最简单且最常见的漏桶思想的实现就是基于SynchronousQueue的线程池，其相当于一个空桶+固定处理线程 : )。</p><blockquote><p> 注意：原生的漏桶算法以恒定速度出水（处理请求），但是实际场景中请求的处理耗时可能不相等，为了实现恒定速率，一般都是限定同时处理请求的最大线程数。</p></blockquote><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>很多场景中，需要允许某种程度的突发请求，请求的最大速度也就是所有桶大小。这时候漏桶算法就不合适了，令牌桶算法更为适合。</p><p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/clipboard.png" alt="img"></p><p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p><p>令牌桶算法的一个实现方案是：起一个Timer线程以固定频率往桶中放令牌，桶满时令牌溢出，业务线程在获取令牌时直接从桶中获取即可。该方案容易理解，但是需要一个Timer线程，资源占用较重。</p><p>令牌桶算法还有一种实现方案不需要用Timer线程，这个经典实现就是<code>Guava</code>中的<code>RateLimiter</code>。<code>RateLimiter</code>实现原理如下：</p><ol><li><code>startTick</code>记录RateLimiter初始化时的时间戳（单位ns），后续<code>nowMicros</code>(当前时间点)都是取(System.nanoTime()-startTick)/1000；</li><li><code>nextFreeTicketMicros</code>记录下次可获取令牌的开始时间点，在RateLimiter初始化和获取到令牌之后会进行更新；</li><li>如果nowMicros大于等于nextFreeTicketMicros，表示可以获取令牌；如果nowMicros大于nextFreeTicketMicros，会计算二者差值并除以放一个令牌的周期，然后赋值给<code>storedPermits</code>字段（表示当前桶中令牌数，注意不能超过桶容量）；</li><li>然后storedPermits减去当前需要令牌数，如果此时要获取令牌数大于storedPermits，那么会将nextFreeTicketMicros再往后推进<code>(要获取令牌 - storedPermits) * 放一个令牌的周期</code> 的时间。</li></ol><p>更具体的步骤及代码实现可参考RateLimiter源码，这里不再赘述。</p><blockquote><p>从步骤4可以看出，初始化一个RateLimiter.create(100)，是可以执行rateLimiter.tryAcquire(200)的，只不多会将nextFreeTicketMicros再往后推进而已。</p></blockquote><h3 id="滑动时间窗口算法"><a href="#滑动时间窗口算法" class="headerlink" title="滑动时间窗口算法"></a>滑动时间窗口算法</h3><p>滑动时间窗口算法就是根据当前时间获取对应的时间窗口，时间窗口保存有流量相关的统计值，根据该统计值判断是否触发流控。</p><p><img src="/2019/07/01/chang-jian-xian-liu-fang-an-she-ji-yu-shi-xian/./常见限流方案设计与实现/9fc0e4c10c8c.png" alt="img"></p><p>一般来说，时间窗口可以循环复用，在复用时重新初始化即可，具体实现可参考sentinel的滑动窗口实现。滑动时间窗口能够支持的瞬时流量最大可为该窗口上限，而令牌桶算法能够支持的瞬时流量最大为桶大小；注意，滑动时间窗口算法中获取token数量一次最大不能超过窗口上限，而RateLimiter实现的令牌桶可以支持一次获取超过桶大小的token。</p><p><strong>分布式限流</strong></p><p>上述所说的几种限流都是单台机器上的限流算法，有些场景下我们还需要分布式限流，一种是基于Redis做分布式限流，另一种类似于Sentinel分布式限流。</p><p><strong>Sentinel</strong></p><p>Sentinel分布式限流是启动一个token server服务器，其他sentinel client端就是token client端，当做限流操作时，从token server获取token，获取成功表示未触发限流；否则表示触发了限流；通信出现异常，可配置降级走本地Sentinel限流机制。分布式限流文档：<a href="https://github.com/alibaba/Sentinel/wiki/集群流控" target="_blank" rel="noopener">Sentinel集群流控</a></p><p>sentinel的分布式限流是token client调用以下方法到服务端获取token，相当于是每次都会获取acquireCount个token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取令牌Token， 参数规则Id，获取令牌数，优先级 </span></span><br><span class="line"><span class="function">TokenResult <span class="title">requestToken</span><span class="params">(Long ruleId, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>基于Redis限流</strong></p><p>基于Redis做限流操作，使用lua脚本保证命令原子性，比如qps设置为10，如果key不存在，就设置key过期时间1s，value=1；如果value小于10，则自增value；value达到10触发流控。示例lua代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">"rate.limit:"</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, key)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">"INCR"</span>, key) &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, key, expire_time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>常用的限流算法有漏桶、令牌桶和滑动窗口，根据具体场景可选择不同限流算法；如果需要集群限流，可选用Sentinel或者基于Redis做分布式限流。</p><blockquote><p> 关于Sentinel，估计挺多小伙伴还不知道Sentinel是个什么东东，Sentinel是一个以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的框架。github地址为：<a href="https://github.com/alibaba/Sentinel。" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel。</a></p><p>笔者整理了一份《Sentinel不完全指南》，需要的小伙伴可以关注「TopCoder」公众号发送 <code>sentinel</code>来获取，《Sentinel不完全指南》和Sentinel官方文档，二者互为补充，结合起来学习Sentinel效果更好呦 : )</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentinel </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentinel dubbo适配机制</title>
      <link href="/2019/06/29/sentinel-dubbo-gua-pei-ji-zhi/"/>
      <url>/2019/06/29/sentinel-dubbo-gua-pei-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>sentinel针对目前常见的主流框架都做了适配，比如dubbo、Web Servlet、Spring Cloud、Spring WebFlux等。sentinel的适配做到了开箱即用，那么它是通过什么机制来实现的呢？这里大家可以思考下，如果一个框架本身没有扩展机制（这只是举个极端的例子，一般开源框架都是有自身的扩展机制的），那么sentinel是无法进行适配的，更谈不上开箱即用，除非更改框架源码。所以说，如果明白了框架的扩展机制，那么理解sentinel的适配机制就很easy了，比如dubbo 本身有Filter机制（consumer端和provider端都有），Web servlet也有自己的Filter机制可进行自定义扩展。</p><p>关于sentinel dubbo的使用示例，因为官方文档已经有详细说明了，这里不再赘述了。下面主要分析sentinel dubbo的实现原理。</p><p>因为dubbo提供有Filter机制，默认需要在 META-INF\dubbo\org.apache.dubbo.rpc.Filter文件中进行配置，sentinel dubbo的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sentinel.dubbo.provider.filter=com.alibaba.csp.sentinel.adapter.dubbo.SentinelDubboProviderFilter</span><br><span class="line">sentinel.dubbo.consumer.filter=com.alibaba.csp.sentinel.adapter.dubbo.SentinelDubboConsumerFilter</span><br><span class="line">dubbo.application.context.name.filter=com.alibaba.csp.sentinel.adapter.dubbo.DubboAppContextFilter</span><br></pre></td></tr></table></figure><p>此处可见，consumer端和provider端各对应一个filter类，这里以SentinelDubboProviderFilter为例进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = <span class="string">"provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDubboProviderFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// Get origin caller.</span></span><br><span class="line">        String application = DubboUtils.getApplication(invocation, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        Entry interfaceEntry = <span class="keyword">null</span>;</span><br><span class="line">        Entry methodEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// resourceName格式为 "接口:方法(入参1,入参2)"</span></span><br><span class="line">            String resourceName = DubboUtils.getResourceName(invoker, invocation);</span><br><span class="line">            String interfaceName = invoker.getInterface().getName();</span><br><span class="line">            <span class="comment">// Only need to create entrance context at provider side, as context will take effect</span></span><br><span class="line">            <span class="comment">// at entrance of invocation chain only (for inbound traffic).</span></span><br><span class="line">            <span class="comment">// 以resourceName作为context name</span></span><br><span class="line">            ContextUtil.enter(resourceName, application);</span><br><span class="line">            interfaceEntry = SphU.entry(interfaceName, EntryType.IN);</span><br><span class="line">            methodEntry = SphU.entry(resourceName, EntryType.IN, <span class="number">1</span>, invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (result.hasException()) &#123;</span><br><span class="line">                Throwable e = result.getException();</span><br><span class="line">                <span class="comment">// Record common exception.</span></span><br><span class="line">                Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">                Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> DubboFallbackRegistry.getProviderFallback().handle(invoker, invocation, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">            Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (methodEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                methodEntry.exit(<span class="number">1</span>, invocation.getArguments());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interfaceEntry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextUtil.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SentinelDubboProviderFilter中会对两个维度进行SphU.entry操作：</p><ul><li>接口维度：resouce name为interfaceName；</li><li>方法维度：resouce name为方法签名，格式为 “接口:方法(入参1,入参2)”。</li></ul><p>处理流程是，先获取接口维度的Resource，再获取方法维度的Resource，二者都获取成功之后，再执行后续的dubbo invoker操作，也就是后续的RPC处理。通过接口和方法两个不同维度，在provider端进行流控更加灵活。</p><blockquote><p>看到这块代码时，笔者有一个疑问：</p></blockquote><p>针对dubbo provider端的流控，SentinelDubboProviderFilter.invoke方法中会先对interfaceName做SphU.entry操作，然后在对method签名做SphU.entry操作，二者通过后再执行invoke后续操作。因为二者不是原子的，有可能针对interfaceName的pass，但是针对method签名的blocked，但是这个时候已经增加了interfaceName对应的pass统计值，这样同一个时间窗口内会影响到针对该接口其他方法的dubbo rpc调用。目前从代码来看，sentinel并未处理这种情况，因为目前没有针对资源的统计值做decrement功能。</p><p>试下一下，如果需要解决该问题，应该如何做呢？</p><ul><li>方案一：增加一个统计值decrement功能，如果针对method签名执行SphU.entry操作被blocked时，调用统计值decrement功能，撤销之前相同时间窗口内针对interfaceName的pass值；</li><li>方案二：像这种需要针对两个resource做SphU.entry操作的场景，可以在判断是否通过pass时同时判断这两个resource对应的统计值是否满足规则限制，让这两个Resource产生关联，一同判断即可。</li></ul><p>笔者倾向于方案二的实现，其实现流程和单个Resource的类似（只不过新增个Resource判断条件），而不像方案一那样需要提供新的方法+增加撤销逻辑来满足，严格来讲，方案一在对资源申请和撤销操作之间，也是会暂用一个pass名额的。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentinel 集群流控原理</title>
      <link href="/2019/06/29/sentinel-ji-qun-liu-kong-yuan-li/"/>
      <url>/2019/06/29/sentinel-ji-qun-liu-kong-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>为什么需要集群流控呢？假设需要将某个API的总qps限制在100，机器数可能为50，这时很自然的想到使用一个专门的server来统计总的调用量，其他实例与该server通信来判断是否可以调用，这就是基本的集群流控方式，sentinel的实现就是这样的。</p><p>如果服务调用使用轮训或者随机路由方式，理论上可以通过在各个单机上设置流控规则即可（<code>单机qps上限=总qps上限 / 机器数</code>）。集群流控可以解决流量分配不均的问题导致总体流控效果不佳的问题，其可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果，不过由于会与server进行通信，所以性能上会有一定损耗。</p><p>集群流控中共有两种身份：</p><ul><li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li><li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li></ul><p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p><ul><li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li><li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li><li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（TokenService），默认实现是复用 sentinel-core 的相关逻辑</li></ul><p>大致了解集群流控概念之后，下面一起分析下集群流控规则、client端和server端各自处理机制~</p><h3 id="集群流控规则"><a href="#集群流控规则" class="headerlink" title="集群流控规则"></a>集群流控规则</h3><p>FlowRule 添加了两个字段用于集群限流相关配置，如下所示。clusterMode在方法<code>FlowRuleChecker.canPassCheck</code>中会用到进行判断是否是集群流控，false表示单机流控；true表示集群流控，会调用方法passClusterCheck与集群流控server端通信判断是否触发了流控，此时异常降级策略为本地流控(<em>fallbackToLocalOrPass方法，fallbackToLocalWhenFail属性为true时执行本地流控，否则直接返回ture不走流控检查</em>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterMode; <span class="comment">// 标识是否为集群限流配置</span></span><br><span class="line"><span class="keyword">private</span> ClusterFlowConfig clusterConfig; <span class="comment">// 集群限流相关配置项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterFlowConfig属性</span></span><br><span class="line"><span class="keyword">private</span> Long flowId; <span class="comment">// 全局唯一的规则 ID，由集群限流管控端分配.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL; <span class="comment">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> fallbackToLocalWhenFail = <span class="keyword">true</span>; <span class="comment">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPassCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    String limitApp = rule.getLimitApp();</span><br><span class="line">    <span class="keyword">if</span> (limitApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rule.isClusterMode()) &#123;<span class="comment">// 集群模式</span></span><br><span class="line">        <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单机模式流控</span></span><br><span class="line">    <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>flowId</strong> 代表全局唯一的规则 ID，Sentinel 集群限流服务端通过此 ID 来区分各个规则，因此务必保持全局唯一。一般 flowId 由统一的管控端进行分配，或写入至 DB 时生成。</li><li><strong>thresholdType</strong> 代表集群限流阈值模式。单机均摊模式表示总qps阈值等于机器数*单机qps阈值；全局阈值等于整个集群配置的阈值。</li><li><strong>strategy</strong> 集群策略，默认<code>FLOW_CLUSTER_STRATEGY_NORMAL</code>，针对ClusterFlowConfig配置该属性为FLOW_CLUSTER_STRATEGY_NORMAL才合法，除此之外，暂无太多业务意义。</li></ul><h3 id="client端处理机制"><a href="#client端处理机制" class="headerlink" title="client端处理机制"></a>client端处理机制</h3><p>client端的处理机制和单机是一样的，只不过clusterMode和clusterConfig属性配置上了而已，具体的client使用可以参考官方文档 <a href="https://github.com/alibaba/Sentinel/wiki/集群流控" target="_blank" rel="noopener">集群流控</a>，这里不再赘述。如果是集群流控，在<code>FlowRuleChecker.canPassCheck</code>方法中会调用方法<code>passClusterCheck</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passClusterCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TokenService clusterService = pickClusterService();</span><br><span class="line">        <span class="keyword">if</span> (clusterService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为null降级处理</span></span><br><span class="line">            <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> flowId = rule.getClusterConfig().getFlowId();</span><br><span class="line">        TokenResult result = clusterService.requestToken(flowId, acquireCount, prioritized);</span><br><span class="line">        <span class="keyword">return</span> applyTokenResult(result, rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">"[FlowRuleChecker] Request cluster token unexpected failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 降级处理 本地限流</span></span><br><span class="line">    <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestToken负责与token server端通信，入参包括<code>flowId, acquireCount, prioritized</code>，这里是没有Resource信息的，server端通过flowid来获取对应规则进行流控判断。注意，调用writeAndFlush发送请求之后等待响应结果，最大等待时间<code>ClusterClientConfigManager.getRequestTimeout()</code>；请求发送过程中，出现任何异常或者返回错误（这里不包括BLOCKED情况），都会默认走降级本地流控逻辑：<code>fallbackToLocalOrPass</code>。</p><blockquote><p>了解了client端处理流程，接下来看下server端处理流程，client和server端都是用netty作为底层网络通信服务，关于netty的原理不是本文讨论的重点因此会简单带过。如果小伙伴们还不太熟悉netty，请参阅对应资料即可。对于netty，每个Java开发者都需要了解甚至是熟悉的，这样不仅仅帮助我们理解NIO及Reactor模型，还能再阅读基于netty的框架源码（比如dubbo/rocketmq等）时，将重点关注在框架本身实现上，而不是网络通信流程及细节上。</p></blockquote><h3 id="server端处理机制"><a href="#server端处理机制" class="headerlink" title="server端处理机制"></a>server端处理机制</h3><p>Sentinel 集群限流服务端有两种启动方式：</p><ul><li><strong>独立模式</strong>（Alone），即作为独立的 token server 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 Global Rate Limiter 给集群提供流控服务。</li><li><img src="/2019/06/29/sentinel-ji-qun-liu-kong-yuan-li/./sentinel-集群流控原理/50463606-c3d26c00-09c7-11e9-8373-1c27e2408f8b.png" alt></li><li><strong>嵌入模式</strong>（Embedded），即作为内置的 token server 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，token server 和 client 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 token server 的总 QPS，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li><li><img src="/2019/06/29/sentinel-ji-qun-liu-kong-yuan-li/./sentinel-集群流控原理/50463600-b7e6aa00-09c7-11e9-9580-6919f0d0a8a4.png" alt="image"></li></ul><p>目前针对token server高可用，sentinel并没有对应的解决方案，不过没有并不意味着没考虑，因为默认可以降级走本地流控。sentinel作为一个限流组件，在大部分应用场景中，如果token server挂了降级为本地流控就可以满足了。</p><blockquote><p> 如果必须考虑token server高可用，可考虑token server集群部署，每个token server都能访问（或存储）全量规则数据，多个client通过特定路由规则分配到不同的token server（相同类型服务路由到同一个token server，不同类型服务可路由到不同token server），token server故障时提供failover机制即可。如果此时考虑到相同类型服务出现网络分区，也就是一部分服务可以正常与token server通信，另一个部分服务无法正常与token server通信，如果无法正常通信的这部分服务直接进行failover，会导致集群限流不准的问题，可通过zookeeper来保存在线的token server，如果zookeeper中token server列表有变化，再进行failover；此情况下再出现任何形式的网络分区，再执行降级逻辑，执行本地限流。</p></blockquote><p>server端不管是独立模式还是嵌入模式，都是通过<code>NettyTransportServer</code>来启动的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline p = ch.pipeline();</span><br><span class="line">                p.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">                p.addLast(<span class="keyword">new</span> NettyRequestDecoder());</span><br><span class="line">                p.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">2</span>));</span><br><span class="line">                p.addLast(<span class="keyword">new</span> NettyResponseEncoder());</span><br><span class="line">                p.addLast(<span class="keyword">new</span> TokenServerHandler(connectionPool));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    b.bind(port).addListener(<span class="keyword">new</span> GenericFutureListener&lt;ChannelFuture&gt;() &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑主要是netty启动逻辑，重点关注initChannel方法，这些是往pipeline添加自定义channelHandler，主要是处理粘包、编解码器和业务处理Handler，这里最重要的是TokenServerHandler，因为是请求处理逻辑，所以重点关注其channelRead方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 全局保存channel</span></span><br><span class="line">    globalConnectionPool.refreshLastReadTime(ctx.channel());</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ClusterRequest) &#123;</span><br><span class="line">        ClusterRequest request = (ClusterRequest)msg;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == ClusterConstants.MSG_TYPE_PING) &#123;</span><br><span class="line">            <span class="comment">// ping请求处理，会记录namespace信息</span></span><br><span class="line">            handlePingRequest(ctx, request);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据request type获取对应处理器</span></span><br><span class="line">           <span class="comment">// 针对集群流控，type为MSG_TYPE_FLOW</span></span><br><span class="line">        RequestProcessor&lt;?, ?&gt; processor = RequestProcessorProvider.getProcessor(request.getType());</span><br><span class="line">        ClusterResponse&lt;?&gt; response = processor.processRequest(request);</span><br><span class="line">        writeResponse(ctx, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对集群流控，type为<code>MSG_TYPE_FLOW</code>，对应处理器为<code>FlowRequestProcessor</code>。首先会提取请求入参 <code>flowId, acquireCount, prioritized</code>，主要步骤如下：</p><ul><li>根据flowId获取规则，为空返回结果NO_RULE_EXISTS；</li><li>获取请求namespace对应的RequestLimiter，非空时进行tryPass限流检查，该检查是针对namespace维度；</li><li>针对flowId对应规则进行限流检查，acquireCount表示该请求需要获取的token数，数据检查基于滑动时间窗口统计来判断的。</li></ul><p>根据限流规则检查之后，会统计相关的<code>PASS/BLOCK/PASS_REQUEST/BLOCK_REQUEST</code>等信息，该流程和单机流控流程是类似的，具体代码不再赘述。处理完成之后，会返回client端处理结果，至此整个集群流控流程就分析完了。</p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentinel 滑动窗口统计机制</title>
      <link href="/2019/06/29/sentinel-hua-dong-chuang-kou-tong-ji-ji-zhi/"/>
      <url>/2019/06/29/sentinel-hua-dong-chuang-kou-tong-ji-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sentinel的滑动窗口统计机制就是根据当前时间，获取对应的时间窗口，并更新该时间窗口中的各项统计指标（pass/block/rt等），这些指标被用来进行后续判断，比如限流、降级等；随着时间的推移，当前时间点对应的时间窗口是变化的，这时会涉及到时间窗口的初始化、复用等。可以说，sentinel上的功能所用到的数据几乎都是滑动窗口统计机制来维护和更新的。</p></blockquote><p>sentinel 处理流程是基于slot链(ProcessorSlotChain)来完成的，比如限流、熔断等，其中重要的一个slot就是<code>StatisticSlot</code>，它是做各种数据统计的，而限流/熔断的数据判断来源就是StatisticSlot，StatisticSlot的各种数据统计都是基于滑动窗口来完成的，因此本文就重点分析StatisticSlot的滑动窗口统计机制。</p><p>sentinel 的slot链(<code>ProcessorSlotChain</code>)是责任链模式的体现，那SlotChain是在哪创建的呢？是在 <code>CtSph.lookProcessChain()</code>方法中创建的，并且该方法会根据当前请求的资源先去一个静态的HashMap中获取，如果获取不到才会创建，创建后会保存到HashMap中。这就意味着，同一个资源会全局共享一个SlotChain。默认生成ProcessorSlotChain逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSlotChainBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个处理过程从第一个slot往后一直传递到最后一个的，当到达StatisticSlot时，开始统计各项指标，统计的结果又会被后续的Slot所采用，作为各种规则校验的依据。各种指标如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MetricEvent &#123;</span><br><span class="line">    PASS, <span class="comment">// Normal pass.</span></span><br><span class="line">    BLOCK, <span class="comment">// Normal block.</span></span><br><span class="line">    EXCEPTION, <span class="comment">// 异常统计</span></span><br><span class="line">    SUCCESS,</span><br><span class="line">    RT, <span class="comment">// rt统计</span></span><br><span class="line">    OCCUPIED_PASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StatisticSlot-entry流程"><a href="#StatisticSlot-entry流程" class="headerlink" title="StatisticSlot.entry流程"></a>StatisticSlot.entry流程</h3><p>处理流程走到StatisticSlot时，首先触发后续slot.entry方法，然后统计各项指标，后续slot中数据判断来源就是这里统计的各项指标。StatisticSlot.entry 逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 触发下一个Slot的entry方法</span></span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, args);</span><br><span class="line">        <span class="comment">// 如果能通过SlotChain中后面的Slot的entry方法，说明没有被限流或降级</span></span><br><span class="line">        <span class="comment">// 统计信息</span></span><br><span class="line">        node.increaseThreadNum();</span><br><span class="line">        node.addPassRequest();</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        context.getCurEntry().setError(e);</span><br><span class="line">        <span class="comment">// Add block count.</span></span><br><span class="line">        node.increaseBlockedQps();</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        context.getCurEntry().setError(e);</span><br><span class="line">        <span class="comment">// Should not happen</span></span><br><span class="line">        node.increaseExceptionQps();</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，StatisticSlot主要就做了3件事：</p><ol><li>触发后续slot的entry方法，进行规则校验</li><li>校验通过则更新node实时指标数据</li><li>校验不通过则更新node异常指标数据</li></ol><p>注意：由于后续的<code>fireEntry</code>操作和更新本次统计信息是两个操作，不是原子的，会造成限流不准的小问题，比如设置的FlowRule count为20，并发情况下可能稍大于20，不过针对大部分场景来说，这点偏差是可以容忍的，毕竟我们要的是限流效果，而不是必须精确的限流操作。</p><h3 id="更新node实时指标数据"><a href="#更新node实时指标数据" class="headerlink" title="更新node实时指标数据"></a>更新node实时指标数据</h3><p>我们可以看到 node.addPassRequest() 这段代码是在fireEntry执行之后执行的，这意味着，当前请求通过了sentinel的流控等规则，此时需要将当次请求记录下来，也就是执行 node.addPassRequest() 这行代码，具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultNode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPassRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.addPassRequest();</span><br><span class="line">    <span class="keyword">this</span>.clusterNode.addPassRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的node是一个 DefaultNode 实例，这里特别补充一个 DefaultNode 和 ClusterNode 的区别：</p><ul><li>DefaultNode：保存着某个resource在某个context中的实时指标，每个DefaultNode都指向一个ClusterNode。</li><li>ClusterNode：保存着某个resource在所有的context中实时指标的总和，同样的resource会共享同一个ClusterNode，不管他在哪个context中。</li></ul><p>上面代码不管是 DefaultNode 还是 ClusterNode ，走的都是StatisticNode 对象的 addPassRequest 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(<span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPassRequest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    rollingCounterInSecond.addPass(count); <span class="comment">// 对每秒指标统计</span></span><br><span class="line">    rollingCounterInMinute.addPass(count); <span class="comment">// 每分钟指标统计</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个通过的指标（pass）都是调用Metric 的接口进行操作的，并且是通过 ArrayMetric 这种实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayMetric</span><span class="params">(<span class="keyword">int</span> windowLength, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> WindowLeapArray(windowLength, interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPass</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间窗口</span></span><br><span class="line">    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();</span><br><span class="line">    wrap.value().addPass(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 currentWindow() 获取当前时间窗口，然后更新当前时间窗口对应的统计指标，以下代码重点关注几个判断逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeapArray</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentWindow(TimeUtil.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TimeUtil</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentTimeMillis是由一个tick线程每个1ms更新一次，具体逻辑在TimeUtil类中</span></span><br><span class="line">    <span class="keyword">return</span> currentTimeMillis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LeapArray</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算当前时间点落在滑动窗口的下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">    <span class="comment">// Calculate current bucket start time.</span></span><br><span class="line">    <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间点对应的windowWrap，array为AtomicReferenceArray</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.为空表示当前时间窗口为初始化过，创建WindowWrap并cas设置到array中</span></span><br><span class="line">            WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket());</span><br><span class="line">            <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 2.获取的时间窗口正好对应当前时间，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 3.获取的时间窗口为老的，进行reset操作复用</span></span><br><span class="line">            <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 4.时间回拨了，正常情况下不会走到这里</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前时间窗口对应的WindowWrap之后，就可以进行更新操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrap.value().addPass(count);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPass</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    add(MetricEvent.PASS, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MetricBucket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MetricBucket <span class="title">add</span><span class="params">(MetricEvent event, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应MetricEvent枚举中值</span></span><br><span class="line">    counters[event.ordinal()].add(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止，整个指标统计流程就完成了，下面重点看下滑动窗口机制。</p><h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>时间窗口是用WindowWrap对象表示的，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> windowLengthInMs;  <span class="comment">// 时间窗口的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> windowStart; <span class="comment">// 时间窗口开始时间</span></span><br><span class="line"><span class="keyword">private</span> T value; <span class="comment">// MetricBucket对象，保存各个指标数据</span></span><br></pre></td></tr></table></figure><p>sentinel时间基准由tick线程来做，每1ms更新一次时间基准，逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemon.setName(<span class="string">"sentinel-time-tick-thread"</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure><p>sentinel默认有每秒和每分钟的滑动窗口，对应的LeapArray类型，它们的初始化逻辑是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> windowLengthInMs; <span class="comment">// 单个滑动窗口时间值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> sampleCount; <span class="comment">// 滑动窗口个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> intervalInMs; <span class="comment">// 周期值（相当于所有滑动窗口时间值之和）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeapArray</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.windowLengthInMs = intervalInMs / sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.intervalInMs = intervalInMs;</span><br><span class="line">    <span class="keyword">this</span>.sampleCount = sampleCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt;(sampleCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每秒滑动窗口，<code>windowLengthInMs=500，sampleCount=2，intervalInMs=1000</code>，针对每分钟滑动窗口，<code>windowLengthInMs=1000，sampleCount=60，intervalInMs=60000</code>，对应代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(<span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>currentTimeMillis时间基准（tick线程）每1ms更新一次，通过currentWindow(timeMillis)方法获取当前时间点对应的WindowWrap对象，然后更新对应的各种指标，用于做限流、降级时使用。注意，当前时间基准对应的事件窗口初始化时lazy模式，并且会复用的。</p></blockquote><p>Sentinel 底层采用高性能的滑动窗口数据结构 LeapArray 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。最后以一张图结束吧：</p><p><img src="/2019/06/29/sentinel-hua-dong-chuang-kou-tong-ji-ji-zhi/./sentinel-滑动窗口统计机制/9fc0e4c10c8c-1561793702083.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentinel 核心概念</title>
      <link href="/2019/06/27/sentinel-he-xin-gai-nian/"/>
      <url>/2019/06/27/sentinel-he-xin-gai-nian/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 前段时间笔者在团队内部分享了sentinel原理设计与实现，主要讲解了sentinel基础概念和工作原理，工作原理部分大家听了基本都了解了，但是对于sentinel的几个概念及其之间的关系还有挺多同学有点模糊的，趁着这几天比较空，针对sentinel的几个核心概念，做了一些总结，希望能帮助一些sentinel初学者理清这些概念之间的关系。</p><p> PS：本文主要参考sentinel源码实现和部分官方文档，建议小伙伴阅读本文的同时也大致看下官方文档和源码，学习效果更好呦 : )*  官方文档讲解的其实还是挺详细的，但是对于这些概念之间的关系可能对于初学者来说还有点不够。</p><p> 估计挺多小伙伴还不知道Sentinel是个什么东东，Sentinel是一个以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的框架。github地址为：<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel</a></p></blockquote><h3 id="资源和规则"><a href="#资源和规则" class="headerlink" title="资源和规则"></a>资源和规则</h3><p><strong>资源</strong>是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p><p>围绕资源的实时状态设定的<strong>规则</strong>，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><p>sentinel中调用SphU或者SphO的entry方法获取限流资源，不同的是前者获取限流资源失败时会抛BlockException异常，后者或捕获该异常并返回false，二者的实现都是基于CtSph类完成的。简单的sentinel示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    entry = SphU.entry(KEY);</span><br><span class="line">    System.out.println(<span class="string">"entry ok..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">    <span class="comment">// 获取限流资源失败</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">    <span class="comment">// biz exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (SphO.entry(KEY)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"entry ok"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取限流资源失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SphU和SphO二者没有孰优孰略问题，底层实现是一样的，根据不同场景选举合适的一个即可。看了简单示例之后，一起来看下sentinel中的核心概念，便于理解后续内容。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>resource是sentinel中最重要的一个概念，sentinel通过资源来保护具体的业务代码或其他后方服务。sentinel把复杂的逻辑给屏蔽掉了，用户只需要为受保护的代码或服务定义一个资源，然后定义规则就可以了，剩下的通通交给sentinel来处理了。并且资源和规则是解耦的，规则甚至可以在运行时动态修改。定义完资源后，就可以通过在程序中埋点来保护你自己的服务了，埋点的方式有两种：</p><ul><li>try-catch 方式（<code>通过 SphU.entry(...)</code>），当 catch 到BlockException时执行异常处理(或fallback)</li><li>if-else 方式（<code>通过 SphO.entry(...)</code>），当返回 false 时执行异常处理(或fallback)</li></ul><p>以上这两种方式都是通过硬编码的形式定义资源然后进行资源埋点的，对业务代码的侵入太大，从0.1.1版本开始，sentinel加入了注解的支持，可以通过注解来定义资源，具体的注解为：SentinelResource 。通过注解除了可以定义资源外，还可以指定 blockHandler 和 fallback 方法。</p><p>在sentinel中具体表示资源的类是：ResourceWrapper ，他是一个抽象的包装类，包装了资源的 Name 和EntryType。他有两个实现类，分别是：StringResourceWrapper 和 MethodResourceWrapper。顾名思义，StringResourceWrapper 是通过对一串字符串进行包装，是一个通用的资源包装类，MethodResourceWrapper 是对方法调用的包装。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context是对资源操作时的上下文环境，每个资源操作(<code>针对Resource进行的entry/exit</code>)必须属于一个Context，如果程序中未指定Context，会创建name为”sentinel_default_context”的默认Context。一个Context生命周期内可能有多个资源操作，Context生命周期内的最后一个资源exit时会清理该Context，这也预示这真个Context生命周期的结束。Context主要属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">// context名字，默认名字 "sentinel_default_context"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// context入口节点，每个context必须有一个entranceNode</span></span><br><span class="line">    <span class="keyword">private</span> DefaultNode entranceNode;</span><br><span class="line">    <span class="comment">// context当前entry，Context生命周期中可能有多个Entry，所有curEntry会有变化</span></span><br><span class="line">    <span class="keyword">private</span> Entry curEntry;</span><br><span class="line">    <span class="comment">// The origin of this context (usually indicate different invokers, e.g. service consumer name or origin IP).</span></span><br><span class="line">    <span class="keyword">private</span> String origin = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：一个Context生命期内Context只能初始化一次，因为是存到ThreadLocal中，并且只有在非null时才会进行初始化。</em></p><p>如果想在调用 SphU.entry() 或 SphO.entry() 前，自定义一个context，则通过ContextUtil.enter()方法来创建。context是保存在ThreadLocal中的，每次执行的时候会优先到ThreadLocal中获取，为null时会调用 <code>MyContextUtil.myEnter(Constants.CONTEXT_DEFAULT_NAME, &quot;&quot;, resourceWrapper.getType())</code>创建一个context。当Entry执行exit方法时，如果entry的parent节点为null，表示是当前Context中最外层的Entry了，此时将ThreadLocal中的context清空。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>刚才在Context身影中也看到了Entry的出现，现在就谈谈Entry。每次执行 SphU.entry() 或 SphO.entry() 都会返回一个Entry，Entry表示一次资源操作，内部会保存当前invocation信息。在一个Context生命周期中多次资源操作，也就是对应多个Entry，这些Entry形成parent/child结构保存在Entry实例中，entry类CtEntry结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtEntry</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Entry parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Entry child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ProcessorSlot&lt;Object&gt; chain;</span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> Node curNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Node&#125; of the specific origin, Usually the origin is the Service Consumer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node originNode;</span><br><span class="line">    <span class="keyword">private</span> Throwable error; <span class="comment">// 是否出现异常</span></span><br><span class="line">    <span class="keyword">protected</span> ResourceWrapper resourceWrapper; <span class="comment">// 资源信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry实例代码中出现了Node，这个又是什么东东呢 :(，咱们接着往下看：</p><h3 id="DefaultNode"><a href="#DefaultNode" class="headerlink" title="DefaultNode"></a>DefaultNode</h3><p>Node（<em>关于StatisticNode的讨论放到下一小节</em>）默认实现类DefaultNode，该类还有一个子类EntranceNode；context有一个entranceNode属性，Entry中有一个curNode属性。</p><ul><li><strong>EntranceNode</strong>：该类的创建是在初始化Context时完成的（ContextUtil.trueEnter方法），注意该类是针对Context维度的，也就是一个context有且仅有一个EntranceNode。</li><li><strong>DefaultNode</strong>：该类的创建是在NodeSelectorSlot.entry完成的，当不存在context.name对应的DefaultNode时会新建（new DefaultNode(resourceWrapper, null)，对应resouce）并保存到本地缓存（NodeSelectorSlot中private volatile Map&lt;String, DefaultNode&gt; map）；获取到context.name对应的DefaultNode后会将该DefaultNode设置到当前context的curEntry.curNode属性，也就是说，在NodeSelectorSlot中是一个context有且仅有一个DefaultNode。</li></ul><p>看到这里，你是不是有疑问？为什么一个context有且仅有一个DefaultNode，我们的resouece跑哪去了呢，其实，这里的一个context有且仅有一个DefaultNode是在NodeSelectorSlot范围内，NodeSelectorSlot是ProcessorSlotChain中的一环，获取ProcessorSlotChain是根据Resource维度来的。总结为一句话就是：<strong>针对同一个Resource，多个context对应多个DefaultNode；针对不同Resource，(不管是否是同一个context)对应多个不同DefaultNode</strong>。这还没看明白 : (，好吧，我不bb了，上图吧：</p><p><img src="/2019/06/27/sentinel-he-xin-gai-nian/./sentinel-核心概念/clipboard.png" alt="img"></p><p>DefaultNode结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultNode</span> <span class="keyword">extends</span> <span class="title">StatisticNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ResourceWrapper id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The list of all child nodes.</span></span><br><span class="line"><span class="comment">     * 子节点集合，注意：目前版本sentinel中子节点个数最多为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;Node&gt; childList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associated cluster node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClusterNode clusterNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Resouce只有一个clusterNode，多个defaultNode对应一个clusterNode，如果defaultNode.clusterNode为null，则在ClusterBuilderSlot.entry中会进行初始化。</p><p>同一个Resource，对应同一个ProcessorSlotChain，这块处理逻辑在lookProcessChain方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = chainMap.get(resourceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            chain = chainMap.get(resourceWrapper);</span><br><span class="line">            <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Entry size limit.</span></span><br><span class="line">                <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                chain = SlotChainProvider.newSlotChain();</span><br><span class="line">                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                    chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                newMap.putAll(chainMap);</span><br><span class="line">                newMap.put(resourceWrapper, chain);</span><br><span class="line">                chainMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StatisticNode"><a href="#StatisticNode" class="headerlink" title="StatisticNode"></a>StatisticNode</h3><p>StatisticNode中保存了资源的实时统计数据（基于滑动时间窗口机制），通过这些统计数据，sentinel才能进行限流、降级等一系列操作。StatisticNode属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticNode</span> <span class="keyword">implements</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒级的滑动时间窗口（时间窗口单位500ms）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT,</span><br><span class="line">        IntervalProperty.INTERVAL);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分钟级的滑动时间窗口（时间窗口单位1s）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The counter for thread count. </span></span><br><span class="line"><span class="comment"> * 线程个数用户触发线程数流控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LongAdder curThreadNum = <span class="keyword">new</span> LongAdder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMetric</span> <span class="keyword">implements</span> <span class="title">Metric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeapArray&lt;MetricBucket&gt; data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricBucket</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存统计值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder[] counters;</span><br><span class="line"><span class="comment">// 最小rt</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> minRt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中MetricBucket.counters数组大小为MetricEvent枚举值的个数，每个枚举对应一个统计项，比如PASS表示通过个数，限流可根据通过的个数和设置的限流规则配置count大小比较，得出是否触发限流操作，所有枚举值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MetricEvent &#123;</span><br><span class="line">    PASS, <span class="comment">// Normal pass.</span></span><br><span class="line">    BLOCK, <span class="comment">// Normal block.</span></span><br><span class="line">    EXCEPTION,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    RT,</span><br><span class="line">    OCCUPIED_PASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>slot是另一个sentinel中非常重要的概念，sentinel的工作流程就是围绕着一个个插槽所组成的插槽链来展开的。需要注意的是每个插槽都有自己的职责，他们各司其职完好的配合，通过一定的编排顺序，来达到最终的限流降级的目的。默认的各个插槽之间的顺序是固定的，因为有的插槽需要依赖其他的插槽计算出来的结果才能进行工作。</p><p>但是这并不意味着我们只能按照框架的定义来，sentinel 通过 SlotChainBuilder 作为 SPI 接口，使得 Slot Chain 具备了扩展的能力。我们可以通过实现 SlotsChainBuilder 接口加入自定义的 slot 并自定义编排各个 slot 之间的顺序，从而可以给 sentinel 添加自定义的功能。</p><p>那SlotChain是在哪创建的呢？是在 CtSph.lookProcessChain() 方法中创建的，并且该方法会根据当前请求的资源先去一个静态的HashMap中获取，如果获取不到才会创建，创建后会保存到HashMap中。这就意味着，同一个资源会全局共享一个SlotChain。默认生成ProcessorSlotChain为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSlotChainBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解ConcurrentHashMap</title>
      <link href="/2019/06/19/shen-ru-li-jie-concurrenthashmap/"/>
      <url>/2019/06/19/shen-ru-li-jie-concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<p>以下ConcurrentHashMap以jdk8中为例进行分析，ConcurrentHashMap是一个线程安全、基于数组+链表(或者红黑树)的kv容器，主要特性如下：</p><ul><li>线程安全，数组中单个slot元素个数超过8个时会将链表结构转换成红黑树，注意树节点之间还是有next指针的；</li><li>当元素个数超过N（<code>N = tab.length - tab.length&gt;&gt;&gt;2，达到0.75阈值时</code>）个时触发rehash，成倍扩容；</li><li>当线程扩容时，其他线程put数据时会加入帮助扩容，加快扩容速度；</li><li>put时对单个slot头节点元素进行synchronized加锁，ConcurrentHashMap中的加锁粒度是针对slot节点的，rehash过程中加锁粒度也是如此；</li><li>get时一般是不加锁。如果slot元素为链表，直接读取返回即可；如果slot元素为红黑树，并且此时该树在进行再平衡或者节点删除操作，读取操作会按照树节点的next指针进行读取，也是不加锁的（因为红黑树中节点也是有链表串起来的）；如果该树并没有进行平衡或者节点删除操作，那么会用CAS加读锁，防止读取过程中其他线程该树进行更新操作（主要是防止破坏红黑树节点之间的链表特性），破坏“读视图”。</li></ul><p>ConcurrentHashMap默认数组长度16，map最大容量为<code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code>。创建ConcurrentHashMap并不是涉及数组的初始化，数组初始化是在第一次put数据才进行的。（注意：JDK1.8中舍弃了之前的分段锁技术，改用CAS+Synchronized机制）</p><h2 id="Node结构"><a href="#Node结构" class="headerlink" title="Node结构"></a>Node结构</h2><p>ConcurrentHashMap中一个重要的类就是Node，该类存储键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是有一些差别是ConcurrentHashMap的value和next属性都是volatile的（<code>保证了get数据时直接返回即可，volatile保证了更新的可见性</code>），且不允许调用setValue方法直接改变Node的value域，增加了find方法辅助map.get()方法，可在get方法返回的结果中更改对应的value值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap定义了三个原子操作，用于对数组指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得在i位置上的Node节点  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少  </span></span><br><span class="line"><span class="comment">//在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改  </span></span><br><span class="line"><span class="comment">//因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//利用volatile方法设置节点位置的值  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;  </span><br><span class="line">   U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就按照ConcurrentHashMap的 <strong>put / get / remove</strong> 来分析下其实现原理，中间涉及rehash、红黑树转换等。</p><h2 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h2><p>put操作流程如下：</p><ul><li>首先根据key的hashCode计算hash，然后根据hash计算应该在数组中存储位置，如果数据为null，新建数组；</li><li>然后通过tabAt（&amp;操作）直接获取对应slot。如果slot为null，则新建kv节点（Node类型）放到slot；</li><li>如果当前slot节点的hash值等于MOVED（等于-1），表示其类型为ForwardingNode，证明其他线程在进行rehash扩容操作，当前线程也会帮助一起进行扩容操作；</li><li>然后对slot节点进行synchronized加锁，如果slot节点hash值大于等于0，表示当前slot对应元素为链表结构，遍历当前链表，如果key存在则更新，否则添加到链表尾部；如果slot节点类型为TreeBin（其hash值为-2），表示slot对应元素为红黑树，则在红黑树中进行更新节点或者添加节点操作，注意，最后如果树不平衡会进行树的再平衡操作，此时对树root节点加CAS写锁。</li><li>最后，如果新添加了节点，会统计map size值；如果当前map数量超过了阈值（<code>N = tab.length - tab.length&gt;&gt;&gt;2</code>）会触发rehash扩容，按照成倍扩容。</li></ul><p>注意：因为往map中添加元素和增加元素统计值是两个步骤，不是原子的，所以获取map.size()时可能不是准确值。</p><p><strong>对key的hashCode计算hash</strong></p><p>存到map中的key并不是直接按照hashCode计算的，因为hashCode有可能为负的，并且不合理的hashCode实现可能导致较多冲突，因此ConcurrentHashMap中会对key对hashCode进行hash操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int hash = spread(key.hashCode());</span></span><br><span class="line"><span class="comment">// HASH_BITS = 0x7fffffff 符号位设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>红黑树节点比较</strong></p><p>既然使用到了红黑树，这就涉及到节点的大小比较问题（节点数据包含key、value信息）。进行节点的大小比较时，首先是比较节点的hash值，注意hash值不是hashCode，因为hash值是对象hashCode与自己无符号右移16位进行异或后的值。如果节点的hash值相等，判断节点的key对象是否实现了Comparable接口，实现的话就是用Comparable逻辑比较节点之间的大小。如果key对象未实现Comparable接口，则调用tieBreakOrder方法进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dir = tieBreakOrder(k, pk); k/pk，带比较两个节点，命名还是挺有意思的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">(d = a.getClass().getName().</span><br><span class="line"> compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line"> -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>这里调用了System.identityHashCode，将由默认方法hashCode()返回，如果对象的hashCode()被重写，则System.identityHashCode和hashCode()的返回值就不一样了。</em></p><p><strong>put源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// key value非空</span></span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"><span class="comment">// slot对应元素个数，链表转换成红黑树时用</span></span><br><span class="line"><span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">tab = initTable();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line"><span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line"><span class="comment">// 在rehash扩容，帮助扩容，扩容完成之后才能继续进行put操作</span></span><br><span class="line">tab = helpTransfer(tab, f);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">V oldVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 可能已经被更新需要再次进行判断</span></span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 节点更新或插入</span></span><br><span class="line">binCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">K ek;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((ek = e.key) == key ||</span><br><span class="line"> (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">oldVal = e.val;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">e.val = value;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; pred = e;</span><br><span class="line"><span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">  value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树更新或插入</span></span><br><span class="line">Node&lt;K,V&gt; p;</span><br><span class="line">binCount = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">   value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">oldVal = p.val;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">p.val = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">treeifyBin(tab, i);</span><br><span class="line"><span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> oldVal;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加统计值，可能触发rehash扩容</span></span><br><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * counterCells非空表示当前put并发较大，按照counterCells进行分线程统计</span></span><br><span class="line"><span class="comment"> * 参考LongAddr思想</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">!U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">(a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">!(uncontended =</span><br><span class="line">  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">fullAddCount(x, uncontended);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">s = sumCount();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"><span class="comment">// 大于等于阈值数时进行扩容操作</span></span><br><span class="line"><span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"><span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">transfer(tab, nt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line"> (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">s = sumCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h2><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件hash值相同同时 key相同（equals） ，对于节点可能在链表或树上的情况，需要分别去查找。</p><p>get时一般是不加锁（Node节点中value数据类型是volatile的，保证了内存可见性）。如果slot元素为链表，直接读取返回即可；如果slot元素为红黑树，并且此时该树在进行再平衡或者节点删除操作，读取操作会按照树节点的next指针进行读取，也是不加锁的；如果该树并没有进行平衡或者节点删除操作，那么会用CAS加读锁，防止读取过程中其他线程该树进行更新操作，破坏“读视图”。</p><h2 id="remove流程"><a href="#remove流程" class="headerlink" title="remove流程"></a>remove流程</h2><p>remove流程就是根据key找到对应节点，将该节点从链表（更改节点前后关系）或者红黑树移除的过程，注意，从红黑树中删除元素后，不会将红黑树转换为列表的，只能在put元素时列表可能有转换红黑树操作，不会有反向操作。</p><p>注意：hashMap有自动rehash扩容机制，但是当元素remove之后并没有自动缩容机制，如果数组经过多次扩容变得很大，并且当前元素较少，请将这些元素转移到一个新的HashMap中。</p><h2 id="rehash流程"><a href="#rehash流程" class="headerlink" title="rehash流程"></a>rehash流程</h2><p>rehash时是成倍扩容（老table和新tableNew），对于table中i位置的所有元素，扩容后会被分配到i和i+table.length这两个位置中。rehash主要的流程transfer方法中，具体不再展开。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 基础数据结构</title>
      <link href="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/"/>
      <url>/2019/06/03/redis-ji-chu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>Redis用到的底层数据结构有：简单动态字符串、双端链表、字典、压缩列表、整数集合、跳跃表等，Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些基础数据结构创建了一个对象系统，这写对象包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象等。<br><a id="more"></a></p><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>redis自定义了简单动态字符串数据结构（sds），并将其作为默认字符串表示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt; &#123;</span></span><br><span class="line">    T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">    T len; <span class="comment">// 数组长度</span></span><br><span class="line">    byte flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">    byte[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sds结构如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603013520254.png" alt></p><p>因为使用<code>len</code>表示当前字符串长度，<code>capacity</code>表示内存分配空间，当往sds字符串中添加过多字符(len达到capacity大小)，则会触发扩容，在字符串长度大小小于1M时，扩容策略为成倍扩容；大于1M时，每次新增1M空间，避免空间浪费。</p><p>比如执行如下命令 <code>redis&gt; set name Redis</code>，Redis将在数据库中创建一个新的键值对，其中键是一个字符串，一个保存着”name”的sds；值是一个字符串，一个保存着”Redis”的sds。使用sds作为字符串存储结构，有以下优势：</p><ul><li>O(1)复杂度获取字符长度</li><li>避免缓冲区溢出</li><li>减少修改字符操作时引起的内存分配次数</li><li>二进制安全的</li><li>兼容部分C字符串函数（因为字符串后面以’\0’结尾）</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表在Redis应用较广泛，比如作为列表的底层实现，当列表中元素较多时会使用链表作为底层数据结构。链表定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p><p>链表提供了表头指针head、表尾指针tail及链表长度len，而<code>dup/free/match</code>用于实现存储类型无关的特性函数。dup用于复制一个链表节点、free用于释放一个链表节点、match用于匹配链表节点和输入的值是否相等。结构图如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603013650477.png" alt></p><p>每个链表节点由一个listNode结构表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis中链表是双向链表。每个链表使用一个list结构表示，这个结构有表头节点指针、表尾节点指针、以及链表长度信息。通过将链表设置不同类型的特定函数，使得Redis链表可存储不同类型的值（是不是类似Java中的模板类）。链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是列表和哈希的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项是小整数或者短的字符串，那么会使用压缩列表作为列表键的底层实现。压缩列表是Redis为了节约内存开发的，由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含多个节点，每个节点保存一个字节数组或者一个整数值。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103003252.png" alt></p><p>zltail_offset记录了左后一个entry的偏移量，通过它可以很快定位到尾节点。entry根据保存元素的不同，会有不一样的结构，不过类似于存储多个TLV消息一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen; <span class="comment">// 前一个 entry 的字节长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">// 元素类型编码</span></span><br><span class="line">    optional byte[] content; <span class="comment">// 元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist（压缩列表） 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。考虑到链表的附加空间相对太高， prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。</p><p>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103100747.png" alt></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称为符号表、映射，是一种保存键值对的数据结构。字典在Redis中应用相当广泛，比如Redis的数据库就是在使用字典作为底层实现的，对于数据库的CURD操作就是构建在对字典的操之上。比如当执行以下命令时：<code>redis&gt; set msg &quot;hello world&quot;</code></p><p>在数据库中创建了一个键为msg，值为hello world的键值对时，这个键值对就保存在代表数据库的字典里面的。除了用作数据库之外，字典还是哈希键的底层实现之一。</p><p>Redis的字典由dict结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 哈希计算</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 比较键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 销毁值的函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数，Redis会为不同用途的字典设置不同的特定函数。privdata属性则保存了需要传给那些特定函数的可选参数。ht属性包含2项，每一项都是一个dictht哈希表，一般情况下字典只使用ht[0]，ht[1]只在对ht[0]哈希表进行rehash时使用。字典结构图如下：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103216086.png" alt><br>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希。哈希表使用分离连接法解决键冲突问题，被分配到同一个索引上多个键值会连接成一个单向链表。在对哈希表进行扩展或者缩容操作时，需要将现有哈希表中键值对rehash到新哈希表中，这个rehash过程不是一次性完成的，而是渐进的。</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针来达到快速访问节点的目的。Redis使用跳跃表作为有序集合的底层实现之一，如果一个有序集合包含的元素数量较多，或者有序集合元素是比较长的字符串，Redis就会使用跳跃表作为有序集合的底层实现。</p><p>Redis中的跳跃表由zskiplistNode和zskiplist两个结构体定义，其中zskiplistNode表示跳跃表节点，zskiplist表示跳跃表信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj; <span class="comment">// Redis对象</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 用于记录两个节点之间的距离，指向NULL的forward值都为0</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p><p>header和tail指针分表指向跳跃表的表头和表尾节点，通过length属性记录表长度，level属性用于保存跳跃表中层高最大的节点的层高值。每个跳跃表节点层高都是1~32的随机值，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的。当分值相同时，节点按照成员对象的大小排序。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103314259.png" alt></p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是集合的底层实现之一，当一个集合只包含整数元素时，并且集合中元素数量不多时，Redis就会使用整数集合作为集合建的底层实现。整数集合是Redis中用于保存整数的集合抽象数据结构，它可以保存int16_t/int32_t/int64_t的值，并且保证集合中元素不会重复。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 16/32/64编码</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p><p>encoding编码的是int型整数的话，那么contents数组中每4项用于保存一个int型整数。</p><p>因为contents数组可以保存int16/int32/int64的值，所以可能会出现升级现象，也就是本来是int16编码方式，需要升级到int32编码方式，这时数组会扩容，然后将新元素添加到数组中，这期间数组始终会保持有序性。一旦整数集合进行了升级操作，编码就会一直保持升级后的状态，也就是不会出现降级操作。<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103405935.png" alt></p><h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>Rax 是 Redis 内部比较特殊的一个数据结构，它是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操作。 Redis 五大基础数据结构里面，能作为字典使用的有 hash 和 zset。 hash 不具备排序功能， zset 则是按照 score 进行排序的。 rax 跟 zset 的不同在于它是按照 key 进行排序的（可类比于InnoDB中的B+树）<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103424586.png" alt></p><p>Rax 被用在 Redis Stream 结构里面用于存储消息队列，在 Stream 里面消息 ID 的前缀是时间戳 + 序号，这样的消息可以理解为时间序列消息。使用 Rax 结构进行存储就可以快速地根据消息 ID 定位到具体的消息，然后继续遍历指定消息之后的所有消息。</p><p>rax 中有非常多的节点，根节点、叶节点和中间节点，有些中间节点带有 value，有些中间节点纯粹是结构性需要没有对应的 value。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isKey; <span class="comment">// 是否没有 key，没有 key 的是根节点</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isNull; <span class="comment">// 是否没有对应的 value，无意义的中间节点</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">1</span>&gt; isCompressed; <span class="comment">// 是否压缩存储，这个压缩的概念比较特别</span></span><br><span class="line">    <span class="keyword">int</span>&lt;<span class="number">29</span>&gt; size; <span class="comment">// 子节点的数量或者是压缩字符串的长度 (isCompressed)</span></span><br><span class="line">    byte[] data; <span class="comment">// 路由键、子节点指针、 value 都在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rax 是一棵比较特殊的 radix tree，它在结构上不是标准的 radix tree。如果一个中间节点有多个子节点，那么路由键就只是一个字符。如果只有一个子节点，那么路由键就是一个字符串。后者就是所谓的「压缩」形式，多个字符压在一起的字符串。如下结构（蓝色的表示压缩节点）：<br><img src="/2019/06/03/redis-ji-chu-shu-ju-jie-gou/./Redis-基础数据结构/20190603103457487.png" alt></p><p>参考资料：</p><ol><li>Redis设计与实现</li><li>Redis深度历险</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的Redis有类转换异常么</title>
      <link href="/2019/06/03/ni-de-redis-you-lei-zhuan-huan-yi-chang-me/"/>
      <url>/2019/06/03/ni-de-redis-you-lei-zhuan-huan-yi-chang-me/</url>
      
        <content type="html"><![CDATA[<p>之前同事反馈说线上遇到Redis反序列化异常问题，异常如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XxxClass1 cannot be cast to XxxClass2</span><br></pre></td></tr></table></figure></p><p>已知信息如下：</p><ul><li>该异常不是必现的，偶尔才会出现；</li><li>出现该异常后重启应用或者过一会就好了；</li><li>序列化协议使用了hessian。</li></ul><p>因为偶尔出现，首先看了报异常那块业务逻辑是不是有问题，看了一遍也发现什么问题。看了下对应日志，发现是在Redis读超时之后才出现的该异常，因此怀疑redis client操作逻辑那块导致的（公司架构组对redis做了一层封装），发现获取/释放redis连接如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">// jedis业务读写操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 归还给连接池</span></span><br><span class="line">        jedisPool.returnResourceObject(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初步认定原因为：发生了读写超时的连接，直接归还给连接池，下次使用该连接时读取到了上一次Redis返回的数据。因此本地验证下，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    config.setMaxTotal(<span class="number">1</span>);</span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.193.133"</span>, <span class="number">6379</span>, <span class="number">2000</span>, <span class="string">"123456"</span>);</span><br><span class="line">    </span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    jedis.set(<span class="string">"key1"</span>.getBytes(), serialize(<span class="keyword">new</span> Person(<span class="string">"luoxn28"</span>, <span class="number">26</span>)));</span><br><span class="line">    jedis.set(<span class="string">"key2"</span>.getBytes(), serialize(<span class="keyword">new</span> Dog(<span class="string">"tom"</span>)));</span><br><span class="line">    jedisPool.returnResourceObject(jedis);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = jedisPool.getResource();</span><br><span class="line">        Person person = deserialize(jedis.get(<span class="string">"key1"</span>.getBytes()), Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 发生了异常之后，未对该连接做任何处理</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedisPool.returnResourceObject(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = jedisPool.getResource();</span><br><span class="line">        Dog dog = deserialize(jedis.get(<span class="string">"key2"</span>.getBytes()), Dog<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedisPool.returnResourceObject(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>连接超时时间设置2000ms，为了方便测试，可以在redis服务器上使用gdb命令断住redis进程（如果redis部署在Linux系统上），比如在执行 <code>jedis.get(&quot;key1&quot;.getBytes()</code> 代码前，对redis进程使用gdb命令断住，那么就会导致读取超时，然后就会触发如下异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person cannot be cast to Dog</span><br></pre></td></tr></table></figure></p><p>既然已经知道了该问题原因并且本地复现了该问题，对应解决方案是，在发生异常时归还给连接池时关闭该连接即可(<em>jedis.close</em>内部已经做了判断)，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">// jedis业务读写操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 归还给连接池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，该问题解决。注意，因为使用了hessian序列化（其包含了类型信息，类似的有Java本身序列化机制），所有会报类转换异常；如果使用了json序列化（其只包含对象属性信息），反序列化时不会报异常，只不过因为不同类的属性不同，会导致反序列化后的对象属性为空或者属性值混乱，使用时会导致问题，并且这种问题因为没有报异常所以更不容易发现。</p><p>既然说到了Redis的连接，要知道的是，Redis基于<code>RESP(Redis Serialization Protocol)</code>协议来通信，并且通信方式是停等方式，也就说一次通信独占一个连接直到client读取到返回结果之后才能释放该连接让其他线程使用。小伙伴们可以思考一下，Redis通信能否像dubbo那样使用<code>单连接+序列号（标识单次通信）</code>通信方式呢？理论上是可以的，不过由于RESP协议中并没有一个”序列号”的字段，所以直接靠原生的通信方法来实现是不现实的。不过我们可以通过echo命令传递并返回”序列号”+正常的读写方式来实现，这里要保证二者执行的原子性，可以通过lua脚本或者事务来实现，事务方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">ECHO &quot;唯一序列号&quot;</span><br><span class="line">GET key1</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>然后客户端收到的结果是一个 <code>[ &quot;唯一序列号&quot;, &quot;value1&quot; ]</code>的列表，你可以根据前一项识别出这是你哪个线程发送的请求。</p><p>为什么Redis通信方式并没有采用类似于dubbo这种通信方式呢，个人认为有以下几点：</p><ul><li>使用停等这种通信方式实现简单，并且协议字段尽可能紧凑；</li><li>Redis都是内存操作，处理性能较强，停等协议不会造成客户端等待时间较长；</li><li>目前来看，通信方式这块不是Redis使用上的性能瓶颈，这一点很重要。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 线上问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap竟然也有死循环</title>
      <link href="/2019/06/01/concurrenthashmap-jing-ran-ye-you-si-xun-huan/"/>
      <url>/2019/06/01/concurrenthashmap-jing-ran-ye-you-si-xun-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前几天和拼多多及政采云的架构师们闲聊，其中拼多多架构师说遇到了一个ConcurrentHashMap死循环问题，当时心里想这不科学呀？ConcurrentHashMap怎么还有死循环呢，毕竟它已经解决HashMap中rehash中死循环问题了，但是随着深入的分析，发现事情并没有之前想的那么简单~ <strong>(以下分析基于jdk版本：jdk1.8.0_171)</strong></p></blockquote><p>保险起见，不能直接贴出出现问题的业务代码，因此将该问题简化成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// map默认capacity 16，当元素个数达到(capacity - capacity &gt;&gt; 2) = 12个时会触发rehash</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    map.put(i, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">12</span>, (k) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里会导致死循环 :(</span></span><br><span class="line">    map.put(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他操作</span></span><br></pre></td></tr></table></figure><p>感兴趣的小伙伴可以在电脑上运行下，话不说多，先说下问题原因：当执行<code>computeIfAbsent</code>时，如果key对应的slot为空，此时会创建<code>ReservationNode</code>对象(hash值为<code>RESERVED=-3</code>)放到当前slot位置，然后调用<code>mappingFunction.apply(key)</code>生成value，根据value创建Node之后赋值到slow位置，此时完成<code>computeIfAbsent</code>流程。但是上述代码<code>mappingFunction</code>中又对该map进行了一次put操作，并且触发了rehash操作，在<code>transfer</code>中遍历slot数组时，依次判断slot对应Node是否为null、hash值是否为MOVED=-1、hash值否大于0(list结构)、Node类型是否是TreeBin(红黑树结构)，唯独没有判断hash值为<code>RESERVED=-3</code>的情况，因此导致了死循环问题。</p><p>问题分析到这里，原因已经很清楚了，当时我们认为，这可能是jdk的<code>“bug”</code>，因此我们最后给出的解决方案是：</p><ul><li>如果在rehash时出现了<code>slot</code>节点类型是<code>ReservationNode</code>，可以给个提示，比如抛异常；</li><li>理论上来说，<code>mappingFunction</code>中不应该再对当前map进行更新操作了，但是jdk并没有禁止不能这样用，最好说明下。</li></ul><p>最后，另一个朋友看了<code>computeIfAbsent</code>的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If the specified key is not already associated with a value,</span></span><br><span class="line"><span class="comment"> * attempts to compute its value using the given mapping function</span></span><br><span class="line"><span class="comment"> * and enters it into this map unless &#123;<span class="doctag">@code</span> null&#125;.  The entire</span></span><br><span class="line"><span class="comment"> * method invocation is performed atomically, so the function is</span></span><br><span class="line"><span class="comment"> * applied at most once per key.  Some attempted update operations</span></span><br><span class="line"><span class="comment"> * on this map by other threads may be blocked while computation</span></span><br><span class="line"><span class="comment"> * is in progress, so the computation should be short and simple,</span></span><br><span class="line"><span class="comment"> * and must not attempt to update any other mappings of this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span></span></span><br></pre></td></tr></table></figure><p>我们发现，其实人家已经知道了这个问题，还特意注释说明了。。。我们还是<code>too yong too simple</code>啊。至此，ConcurrentHashMap死循环问题告一段落，还是<strong>要遵循编码规范，不要在mappingFunction中再对当前map进行更新操作</strong>。其实ConcurrentHashMap死循环不仅仅出现在上述讨论的场景中，以下场景也会触发，原因和上述讨论的是一样的，代码如下，感兴趣的小伙伴也可以本地跑下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.computeIfAbsent(<span class="number">12</span>, (k) -&gt; &#123;</span><br><span class="line">    map.put(k, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// 其他操作</span></span><br></pre></td></tr></table></figure><p>最后，一起跟着<code>computeIfAbsent</code>源码来分下上述死循环代码的执行流程，限于篇幅，只分析下主要流程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    V val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; r = <span class="keyword">new</span> ReservationNode&lt;K,V&gt;();</span><br><span class="line">            <span class="keyword">synchronized</span> (r) &#123;</span><br><span class="line">                <span class="comment">// 这里使用synchronized针对局部对象意义不大，主要是下面的cas操作保证并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, r)) &#123;</span><br><span class="line">                    binCount = <span class="number">1</span>;</span><br><span class="line">                    Node&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的value返回可能为null呦</span></span><br><span class="line">                        <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>)</span><br><span class="line">                            node = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        setTabAt(tab, i, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 仅仅判断了node.hash &gt;=0和node为TreeBin类型情况，未判断`ReservationNode`类型</span></span><br><span class="line">                <span class="comment">// 扩容时判断和此处类似</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek; V ev;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                val = e.val;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    added = <span class="keyword">true</span>;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(h, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>)</span><br><span class="line">                            val = p.val;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            added = <span class="keyword">true</span>;</span><br><span class="line">                            t.putTreeVal(h, key, val);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (!added)</span><br><span class="line">                    <span class="keyword">return</span> val;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 计数统计&amp;阈值判断+扩容操作</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好文推荐：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;mid=2649938471&amp;idx=1&amp;sn=2964df2adc4feaf87c11b4915b9a018e&amp;chksm=8f350992b842808477d2bfde6d58354f86c28b7a70d1c5395e550ed6ca683dadcbb7a9637775&amp;token=512328060&amp;lang=zh_CN#rd" target="_blank" rel="noopener">别再问我ConcurrentHashMap了</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;mid=2649938424&amp;idx=1&amp;sn=e4b7d4d04b02794698f8b4d46a1d89d1&amp;chksm=8f350a4db842835b7df97d6a42bab0cc25df1fef824be0427710643836bd47cd4fd91b5e562a&amp;token=512328060&amp;lang=zh_CN#rd" target="_blank" rel="noopener">你的ThreadLocal线程安全么</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文弄懂分布式锁</title>
      <link href="/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/"/>
      <url>/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多线程情况下对共享资源的操作需要加锁，避免数据被写乱，在分布式系统中，这个问题也是存在的，此时就需要一个分布式锁服务。常见的分布式锁实现一般是基于DB、Redis、zookeeper。下面笔者会按照顺序分析下这3种分布式锁的设计与实现，想直接看分布式锁总结的小伙伴可直接翻到文档末尾处。</p></blockquote><p>分布式锁的实现由多种方式，但是不管怎样，分布式锁一般要有以下特点：</p><ul><li><strong>排他性</strong>：任意时刻，只能有一个client能获取到锁</li><li><strong>容错性</strong>：分布式锁服务一般要满足AP，也就是说，只要分布式锁服务集群节点大部分存活，client就可以进行加锁解锁操作</li><li><strong>避免死锁</strong>：分布式锁一定能得到释放，即使client在释放之前崩溃或者网络不可达</li></ul><p>除了以上特点之外，分布式锁最好也能满足可重入、高性能、阻塞锁特性（AQS这种，能够及时从阻塞状态唤醒）等，下面就话不多说，赶紧上车~</p><h2 id="DB锁"><a href="#DB锁" class="headerlink" title="DB锁"></a>DB锁</h2><p>在数据库新建一张表用于控制并发控制，表结构可以如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`lock_table`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`key_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分布式key'</span>,</span><br><span class="line">  <span class="string">`memo`</span> <span class="built_in">varchar</span>(<span class="number">43</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'可记录操作内容'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>,<span class="string">`key_id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`key_id`</span> (<span class="string">`key_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p><p>key_id作为分布式key用来并发控制，memo可用来记录一些操作内容（比如memo可用来支持重入特性，标记下当前加锁的client和加锁次数）。将key_id设置为唯一索引，保证了针对同一个key_id只有一个加锁（数据插入）能成功。此时lock和unlock伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def lock ：</span><br><span class="line">    exec sql: insert into lock_table(key_id, memo, update_time) values (key_id, memo, NOW())</span><br><span class="line">    if result == true :</span><br><span class="line">        return true</span><br><span class="line">    else :</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">def unlock ：</span><br><span class="line">    exec sql: delete from lock_table where key_id = &apos;key_id&apos; and memo = &apos;memo&apos;</span><br></pre></td></tr></table></figure></p><p>注意，伪代码中的lock操作是非阻塞锁，也就是tryLock，如果想实现阻塞（或者阻塞超时）加锁，只修反复执行lock伪代码直到加锁成功为止即可。基于DB的分布式锁其实有一个问题，那就是如果加锁成功后，client端宕机或者由于网络原因导致没有解锁，那么其他client就无法对该key_id进行加锁并且无法释放了。为了能够让锁失效，需要在应用层加上定时任务，去删除过期还未解锁的记录，比如删除2分钟前未解锁的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def clear_timeout_lock :</span><br><span class="line">    exec sql : delete from lock_table where update_time &lt;  ADDTIME(NOW(),&apos;-00:02:00&apos;)</span><br></pre></td></tr></table></figure></p><p>因为单实例DB的TPS一般为几百，所以基于DB的分布式性能上限一般也是1k以下，一般在并发量不大的场景下该分布式锁是满足需求的，不会出现性能问题。不过DB作为分布式锁服务需要考虑单点问题，对于分布式系统来说是不允许出现单点的，一般通过数据库的同步复制，以及使用vip切换Master就能解决这个问题。</p><p>以上DB分布式锁是通过insert来实现的，如果加锁的数据已经在数据库中存在，那么用<code>select xxx where key_id = xxx for udpate</code>方式来做也是可以的。</p><h2 id="Redis锁"><a href="#Redis锁" class="headerlink" title="Redis锁"></a>Redis锁</h2><p>Redis锁是通过以下命令对资源进行加锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key_id key_value NX PX expireTime</span><br></pre></td></tr></table></figure></p><p>其中，set nx命令只会在key不存在时给key进行赋值，px用来设置key过期时间，key_value一般是随机值，用来保证释放锁的安全性（释放时会判断是否是之前设置过的随机值，只有是才释放锁）。由于资源设置了过期时间，一定时间后锁会自动释放。</p><p><code>set nx</code>保证并发加锁时只有一个client能设置成功（Redis内部是单线程，并且数据存在内存中，也就是说redis内部执行命令是不会有多线程同步问题的），此时的lock/unlock伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def lock:</span><br><span class="line">    if (redis.call(&apos;set&apos;, KEYS[1], ARGV[1], &apos;ex&apos;, ARGV[2], &apos;nx&apos;)) then</span><br><span class="line">      return true</span><br><span class="line">    end</span><br><span class="line">      return false</span><br><span class="line">      </span><br><span class="line">def unlock:</span><br><span class="line">    if (redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1]) then</span><br><span class="line">      redis.call(&apos;del&apos;, KEYS[1])</span><br><span class="line">      return true</span><br><span class="line">    end</span><br><span class="line">      return false</span><br></pre></td></tr></table></figure></p><h3 id="Redis锁续约问题"><a href="#Redis锁续约问题" class="headerlink" title="Redis锁续约问题"></a>Redis锁续约问题</h3><p>如果一个获取到锁的client因为某种原因导致没能及时释放锁，并且redis因为超时释放了锁，另外一个client获取到了锁，此时情况如下图所示：<br><img src="/2019/05/31/yi-wen-nong-dong-fen-bu-shi-suo/./一文弄懂分布式锁/20190601104854371.png" alt></p><p>那么如何解决这个问题呢，一种方案是引入锁续约机制，也就是获取锁之后，释放锁之前，会定时进行锁续约，比如以锁超时时间的1/3为间隔周期进行锁续约。</p><p>关于开源的redis的分布式锁实现有很多，比较出名的有<a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">redisson</a>、百度的<a href="https://github.com/baidu/dlock" target="_blank" rel="noopener">dlock</a>，关于分布式锁，笔者也写了一个简易版的分布式锁redis-lock，主要是增加了锁续约和可同时针对多个key加锁的机制。</p><p>对于高可用性，一般可以通过集群或者master-slave来解决，redis锁优势是性能出色，劣势就是由于数据在内存中，一旦缓存服务宕机，锁数据就丢失了。像redis自带复制功能，可以对数据可靠性有一定的保证，但是由于复制也是异步完成的，因此依然可能出现master节点写入锁数据而未同步到slave节点的时候宕机，锁数据丢失问题。</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p>ZooKeeper是一个高可用的分布式协调服务，由雅虎创建，是Google Chubby的开源实现。ZooKeeper提供了一项基本的服务：分布式锁服务。zookeeper重要的3个特征是：zab协议、node存储模型和watcher机制。通过zab协议保证数据一致性，zookeeper集群部署保证可用性，node存储在内存中，提高了数据操作性能，使用watcher机制，实现了通知机制（比如加锁成功的client释放锁时可以通知到其他client）。</p><p>zookeeper node模型支持临时节点特性，即client写入的数据时临时数据，当客户端宕机时临时数据会被删除，这样就不需要给锁增加超时释放机制了。当针对同一个path并发多个创建请求时，只有一个client能创建成功，这个特性用来实现分布式锁。注意：如果client端没有宕机，由于网络原因导致zookeeper服务与client心跳失败，那么zookeeper也会把临时数据给删除掉的，这时如果client还在操作共享数据，是有一定风险的。</p><p>基于zookeeper实现分布式锁，相对于基于redis和DB的实现来说，使用上更容易，效率与稳定性较好。curator封装了对zookeeper的api操作，同时也封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等，使用curator进行分布式加锁示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对zookeeper的底层api的一些封装--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String lockPath = <span class="string">"/curator_recipes_lock_path"</span>;</span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="string">"192.168.193.128:2181"</span>)</span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).build();</span><br><span class="line"></span><br><span class="line">    client.start();</span><br><span class="line">    InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"></span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.acquire();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"zookeeper acquire success: "</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LockSupport.park();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面介绍的3种分布式锁的设计与实现中，我们可以看出每种实现都有各自的特点，针对潜在的问题有不同的解决方案，归纳如下：</p><ul><li>性能：redis &gt; zookeeper &gt; db。</li><li>避免死锁：DB通过应用层设置定时任务来删除过期还未释放的锁，redis通过设置超时时间来解决，而zookeeper是通过临时节点来解决。</li><li>可用性：DB可通过数据库同步复制，vip切换master来解决，redis可通过集群或者master-slave方式来解决，zookeeper本身自己是通过zab协议集群部署来解决的。注意，DB和redis的复制一般都是异步的，也就是说某些时刻分布式锁发生故障可能存在数据不一致问题，而zookeeper本身通过zab协议保证集群内(至少n/2+1个)节点数据一致性。</li><li>锁唤醒：DB和redis分布式锁一般不支持唤醒机制（也可以通过应用层自己做轮询检测锁是否空闲，空闲就唤醒内部加锁线程），zookeeper可通过本身的watcher/notify机制来做。</li></ul><p>使用分布式锁，安全性上和多线程（同一个进程内）加锁是没法比的，可能由于网络原因，分布式锁服务（因为超时或者认为client挂了）将加锁资源给删除了，如果client端继续操作共享资源，此时是有隐患的。因此，对于分布式锁，一个是尽量提高分布式锁服务的可用性，另一个就是要部署同一内网，尽量降低网络问题发生几率。这样来看，貌似分布式锁服务不是“完美”的（PS：技术貌似也不好做到十全十美 :( ），那么开发人员该如何选择分布式锁呢？最好是结合自己的业务实际场景，来选择不同的分布式锁实现，一般来说，基于redis的分布式锁服务应用较多。</p><p>参考资料：</p><ol><li><a href="http://weizijun.cn/2016/03/17/%E8%81%8A%E4%B8%80%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">聊一聊分布式锁的设计</a></li><li><a href="https://github.com/luoxn28/redis-lock" target="_blank" rel="noopener">https://github.com/luoxn28/redis-lock</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础概念知多少</title>
      <link href="/2019/05/19/mysql-ji-chu-gai-nian-zhi-duo-shao/"/>
      <url>/2019/05/19/mysql-ji-chu-gai-nian-zhi-duo-shao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL基础概念相关的名词还是挺多的，比如3大范式、4种隔离界别、ACID、DQL、DML、DDL，还有redo、undo、binlog等，本文就统一整理下MySQL常见的基础概念，方便小伙伴们翻阅~</p></blockquote><p>MySQL相关的名词概念还是挺多的，但是常用的也不多，因此将常用的统计整理下，便于回顾：</p><ul><li><strong>DQL</strong>：data query language，指SELECT查询语句；</li><li><strong> DML</strong>：data manipulation language，指SELECT、UPDATE、INSERT、DELETE这4种对数据操控语句；</li><li><strong>DDL</strong>：data definition language，数据定义语句，创建/修改/删除表结构，主要有CREATE、ALTER、DROP等；</li><li><strong>MDL锁</strong>：Metadata Locking，这里的metalock指的是数据库及表的结构信息。MySQL中，DDL不属于事务范畴，如果事务和DDL并行执行，操作相关联的表的话，会出现各种意想不到问题，导致事务特性被破坏或者<a href="https://bugs.mysql.com/bug.php?id=989" target="_blank" rel="noopener">binlog顺序错乱</a>等，为解决这些问题而引入MDL锁机制。</li></ul><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><ul><li>第一范式：每个字段都是原子的，也就说不可再分解；</li><li>第二范式：有主键，非主键字段依赖主键字段；</li><li>第三范式：非主键之间不能相互依赖。</li></ul><p>注意，三大范式是数据表的建议设计原则，并不是非得完全按照这个来设计，具体设计还要根据实际场景来分析。任何给定的数据通常有多种表示方法，完全的范式话和反范式化，以及二者的折中。在范式化数据库中，任何数据都会出现且只出现一次，相反在反范式化中，数据是冗余的。</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>ACID是事务的4个特性，分别是原子性、一致性、隔离性和持久性。</p><ul><li>A：atomicity，原子性，一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚；</li><li>C：consistency，一致性，数据库总是从一个一致性的状态转换到另一个一致性的状态；</li><li>I：isolation，隔离性，通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的（隔离级别在非提交读时不满足）；</li><li>D：一旦事务提交，则其所做的修改就会永久保存到数据库中。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>数据库事务的4种隔离级别：</p><ul><li>未提交读：一个事务可以读到另外一个事务未提交的数据。</li><li>提交度：一个事务更新数据过程中，如果事务还未提交，其他事务读不到该数据。</li><li>可重复读：该级别保证了在同一个事务中，多次读取同样记录的结果是一样的，解决了“提交读”中不可重复读的问题。但是理论上还是无法解决幻读问题（通过间隙锁可解决幻读问题）。</li><li>串行化：将所有事务都进行串行化处理，等级最高的隔离级别。</li></ul><h2 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h2><p>幻读就是当事务在读取某个范围数据时，另一个事务又在该范围插入了新的数据，当之前的事务再次读取该范围数据时，就会产生幻行。产生幻读的原因是之前的事务在读取数据的范围没有增加范围锁（range-locks），也就是读取时只是锁定的行级共享锁，没有锁定整个查询区间或者表。</p><h2 id="常见索引结构"><a href="#常见索引结构" class="headerlink" title="常见索引结构"></a>常见索引结构</h2><ul><li>B+树索引：B+ 树是关系型数据库中常见的索引类型。注意：B+树所以并不能找到一个给定键值的具体行，只能找到被查找数据行所在的页，然后数据库将页读入内存，在内存中进行查找，最后得到要查找的数据；</li><li>哈希索引：InnoDB支持的哈希索引是自适应的，不能人为干预在一张表中生成哈希索引，innodb会根据表的使用情况自动生成哈希索引；</li><li>全文索引：InnoDB支持全文索引，但是每张表只能有一个全文检索的索引，一般都是使用倒排索引技术来实现。</li></ul><h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><p>聚集索引就是主键索引，其叶子节点就是记录的数据（页）。非聚集索引也叫做辅助索引，其叶子结点记录的是主键值。以表t为例说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0,</span><br><span class="line">s varchar(16) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">index k(k)) engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &apos;aa&apos;),(200,2,&apos;bb&apos;),(300,3,&apos;cc&apos;),(500,5,&apos;ee&apos;),(600,6,&apos;ff&apos;);</span><br></pre></td></tr></table></figure></p><p>表T对应的主键索引和辅助索引如下：<br><img src="/2019/05/19/mysql-ji-chu-gai-nian-zhi-duo-shao/./MySQL基础概念知多少/20190519011710272.png" alt></p><h2 id="几个日志"><a href="#几个日志" class="headerlink" title="几个日志"></a>几个日志</h2><ul><li>redo log：记录的是页的物理操作，InnoDB通过将事务操作先写redo log，而不是将数据页的更新写磁盘，相当于将磁盘随机写(data文件)变成了顺序写(redo log)，后续在MySQL”空闲”时再慢慢写磁盘，提高服务器性能；</li><li>undo log：undo log保存了事务发生之前的数据的版本，可用于回滚，同时可提供多版本并发控制读（MVCC），也就是非锁定读。undo log是逻辑日志，在执行undo时，仅仅是将数据逻辑上恢复至事务之前的状态，而不是从物理页上操作的，这一条不同于redo log。事务开始时将当前版本生成undo log，undo也会产生redo来保证undo log可靠性；</li><li>binlog：binlog是mysql层面的归档日志，可用于主从复制和数据库基于时间点的还原。binlog记录的是逻辑日志，记录的是DDL和DML操作日志，可以简单认为是执行过的事务中的更新sql语句。</li><li>慢查询、错误日志等。</li></ul><h2 id="几个文件"><a href="#几个文件" class="headerlink" title="几个文件"></a>几个文件</h2><ul><li>.ibd文件和.ibdata文件：.ibd文件和ibdata文件都是存放innodb数据的文件，之所有有2个，因为innodb支持配置来决定是使用共享表空间还是独享表空间。独享表空间使用”.ibd”文件存储数据，并且每个表有一个.ibd文件；如果使用共享表空间，则会使用ibdata文件，所有表公用一个（或者配置多个）ibdata文件。</li><li>.ifm文件：存放表相关的元数据信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
