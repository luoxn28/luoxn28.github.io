<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>Transmittable-Thread-Local：线程间上下文传递解决方案 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Transmittable-Thread-Local：线程间上下文传递解决方案</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Transmittable-Thread-Local：线程间上下文传递解决方案</h1><div class="post-meta">Mar 16, 2020<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div></div></div><div class="post-content"><blockquote>
<p>TTL（transmittable-thread-local）是一个线程间传递ThreadLocal，异步执行时上下文传递的解决方案。整个库的核心是构建在TransmittableThreadLocal类（继承并加强InheritableThreadLocal类）之上，同时包含线程池修饰（ExecutorService/ForkJoinPool/TimerTask）以及Java Agent支持，代码小于1k行，短小精悍。</p>
</blockquote>
<p>在往下看之前，最好大致看下 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a> 文档，效果会更好。JDK的InheritableThreadLocal类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时的ThreadLocal值传递</strong>到 <strong>任务执行时</strong>。原理是使用TtlRunnable/Ttlcallable包装了Runnable/Callable类：</p>
<ol>
<li>在TtlRunnable/Ttlcallable初始化时<strong>capture</strong> TransmittableThreadLocal变量</li>
<li>在run方法调用runnable.run()前进行<strong>replay</strong>，设置到当前线程ThreadLocal</li>
<li>在run方法调用runnable.run()后进行<strong>restore</strong>，上下文还原，也就是replay的反向操作</li>
</ol>
<p>注意，步骤1和步骤2/3不是在同一个线程中执行的。</p>
<p>既然TTL的TransmittableThreadLocal是继承并加强InheritableThreadLocal类的，那么首先需要分析下InheritableThreadLocal是什么东东，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建线程时，如果当前inheritableThreadLocals非空，则会获取当前inheritableThreadLocals传递给新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal变量的set/get/remove操作都是在inheritableThreadLocals上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建inheritableThreadLocals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread类中有两个ThreadLocal相关的ThreadLocalMap属性，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals：ThreadLocal变量使用</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals：InheritableThreadLocal变量使用</span><br></pre></td></tr></table></figure>
<p>新建线程时，将当前线程的inheritableThreadLocals传递给新线程，这里的传递是对InheritableThreadLocal变量的数据做浅拷贝（引用复制），这样新线程可以使用同一个InheritableThreadLocal变量查看上一个线程的数据。</p>
<p>下面分析下使用InheritableThreadLocal的一个demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: value-set-in-parent</span></span><br></pre></td></tr></table></figure>
<p>上面代码在submit任务时会伴随着（线程池工作）线程的创建，会继承当前线程的InheritableThreadLocal，所以会有上述输出结果。如果将代码改成下面的样子，会有什么不同呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; &#123;&#125;); <span class="comment">// 先进行工作线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line">    executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: null</span></span><br></pre></td></tr></table></figure>
<p>因为创建线程时当前线程并没有inheritableThreadLocals，所以线程池中线程打印结果为null。这种场景下如何才能获取到parent变量的数据呢？这时就该TTL出场了，将上述代码改成TTL方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testTtlInheritableThreadLocal_线程池() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    executor.submit(() -&gt; &#123;&#125;); <span class="comment">// 先进行工作线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用TTL</span></span><br><span class="line">    <span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">    parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line">    <span class="comment">// 将Runnable通过TtlRunnable包装下</span></span><br><span class="line">    executor.submit(TtlRunnable.get(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：pool-1-thread-1: value-set-in-parent</span></span><br></pre></td></tr></table></figure>
<p>下面以TtlRunnable.get()为起点分析TTL的设计实现，TtlRunnable.get源码如下（TtlRunnable.get流程对应的初始化时<strong>capture</strong>操作，保存快照。TtlCallable和TtlRunnable流程类似）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title">get</span><span class="params">(@Nullable Runnable runnable)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> get(runnable, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title">get</span><span class="params">(@Nullable Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun, <span class="keyword">boolean</span> idempotent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (runnable <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">		<span class="comment">// 幂等时直接返回，否则执行会产生问题，直接抛异常</span></span><br><span class="line">		<span class="keyword">if</span> (idempotent) <span class="keyword">return</span> (TtlRunnable) runnable;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already TtlRunnable!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> TtlRunnable(runnable, releaseTtlValueReferenceAfterRun);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(@Nonnull Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());</span><br><span class="line">	<span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">	<span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">	<span class="comment">// 从holder获取所有threadLocal，存到captured，这里相当于对当前线程holder做一个快照保存</span></span><br><span class="line">	<span class="comment">// 到TtlRunnable实例属性中，在执行TtlRunnable时进行回放</span></span><br><span class="line">	<span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">		captured.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> captured;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在新建TtlRunnable过程中，会保存下TransmittableThreadLocal.holder到captured，记录到TtlRunnable实例中的capturedRef字段，TransmittableThreadLocal.holder类型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note about holder:</span></span><br><span class="line"><span class="comment">// 1. The value of holder is type Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; (WeakHashMap implementation),</span></span><br><span class="line"><span class="comment">//    but it is used as *set*. 因为没有WeakSet的原因</span></span><br><span class="line"><span class="comment">// 2. WeakHashMap support null value.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">        <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>从上面代码我们知道初始化TtlRunnable时已经将TransmittableThreadLocal保存下来了，那么什么时候应用到当前线程ThreadLocal中呢，这是就需要看下TtlRunnable.run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object captured = capturedRef.get();</span><br><span class="line">    <span class="comment">// captured不应该为空，releaseTtlValueReferenceAfterRun为true时设置capturedRef为null，防止当前Runnable重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"TTL value reference is released after run!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// captured进行回放，应用到当前线程中</span></span><br><span class="line">    Object backup = replay(captured);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restore(backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，TTL中的replay操作是以captured为当前inheritableThreadLocals的（处理逻辑是在TtlRunable run时，会以TtlRunnable.get时间点获取的captured（类似TTL快照）为准，holder中不在captured的先移除，在的会被替换）。关于replay中的clean extra TTL value讨论可以参考：<a href="https://github.com/alibaba/transmittable-thread-local/issues/134。回放captured和执行完runnable.run之后，再restore恢复到原来inheritableThreadLocals的状态。" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local/issues/134。回放captured和执行完runnable.run之后，再restore恢复到原来inheritableThreadLocals的状态。</a></p>
<p>说完了TTL中的capture、replay和restore流程，再看下官方提供的这个时序图，是不是感觉清晰很多。</p>
<p><img src="/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/./transmittable-thread-local：线程间上下文传递解决方案/image-20200315174314526.png" alt="image-20200315174314526"></p>
<p>除了通过TtlRunable.get()修饰用户自定义的task之外，还可以修饰线程池和使用Java Agent修饰JDK线程池实现类的方式实现TTL功能。</p>
<p>修饰线程池省去每次Runnable和Callable传入线程池时的修饰，这个逻辑可以在线程池中完成，其实就是在提交task时调用TtlRunable.get()修饰下。通过工具类com.alibaba.ttl.threadpool.TtlExecutors完成，有下面的方法：</p>
<ul>
<li>getTtlExecutor：修饰接口Executor</li>
<li>getTtlExecutorService：修饰接口ExecutorService</li>
<li>getTtlScheduledExecutorService：修饰接口ScheduledExecutorService</li>
</ul>
<p>使用Java Agent来修饰JDK线程池实现类，这种方式，实现线程池的传递是透明的，代码中没有修饰Runnable或是线程池的代码。即可以做到应用代码无侵入。关于 无侵入 的更多说明参见文档 <a href="https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md#java-agent方式对应用代码无侵入" target="_blank" rel="noopener">Java Agent方式对应用代码无侵入</a>。</p>
<p>使用Java Agent 实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动参数中需加上 -javaagent:path/transmittable-thread-local-x.x.x.jar</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">parent.set(<span class="string">"value-set-in-parent"</span>);</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + parent.get()));</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<p>TTL代码实现来看，确实短小精悍，值得花几个小时看下源码。通过看源码，我发现了，可以通过new ThreadLocal对象时，直接重写其initialValue方法，可以在threadLocal.get为空时初始化一个值，使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"init"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">local.set(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println(local.get()); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">local.remove();</span><br><span class="line">System.out.println(local.get()); <span class="comment">// init</span></span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/">http://luoxn28.github.io/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2020/03/16/transmittable-thread-local-xian-cheng-jian-shang-xia-wen-chuan-di-jie-jue-fang-an/" data-id="ckc7rx87p001ioqci1sfgvrkx" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD4klEQVR42u3aQW7jQAwEQP//095rgMjabnKU5FA6BVpHnikt0CGHr1d8vb9c3+8nd77e//5z/pn2zuuJCwcOHDhwxFu9X1y7jfZ7758wW1u+Rxw4cODAcZbj09c/F3v5ou/Xlq8weQ4OHDhw4Ph5jiT8NoViTpNw48CBAweOv8+RxOqeLI/b/evEgQMHDhxPcCTNwfy3ZgVb+xqS9TzYK8WBAwcOHIs6K1/u3/z5kfkOHDhw4MARh9MsONsAPhvM+wsHDhw4cOw58kDKi7rkX59oDs7KMxw4cODA8RzHLBrzoM3jeTas0P4psCrkcODAgQNHwDGLwNlB0SyS8+hN9vXxkzhw4MCB4xDHJuTazbcbmz0/h8CBAwcOHM9xtEG1ObJqyfIGZXsYFuU5Dhw4cOAoOTbHRUn0tkyzl5EXfjhw4MCB42mO/DCpLY1mzce8vMyfH5WLOHDgwIHjYY5ZQLYtxZw+Kc9e5YUDBw4cOE5xJGVPWzKdCrz36ErW/3ENOHDgwIHjKMdm7KBtzOWlWgvXHjVd/MWBAwcOHDjWHEkRlUdv20CcFWmzg6v/tC9x4MCBA8eaY0aQh2gek7PjqM0QRjHWgAMHDhw4Yo5Ny292dNQO3u2jd/g/AgcOHDhwHA3X+yhtD6Xa+/mYwv4JOHDgwIHjLEc7XpBsb1/ItdCbku9ihThw4MCB4xDHPqjall8e5O32ZlGNAwcOHDjOcsy2kRd1r/hqB+Y2h1g4cODAgeM5jjzwkoOfpLjab7JdQ7Q7HDhw4MCx4Gg3MyPLl94eaNWNv/vfwoEDBw4chzja4bZTQZgPxu0Lv+jbceDAgQPHmiP/gny8oB1xaL9lFvx5POPAgQMHjg1HHpBtCy9f1ubgajZyEZ2/4cCBAweONcesJMuf0wZw0l7cFHIXd3DgwIEDx5pjMyKQ09xvNRl92JSaeSGHAwcOHDj2HLMl5pE2i8zZAVL+/j/uEQcOHDhwHOJIDn72AZmXiHuy/I+Gi6DFgQMHDhyHONpjpFNHU7OC8NQQxsVAAw4cOHDgWHPMjv/3fHnJl0f1rDTFgQMHDhynOGaHNEnrcHOM1L6S2fOHdS0OHDhw4LjleJfXphnXlm2b0b28yKynOXDgwIEDx6FrX3rlJVnLl49czBqOOHDgwIGj5WgDMjleyjmKtl35PodBiwMHDhw4DnHMgipvyW0Ccv/CijYlDhw4cOD4JY79cENbsOUtwnbcAQcOHDhw/C5H+5n8Cfkh0yzgi1E5HDhw4MCx5siHGNpY3bcm96+hGM7AgQMHDhxrjlkr7exwwz56201uGos4cODAgeMDxz+wM7nM8JI2hQAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/2020/03/17/group-by-zhong-zi-cha-xun-order-by-pai-xu-shi-xiao-wen-ti-fen-xi/">group by中子查询order by排序失效问题分析</a><a class="next" href="/2020/03/13/xian-cheng-chi-ru-he-chuan-di-xian-cheng-shang-xia-wen-xin-xi/">线程池如何传递线程上下文信息</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-provider-filter-lian-shi-ru-he-gou-jian-de/">Dubbo provider Filter链是如何构建的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-rpc-zai-provider-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在provider端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/dubbo-provider-shi-ru-he-qi-dong-de/">dubbo provider是如何启动的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/dubbo-lian-tong-xing-tao-lun/">Dubbo连通性讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/dubbo-xian-cheng-mo-xing/">Dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/04/dubbo-rpc-zai-consumer-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在consumer端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>