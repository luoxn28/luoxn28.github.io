<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="该来的终究会来，而且比想象的更快！"><title>页面更换算法 | luoxn28</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">页面更换算法</h1><a id="logo" href="/.">luoxn28</a><p class="description">南</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">页面更换算法</h1><div class="post-meta">Apr 11, 2020<span> | </span><span class="category"><a href="/categories/操作系统/">操作系统</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机算法"><span class="toc-number">1.</span> <span class="toc-text">随机算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO算法"><span class="toc-number">2.</span> <span class="toc-text">FIFO算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟算法"><span class="toc-number">3.</span> <span class="toc-text">时钟算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NRU算法"><span class="toc-number">4.</span> <span class="toc-text">NRU算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU算法"><span class="toc-number">5.</span> <span class="toc-text">LRU算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作集算法"><span class="toc-number">6.</span> <span class="toc-text">工作集算法</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis中的内存淘汰"><span class="toc-number"></span> <span class="toc-text">Redis中的内存淘汰</span></a></li></div></div><div class="post-content"><blockquote>
<p>操作系统为什么需要页面更换呢，因为物理内存不够，不可能同时加载所需的所有数据页，因此只能加载正在或最近要使用的内存页。页面更换的目标是，尽量替换掉不再使用或者一段时间内不再使用的内存页，要不然会很容易触发缺页中断，该操作代价较大，涉及到从磁盘加载，因此页面更换可不是随便的事情。</p>
</blockquote>
<p>为了达到降低随后发生缺页中断的次数或者概率，人们设计出了各种各样的页面替换算法，这些算法大致可分为公平算法和非公平算法。</p>
<ul>
<li>公平算法：随机算法、FIFO算法、时钟算法。</li>
<li>非公平算法：NRU算法、LRU算法、工作集算法。</li>
</ul>
<h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p>这种就是简单的随机选择进行页替换，无需多言，简单粗暴。</p>
<h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><p>这种就是先来后到，可以使用链表记录页分配的先后顺序，淘汰时按照顺序淘汰即可，也是非常的简单粗暴。</p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>内存使用中的页按照时钟的逻辑形状，淘汰页时按照时钟顺序检查，如果页未访问到（每个页对应一个访问标识，未访问到时设置为0），则直接替换；如果访问过则设置访问位为0，方便下次淘汰。时钟逻辑图如下：</p>
<p><img src="/2020/04/11/ye-mian-geng-huan-suan-fa/./页面更换算法/image-20200411171144181.png" alt="image-20200411171144181"></p>
<h3 id="NRU算法"><a href="#NRU算法" class="headerlink" title="NRU算法"></a>NRU算法</h3><p>最近未使用算法，将最近一段时间没有访问过的页面进行替换，作出这种选择是基于程序访问的时空局域性。依据时空局域性，一个最近没有访问过的页面，在随后的时间内也不太可能被访问，而NRU的实现就是利用页面的访问和修改位来实现的。</p>
<blockquote>
<p>时空局限性在很多程序设计思想中有体现，比如rocketmq中page cache缓存最近读写的消息数据等。</p>
</blockquote>
<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>LRU是对NRU算法的改进，其考虑的是最近使用的频率而不是最近是否使用过。LRU算法的实现必须以某种方式记录每个页面被访问的次数，简单的办法就是在页表的记录项里面增加一个计数域，一个页面被访问一次，则这个计数器的值加1；或者使用链表结构，每访问一次就将该页移动到链表头。</p>
<h3 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h3><p>考虑到LRU算法实现，其需要对每个页面保持某种记录，并在每次页面访问时或周期性对这些记录更新，造成时间空间成本高。工作集概念来源于程序访问的时空局域性，在一段时间内，程序访问的页面将局限在一组页面集合上。</p>
<p>例如，最近K次访问均发生在某m个页面上，那么m就是参数为k时的工作集。用w(k, t)表示时间t时k次访问所涉及的页面数量。显然随着k的增长，w(k, t)的值将随之增长，在k增长至某个数值后，w(k, t)值增长将及其缓慢甚至接近停滞，并维持一段时间。</p>
<p><img src="/2020/04/11/ye-mian-geng-huan-suan-fa/./页面更换算法/image-20200411171208269.png" alt="image-20200411171208269"></p>
<p>工作集算法就是操作系统局限性的一种体现，一段时间内，CPU操作的数据大都集中在少量数据上，因此可以应用工作集算法来进行页的替换操作。</p>
<h2 id="Redis中的内存淘汰"><a href="#Redis中的内存淘汰" class="headerlink" title="Redis中的内存淘汰"></a>Redis中的内存淘汰</h2><p>以上分析了操作系统中的页面更换算法，更广义来讲，页面更换就是内存淘汰，操作系统的页面更换算法可能不能直接让开发者<code>感同身受</code>，毕竟这是OS层面的东东。下面就以实际开发中常用到的Redis为例，来分析下<strong>Redis内存淘汰策略</strong>，对比加深对内存淘汰的理解。</p>
<p><strong>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据</strong>。目前Redis的内存淘汰策略有如下几种：</p>
<ul>
<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p>对于LRU（Least Recent Used），淘汰掉最不经常使用的，LRU可以通过<code>hashMap + 双向链表</code>来实现，如果Redis也基于hashMap + 双向链表实现，显然要对目前的数据结构做较大改动，为了追求空间的利用率，Redis采用权衡的实现方案：<strong>Redis会基于server.maxmemory_samples配置选取固定数目的key，然后比较它们的lru访问时间，然后淘汰最近最久没有访问的key，maxmemory_samples的值越大，Redis的近似LRU算法就越接近于严格LRU算法，但是相应消耗也变高，对性能有一定影响，样本值默认为5</strong>。</p>
<blockquote>
<p>从Redis的内存淘汰实现方案来看，虽然遵循了LRU思想但不完全照搬，根据实际应用场景进行trade-off。</p>
</blockquote>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>luoxn28</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/04/11/ye-mian-geng-huan-suan-fa/">http://luoxn28.github.io/2020/04/11/ye-mian-geng-huan-suan-fa/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://luoxn28.github.io/2020/04/11/ye-mian-geng-huan-suan-fa/" data-id="ckc7rx8as0052oqciytuht0o4" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aS07DQBAFwNz/0mGLBHbe6yFImSmvUHDiKS9a/Xs84ut5cd3/9/s9P3/t/lmPd1wYGBgfy0gOcX+sq3sS6tWd9QvCwMA4gHEf+PLH3MPagFuEbAwMDIz45+6/NQu4GBgYGOuMNonMv4uBgYHRFrE57z6JfEsjDwMDY2tG3nX//7/fMt/AwMD4KMazvJLSNG/Pzc7wy6kwMDC2ZuQBLi9Wk3J3ZVB6eScGBsYxjLwF1i5eJElnXvrWFTMGBsZGjNkD2iA7O8MLHgYGxqaMthxtC9e2of9noRYDA2Mjxkp4nTXdZqTkcwwMjF0ZbSu/PWgb3Ns7MTAwTmDMwmX+OtYXLOrSFwMDYzvGSrNsFi5nCeiLp2NgYGzNaEebbRI5a+SthGAMDIz9GElwbFO9dmyZJ4iXn2BgYBzAmC1vzY6VtO2GyxYYGBhbM5Jj3ZeRSTo4K4ajYI2BgXEM4/6n24Z+OzCYLVtgYGCcwMiHjitLYO2xkhbei+UwDAyMAxh5uGzXLPIEMW/YYWBgnMNof3pWprYrGvlrxcDAOIExGwbMBgnt4kU0qcTAwNiU8SyvlZWLHNyOOTEwMPZmtAG0bfS3ryYfQuRrIhgYGHsw8kI057VHbwMuBgbGmYw28LVp3zrvxdMxMDAwRmsTK+lm3QTEwMDAKANr3tbPV9D+OOBiYGB8IGN9YSIfPBQJXz7OxMDA2JrRLk/UC1sLCxnrCSgGBsaHM74A0ci8KmVuEgQAAAAASUVORK5CYII=">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/04/11/linux-inode-na-xie-shi-er/">Linux inode那些事儿</a><a class="next" href="/2020/04/08/ci-pan-io/">磁盘IO</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0eda0c4ea18dd9042b41',
  clientSecret: 'df032ab700b83adbcaaf2f74eee0004c1ada25df',
  repo: 'luoxn28.github.io.gittalk',
  owner: 'luoxn28',
  admin: ['luoxn28'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架研究/">框架研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/influxdb/" style="font-size: 15px;">influxdb</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/sentinel/" style="font-size: 15px;">sentinel</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-provider-filter-lian-shi-ru-he-gou-jian-de/">Dubbo provider Filter链是如何构建的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/dubbo-rpc-zai-provider-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在provider端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/dubbo-provider-shi-ru-he-qi-dong-de/">dubbo provider是如何启动的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/dubbo-lian-tong-xing-tao-lun/">Dubbo连通性讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/dubbo-xian-cheng-mo-xing/">Dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/04/dubbo-rpc-zai-consumer-duan-shi-ru-he-pao-qi-lai-de/">Dubbo RPC在consumer端是如何跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/dubbo-de-fa-zhan-li-cheng/">dubbo的发展历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/ze-ren-lian-de-2-chong-shi-xian-fang-shi/">责任链的2种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-mmap/">Linux mmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/19/linux-guan-dao/">Linux管道</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">luoxn28.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>